From ccbd02a2adbea030221323a830a666fd2ca219c7 Mon Sep 17 00:00:00 2001
From: Aaron <kljsandjb@me.com>
Date: Thu, 1 Oct 2020 13:06:11 +0000
Subject: [PATCH] start with lab 6

initialized transmit, TX is ready
transmit finished

root@9dfe7b025747:/usr/src/app/lab# tcpdump -XXnr qemu.pcap
reading from file qemu.pcap, link-type EN10MB (Ethernet)
20:44:41.795394 [|ether]
        0x0000:  6865 6c6c 6f2c 2077 6f72 6c64 0a         hello,.world.
20:44:41.797814 [|ether]
        0x0000:  6865 6c6c 6f2c 2077 6f72 6c64 0a         hello,.world.
20:44:41.801232 [|ether]
        0x0000:  6865 6c6c 6f2c 2077 6f72 6c64 0a         hello,.world.
20:44:41.806917 [|ether]
        0x0000:  6865 6c6c 6f2c 2077 6f72 6c64 0a         hello,.world.
20:44:41.812211 [|ether]
        0x0000:  6865 6c6c 6f2c 2077 6f72 6c64 0a         hello,.world.
---
 kern/e1000.c    | 80 +++++++++++++++++++++++++++++++++++++++++++++++++
 kern/e1000.h    | 41 +++++++++++++++++++++++++
 kern/pci.c      |  8 +++++
 kern/syscall.c  |  4 ++-
 kern/trap.c     |  5 +---
 user/testtime.c |  4 ++-
 6 files changed, 136 insertions(+), 6 deletions(-)

diff --git a/kern/e1000.c b/kern/e1000.c
index 192f317..9a2b284 100644
--- a/kern/e1000.c
+++ b/kern/e1000.c
@@ -1,4 +1,84 @@
 #include <kern/e1000.h>
 #include <kern/pmap.h>
+#include <kern/pci.h>
+#include <inc/string.h>
 
 // LAB 6: Your driver code here
+
+// register descriptor layout, 64 descriptors, each with 16 byte
+// 8 descriptors within a group, total 8 groups, 1KB ring buffer.
+// needs to be 16-byte aligned
+struct tx_desc
+{
+	uint64_t addr;  // only fill low 32 bits
+	uint16_t length;
+	uint8_t cso;
+	uint8_t cmd;
+	uint8_t status;
+	uint8_t css;
+	uint16_t special;
+} __attribute__ ((aligned (16)));
+
+struct tx_desc tdesc[64];  // TDESC ring buffer, max 64
+
+int e1000_transmit(void *buffer, size_t size);
+
+//  wrap pci_func_enable function
+int pci_func_attach(struct pci_func *pcif)
+{
+    pci_func_enable(pcif);
+
+    // allocating buffer space for each TDESC, a PAGE can hold 2 MTU
+    size_t tdesc_length = sizeof(tdesc) / sizeof(struct tx_desc);
+    for (int i = 0; i < tdesc_length; i+=2)
+    {
+        tdesc[i].addr = page2pa(page_alloc(ALLOC_ZERO));
+        tdesc[i].length = MTU;
+        tdesc[i].cmd |= 0b1000; // set RS bit to report status of each descriptor
+        tdesc[i].status |= 0b1; // enable DD bit by default, clear when transmitting
+        
+        // assign another half to the second one
+        tdesc[i + 1].addr = tdesc[i].addr + PGSIZE / 2;
+        tdesc[i + 1].length = MTU;
+        tdesc[i + 1].cmd |= 0b1000;
+        tdesc[i + 1].status |= 0b1;
+    }
+
+    // perform initialization in Chapter 14.5, for TX
+    e1000_bar0[E1000_TDBAH / sizeof(uint32_t)] = 0;     // high 32 bit is cleared
+    e1000_bar0[E1000_TDBAL / sizeof(uint32_t)] = PADDR(tdesc);     // base address as descriptor array's physical address
+    e1000_bar0[E1000_TDLEN / sizeof(uint32_t)] = sizeof(tdesc);    // total 1024 bytes
+    e1000_bar0[E1000_TDH / sizeof(uint32_t)] = 0x0;        // initialized as 0, Hardware is responsible to update this
+    e1000_bar0[E1000_TDT / sizeof(uint32_t)] = 0x0;        // initialized as 0, Software is responsible to update this
+    e1000_bar0[E1000_TCTL / sizeof(uint32_t)] = (0x40 << 12) | 0b1010;    // enable TX, full-duplex operation
+    e1000_bar0[E1000_TIPG / sizeof(uint32_t)] = 10;        // IEEE 802.3 standard IPG
+
+    char *sample = "hello, world\n";
+    for (int i = 0; i < 142; i++)
+        e1000_transmit(sample, strlen(sample));
+
+    return 0;
+}
+
+int e1000_transmit(void *buffer, size_t size)
+{
+    uint32_t current = e1000_bar0[E1000_TDT / sizeof(uint32_t)];
+    uint32_t next = current + 1;
+    if (tdesc[current].status & 0b1)
+    {
+        tdesc[current].status &= ~0b1;
+        void *addr = (void *)KADDR((uint32_t)tdesc[current].addr);
+        memcpy(addr, buffer, MIN(size, MTU));
+        tdesc[current].cmd |= 0b1;      // End of Packet
+        tdesc[current].length = MIN(size, MTU);
+        // update tail pointer, inform network card
+        e1000_bar0[E1000_TDT / sizeof(uint32_t)] = next % (sizeof(tdesc) / sizeof(struct tx_desc));
+        return 0;
+    }
+    else
+    {
+        // require for re-transmission
+        cprintf("lost packet 0x%x\n", buffer);
+        return -1;
+    }
+}
\ No newline at end of file
diff --git a/kern/e1000.h b/kern/e1000.h
index 8b5a513..a501d38 100644
--- a/kern/e1000.h
+++ b/kern/e1000.h
@@ -1,3 +1,44 @@
 #ifndef JOS_KERN_E1000_H
 #define JOS_KERN_E1000_H
+
+#include <inc/types.h>
+
+#define E1000_VENDOR_ID 0x8086
+#define E1000_DEVICE_ID 0x100E
+
+#define MTU 1518
+
+#define E1000_STATUS   0x00008  /* Device Status - RO */
+
+#define E1000_TDBAL    0x03800  /* TX Descriptor Base Address Low - RW */
+#define E1000_TDBAH    0x03804  /* TX Descriptor Base Address High - RW */
+#define E1000_TDLEN    0x03808  /* TX Descriptor Length - RW */
+#define E1000_TDH      0x03810  /* TX Descriptor Head - RW */
+#define E1000_TDT      0x03818  /* TX Descripotr Tail - RW */
+
+/* Transmit Control */
+#define E1000_TCTL     0x00400  /* TX Control - RW */
+// #define E1000_TCTL_RST    0x00000001    /* software reset */
+#define E1000_TCTL_EN     0x00000002    /* enable tx */
+// #define E1000_TCTL_BCE    0x00000004    /* busy check enable */
+#define E1000_TCTL_PSP    0x00000008    /* pad short packets */
+#define E1000_TCTL_CT     0x00000ff0    /* collision threshold */
+#define E1000_TCTL_COLD   0x003ff000    /* collision distance */
+// #define E1000_TCTL_SWXOFF 0x00400000    /* SW Xoff transmission */
+// #define E1000_TCTL_PBE    0x00800000    /* Packet Burst Enable */
+// #define E1000_TCTL_RTLC   0x01000000    /* Re-transmit on late collision */
+// #define E1000_TCTL_NRTU   0x02000000    /* No Re-transmit on underrun */
+// #define E1000_TCTL_MULR   0x10000000    /* Multiple request support */
+
+#define E1000_TIPG     0x00410  /* TX Inter-packet gap -RW */
+
+#define E1000_TXD_CMD_RS     0x08000000 /* Report Status */
+#define E1000_TXD_STAT_DD    0x00000001 /* Descriptor Done */
+
+volatile uint32_t *e1000_bar0;      // memory mapped E1000 device registers
+
+
+/* Receive Control */
+
+
 #endif  // SOL >= 6
diff --git a/kern/pci.c b/kern/pci.c
index 784e072..519f172 100644
--- a/kern/pci.c
+++ b/kern/pci.c
@@ -4,6 +4,7 @@
 #include <kern/pci.h>
 #include <kern/pcireg.h>
 #include <kern/e1000.h>
+#include <kern/pmap.h>
 
 // Flag to do "lspci" at bootup
 static int pci_show_devs = 1;
@@ -15,6 +16,7 @@ static uint32_t pci_conf1_data_ioport = 0x0cfc;
 
 // Forward declarations
 static int pci_bridge_attach(struct pci_func *pcif);
+extern int pci_func_attach(struct pci_func *pcif);
 
 // PCI driver table
 struct pci_driver {
@@ -31,6 +33,7 @@ struct pci_driver pci_attach_class[] = {
 // pci_attach_vendor matches the vendor ID and device ID of a PCI device. key1
 // and key2 should be the vendor ID and device ID respectively
 struct pci_driver pci_attach_vendor[] = {
+	{ E1000_VENDOR_ID, E1000_DEVICE_ID, &pci_func_attach },
 	{ 0, 0, 0 },
 };
 
@@ -233,6 +236,9 @@ pci_func_enable(struct pci_func *f)
 		f->reg_base[regnum] = base;
 		f->reg_size[regnum] = size;
 
+		if (regnum == 0)
+			e1000_bar0 = mmio_map_region(base, size);
+
 		if (size && !base)
 			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
 				"may be misconfigured: "
@@ -245,6 +251,8 @@ pci_func_enable(struct pci_func *f)
 	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
 		f->bus->busno, f->dev, f->func,
 		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
+	cprintf("Device status for E1000 BAR 0 is 0x%x\n",
+		e1000_bar0[E1000_STATUS / sizeof(uint32_t)]);
 }
 
 int
diff --git a/kern/syscall.c b/kern/syscall.c
index e794918..fb9afa9 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -391,7 +391,7 @@ static int
 sys_time_msec(void)
 {
 	// LAB 6: Your code here.
-	panic("sys_time_msec not implemented");
+	return time_msec();
 }
 
 static void
@@ -453,6 +453,8 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
 		return sys_ipc_try_send(a1, a2, (void *)a3, a4);
 	case SYS_ipc_recv:
 		return sys_ipc_recv((void *)a1);
+	case SYS_time_msec:
+		return sys_time_msec();
 	case SYS_ide_sleep:
 		sys_ide_sleep((void *)a1, a2, (int)a3);
 	case NSYSCALLS:
diff --git a/kern/trap.c b/kern/trap.c
index 37014bf..ce81dd4 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -242,6 +242,7 @@ trap_dispatch(struct Trapframe *tf)
 		switch (tf->tf_trapno)
 		{
 		case IRQ_OFFSET + IRQ_TIMER:
+			time_tick();
 			lapic_eoi();
 			sched_yield();
 			break;
@@ -296,10 +297,6 @@ trap_dispatch(struct Trapframe *tf)
 	// triggered on every CPU.
 	// LAB 6: Your code here.
 
-
-	// Handle keyboard and serial interrupts.
-	// LAB 5: Your code here.
-
 	// Unexpected trap: The user process or the kernel has a bug.
 	print_trapframe(tf);
 	if (tf->tf_cs == GD_KT)
diff --git a/user/testtime.c b/user/testtime.c
index 68e350c..26a9975 100644
--- a/user/testtime.c
+++ b/user/testtime.c
@@ -22,7 +22,9 @@ umain(int argc, char **argv)
 	int i;
 
 	// Wait for the console to calm down
-	for (i = 0; i < 50; i++)
+	// since I enabled disk interrupt, so count down will not be
+	// continous sometimes, so increase the yielding times
+	for (i = 0; i < 400; i++)
 		sys_yield();
 
 	cprintf("starting count down: ");
-- 
2.20.1

