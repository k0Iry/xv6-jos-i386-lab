From 101ce64dcab9cc2d00af4e38c82c2f344817b64d Mon Sep 17 00:00:00 2001
From: Aaron <kljsandjb@me.com>
Date: Thu, 1 Oct 2020 13:06:11 +0000
Subject: [PATCH] start with lab 6

---
 kern/e1000.c    | 8 ++++++++
 kern/e1000.h    | 4 ++++
 kern/pci.c      | 2 ++
 kern/syscall.c  | 4 +++-
 kern/trap.c     | 5 +----
 user/testtime.c | 4 +++-
 6 files changed, 21 insertions(+), 6 deletions(-)

diff --git a/kern/e1000.c b/kern/e1000.c
index 192f317..d66e317 100644
--- a/kern/e1000.c
+++ b/kern/e1000.c
@@ -1,4 +1,12 @@
 #include <kern/e1000.h>
 #include <kern/pmap.h>
+#include <kern/pci.h>
 
 // LAB 6: Your driver code here
+
+//  wrap pci_func_enable function
+int pci_func_attach(struct pci_func *pcif)
+{
+    pci_func_enable(pcif);
+    return 0;
+}
\ No newline at end of file
diff --git a/kern/e1000.h b/kern/e1000.h
index 8b5a513..5874ceb 100644
--- a/kern/e1000.h
+++ b/kern/e1000.h
@@ -1,3 +1,7 @@
 #ifndef JOS_KERN_E1000_H
 #define JOS_KERN_E1000_H
+
+#define E1000_VENDOR_ID 0x8086
+#define E1000_DEVICE_ID 0x100E
+
 #endif  // SOL >= 6
diff --git a/kern/pci.c b/kern/pci.c
index 784e072..4fd6f4e 100644
--- a/kern/pci.c
+++ b/kern/pci.c
@@ -15,6 +15,7 @@ static uint32_t pci_conf1_data_ioport = 0x0cfc;
 
 // Forward declarations
 static int pci_bridge_attach(struct pci_func *pcif);
+extern int pci_func_attach(struct pci_func *pcif);
 
 // PCI driver table
 struct pci_driver {
@@ -31,6 +32,7 @@ struct pci_driver pci_attach_class[] = {
 // pci_attach_vendor matches the vendor ID and device ID of a PCI device. key1
 // and key2 should be the vendor ID and device ID respectively
 struct pci_driver pci_attach_vendor[] = {
+	{ E1000_VENDOR_ID, E1000_DEVICE_ID, &pci_func_attach },
 	{ 0, 0, 0 },
 };
 
diff --git a/kern/syscall.c b/kern/syscall.c
index e794918..fb9afa9 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -391,7 +391,7 @@ static int
 sys_time_msec(void)
 {
 	// LAB 6: Your code here.
-	panic("sys_time_msec not implemented");
+	return time_msec();
 }
 
 static void
@@ -453,6 +453,8 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
 		return sys_ipc_try_send(a1, a2, (void *)a3, a4);
 	case SYS_ipc_recv:
 		return sys_ipc_recv((void *)a1);
+	case SYS_time_msec:
+		return sys_time_msec();
 	case SYS_ide_sleep:
 		sys_ide_sleep((void *)a1, a2, (int)a3);
 	case NSYSCALLS:
diff --git a/kern/trap.c b/kern/trap.c
index 37014bf..ce81dd4 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -242,6 +242,7 @@ trap_dispatch(struct Trapframe *tf)
 		switch (tf->tf_trapno)
 		{
 		case IRQ_OFFSET + IRQ_TIMER:
+			time_tick();
 			lapic_eoi();
 			sched_yield();
 			break;
@@ -296,10 +297,6 @@ trap_dispatch(struct Trapframe *tf)
 	// triggered on every CPU.
 	// LAB 6: Your code here.
 
-
-	// Handle keyboard and serial interrupts.
-	// LAB 5: Your code here.
-
 	// Unexpected trap: The user process or the kernel has a bug.
 	print_trapframe(tf);
 	if (tf->tf_cs == GD_KT)
diff --git a/user/testtime.c b/user/testtime.c
index 68e350c..26a9975 100644
--- a/user/testtime.c
+++ b/user/testtime.c
@@ -22,7 +22,9 @@ umain(int argc, char **argv)
 	int i;
 
 	// Wait for the console to calm down
-	for (i = 0; i < 50; i++)
+	// since I enabled disk interrupt, so count down will not be
+	// continous sometimes, so increase the yielding times
+	for (i = 0; i < 400; i++)
 		sys_yield();
 
 	cprintf("starting count down: ");
-- 
2.20.1

