From 9512416da80416bf07724068b46e1ea5eec4b655 Mon Sep 17 00:00:00 2001
From: Aaron <kljsandjb@me.com>
Date: Thu, 1 Oct 2020 13:06:11 +0000
Subject: [PATCH] start with lab 6

initialized transmit, TX is ready
transmit finished, added system call

root@9dfe7b025747:/usr/src/app/lab# tcpdump -XXnr qemu.pcap
reading from file qemu.pcap, link-type EN10MB (Ethernet)
20:44:41.795394 [|ether]
        0x0000:  6865 6c6c 6f2c 2077 6f72 6c64 0a         hello,.world.
20:44:41.797814 [|ether]
        0x0000:  6865 6c6c 6f2c 2077 6f72 6c64 0a         hello,.world.
20:44:41.801232 [|ether]
        0x0000:  6865 6c6c 6f2c 2077 6f72 6c64 0a         hello,.world.
20:44:41.806917 [|ether]
        0x0000:  6865 6c6c 6f2c 2077 6f72 6c64 0a         hello,.world.
20:44:41.812211 [|ether]
        0x0000:  6865 6c6c 6f2c 2077 6f72 6c64 0a         hello,.world.
---
 inc/lib.h       |   1 +
 inc/syscall.h   |   1 +
 kern/e1000.c    | 101 ++++++++++++++++++++++++++++++++++++++++++++++++
 kern/e1000.h    |  15 +++++++
 kern/pci.c      |   8 ++++
 kern/syscall.c  |  14 ++++++-
 kern/trap.c     |   5 +--
 lib/syscall.c   |   6 +++
 user/testtime.c |   4 +-
 9 files changed, 149 insertions(+), 6 deletions(-)

diff --git a/inc/lib.h b/inc/lib.h
index 0850acb..24bec7a 100644
--- a/inc/lib.h
+++ b/inc/lib.h
@@ -61,6 +61,7 @@ int	sys_ipc_try_send(envid_t to_env, uint32_t value, void *pg, int perm);
 int	sys_ipc_recv(void *rcv_pg);
 unsigned int sys_time_msec(void);
 void sys_ide_sleep(void *chan, size_t nsecs, int op);
+int sys_send(const void *buffer, size_t length);
 
 // This must be inlined.  Exercise for reader: why?
 static inline envid_t __attribute__((always_inline))
diff --git a/inc/syscall.h b/inc/syscall.h
index 23c5278..612f9be 100644
--- a/inc/syscall.h
+++ b/inc/syscall.h
@@ -19,6 +19,7 @@ enum {
 	SYS_ipc_recv,
 	SYS_time_msec,
 	SYS_ide_sleep,
+	SYS_send,
 	NSYSCALLS
 };
 
diff --git a/kern/e1000.c b/kern/e1000.c
index 192f317..955465d 100644
--- a/kern/e1000.c
+++ b/kern/e1000.c
@@ -1,4 +1,105 @@
 #include <kern/e1000.h>
 #include <kern/pmap.h>
+#include <kern/pci.h>
+#include <inc/string.h>
 
 // LAB 6: Your driver code here
+
+// divided by 4 for use as uint32_t[] indices.
+
+#define E1000_TDBAL    (0x03800/4)  /* TX Descriptor Base Address Low - RW */
+#define E1000_TDBAH    (0x03804/4)  /* TX Descriptor Base Address High - RW */
+#define E1000_TDLEN    (0x03808/4)  /* TX Descriptor Length - RW */
+#define E1000_TDH      (0x03810/4)  /* TX Descriptor Head - RW */
+#define E1000_TDT      (0x03818/4)  /* TX Descripotr Tail - RW */
+
+/* Transmit Control */
+#define E1000_TCTL     (0x00400/4)  /* TX Control - RW */
+#define E1000_TIPG     (0x00410/4)  /* TX Inter-packet gap -RW */
+
+#define E1000_TXD_CMD_RS     0x08000000 /* Report Status */
+#define E1000_TXD_STAT_DD    0x00000001 /* Descriptor Done */
+
+#define MTU 1518
+
+// register descriptor layout, 64 descriptors, each with 16 byte
+// 8 descriptors within a group, total 8 groups, 1KB ring buffer.
+// needs to be 16-byte aligned
+struct tx_desc
+{
+	uint64_t addr;  // only fill low 32 bits
+	uint16_t length;
+	uint8_t cso;
+	uint8_t cmd;
+	uint8_t status;
+	uint8_t css;
+	uint16_t special;
+} __attribute__ ((aligned (16)));
+
+struct tx_desc tdesc[64];  // TDESC ring buffer, max 64
+
+//  wrap pci_func_enable function
+int pci_func_attach(struct pci_func *pcif)
+{
+    pci_func_enable(pcif);
+
+    // allocating buffer space for each TDESC, a PAGE can hold 2 MTU
+    size_t tdesc_length = sizeof(tdesc) / sizeof(struct tx_desc);
+    for (int i = 0; i < tdesc_length; i+=2)
+    {
+        tdesc[i].addr = page2pa(page_alloc(ALLOC_ZERO));
+        tdesc[i].cmd |= (E1000_TXD_CMD_RS >> 24); // set RS bit to report status of each descriptor
+        tdesc[i].status |= E1000_TXD_STAT_DD; // enable DD bit by default, clear when transmitting
+        
+        // assign another half to the second one
+        tdesc[i + 1].addr = tdesc[i].addr + PGSIZE / 2;
+        tdesc[i + 1].cmd |= (E1000_TXD_CMD_RS >> 24);
+        tdesc[i + 1].status |= E1000_TXD_STAT_DD;
+    }
+
+    // perform initialization in Chapter 14.5, for TX
+    e1000_bar0[E1000_TDBAH] = 0;     // high 32 bit is cleared
+    e1000_bar0[E1000_TDBAL] = PADDR(tdesc);     // base address as descriptor array's physical address
+    e1000_bar0[E1000_TDLEN ] = sizeof(tdesc);    // total 1024 bytes
+    e1000_bar0[E1000_TDH] = 0x0;        // initialized as 0, Hardware is responsible to update this
+    e1000_bar0[E1000_TDT] = 0x0;        // initialized as 0, Software is responsible to update this
+    e1000_bar0[E1000_TCTL] = (0x40 << 12) | 0b1010;    // enable TX, full-duplex operation
+    e1000_bar0[E1000_TIPG] = 10;        // IEEE 802.3 standard IPG
+
+    /* self test with overflow and transmission*/
+    char *sample = "hello, world, let's transmit something\n";
+    for (int i = 0; i < 142; i++)
+        e1000_transmit(sample, strlen(sample));
+
+    return 0;
+}
+
+/*
+ * transmit a packet
+ * 
+ * return number of bytes transmitted
+ * return 0 if this packet needs re-transmission
+*/
+size_t e1000_transmit(const void *buffer, size_t size)
+{
+    uint32_t current = e1000_bar0[E1000_TDT];
+    if (tdesc[current].status & E1000_TXD_STAT_DD)
+    {
+        tdesc[current].status &= ~E1000_TXD_STAT_DD;
+        void *addr = (void *)KADDR((uint32_t)tdesc[current].addr);
+        size_t length = MIN(size, MTU);
+        memcpy(addr, buffer, length);
+        tdesc[current].cmd |= 0b1;      // End of Packet
+        tdesc[current].length = length;
+        // update tail pointer, inform network card
+        uint32_t next = current + 1;
+        e1000_bar0[E1000_TDT] = next % (sizeof(tdesc) / sizeof(struct tx_desc));
+        return length;
+    }
+    else
+    {
+        // require for re-transmission
+        cprintf("lost packet 0x%x\n", buffer);
+        return 0;
+    }
+}
\ No newline at end of file
diff --git a/kern/e1000.h b/kern/e1000.h
index 8b5a513..7a9ecfa 100644
--- a/kern/e1000.h
+++ b/kern/e1000.h
@@ -1,3 +1,18 @@
 #ifndef JOS_KERN_E1000_H
 #define JOS_KERN_E1000_H
+
+#include <inc/types.h>
+
+#define E1000_VENDOR_ID 0x8086
+#define E1000_DEVICE_ID 0x100E
+
+#define E1000_STATUS   (0x00008/4)  /* Device Status - RO */
+
+volatile uint32_t *e1000_bar0;      // memory mapped E1000 device registers
+
+size_t e1000_transmit(const void *buffer, size_t size);
+
+/* Receive Control */
+
+
 #endif  // SOL >= 6
diff --git a/kern/pci.c b/kern/pci.c
index 784e072..5ad5ae7 100644
--- a/kern/pci.c
+++ b/kern/pci.c
@@ -4,6 +4,7 @@
 #include <kern/pci.h>
 #include <kern/pcireg.h>
 #include <kern/e1000.h>
+#include <kern/pmap.h>
 
 // Flag to do "lspci" at bootup
 static int pci_show_devs = 1;
@@ -15,6 +16,7 @@ static uint32_t pci_conf1_data_ioport = 0x0cfc;
 
 // Forward declarations
 static int pci_bridge_attach(struct pci_func *pcif);
+extern int pci_func_attach(struct pci_func *pcif);
 
 // PCI driver table
 struct pci_driver {
@@ -31,6 +33,7 @@ struct pci_driver pci_attach_class[] = {
 // pci_attach_vendor matches the vendor ID and device ID of a PCI device. key1
 // and key2 should be the vendor ID and device ID respectively
 struct pci_driver pci_attach_vendor[] = {
+	{ E1000_VENDOR_ID, E1000_DEVICE_ID, &pci_func_attach },
 	{ 0, 0, 0 },
 };
 
@@ -233,6 +236,9 @@ pci_func_enable(struct pci_func *f)
 		f->reg_base[regnum] = base;
 		f->reg_size[regnum] = size;
 
+		if (regnum == 0)
+			e1000_bar0 = mmio_map_region(base, size);
+
 		if (size && !base)
 			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
 				"may be misconfigured: "
@@ -245,6 +251,8 @@ pci_func_enable(struct pci_func *f)
 	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
 		f->bus->busno, f->dev, f->func,
 		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
+	cprintf("Device status for E1000 BAR 0 is 0x%x\n",
+		e1000_bar0[E1000_STATUS]);
 }
 
 int
diff --git a/kern/syscall.c b/kern/syscall.c
index e794918..10baf38 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -12,6 +12,7 @@
 #include <kern/console.h>
 #include <kern/sched.h>
 #include <kern/time.h>
+#include <kern/e1000.h>
 
 // Print a string to the system console.
 // The string is exactly 'len' characters long.
@@ -391,7 +392,7 @@ static int
 sys_time_msec(void)
 {
 	// LAB 6: Your code here.
-	panic("sys_time_msec not implemented");
+	return time_msec();
 }
 
 static void
@@ -413,6 +414,13 @@ sys_ide_sleep(void *chan, size_t nsecs, int op)
 	sched_yield();
 }
 
+static int
+sys_send(const void *buffer, size_t length)
+{
+	user_mem_assert(curenv, buffer, length, PTE_U);
+	return (int)e1000_transmit(buffer, length);
+}
+
 // Dispatches to the correct kernel function, passing the arguments.
 int32_t
 syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
@@ -453,8 +461,12 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
 		return sys_ipc_try_send(a1, a2, (void *)a3, a4);
 	case SYS_ipc_recv:
 		return sys_ipc_recv((void *)a1);
+	case SYS_time_msec:
+		return sys_time_msec();
 	case SYS_ide_sleep:
 		sys_ide_sleep((void *)a1, a2, (int)a3);
+	case SYS_send:
+		return sys_send((const void*)a1, a2);
 	case NSYSCALLS:
 	default:
 		return -E_INVAL;
diff --git a/kern/trap.c b/kern/trap.c
index 37014bf..ce81dd4 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -242,6 +242,7 @@ trap_dispatch(struct Trapframe *tf)
 		switch (tf->tf_trapno)
 		{
 		case IRQ_OFFSET + IRQ_TIMER:
+			time_tick();
 			lapic_eoi();
 			sched_yield();
 			break;
@@ -296,10 +297,6 @@ trap_dispatch(struct Trapframe *tf)
 	// triggered on every CPU.
 	// LAB 6: Your code here.
 
-
-	// Handle keyboard and serial interrupts.
-	// LAB 5: Your code here.
-
 	// Unexpected trap: The user process or the kernel has a bug.
 	print_trapframe(tf);
 	if (tf->tf_cs == GD_KT)
diff --git a/lib/syscall.c b/lib/syscall.c
index 8663cfd..210f9de 100644
--- a/lib/syscall.c
+++ b/lib/syscall.c
@@ -170,3 +170,9 @@ sys_ide_sleep(void *chan, size_t nsecs, int op)
 	// can't use sysenter, since we need to restore our flags from trapframe
 	syscall(SYS_ide_sleep, 0, (uint32_t)chan, nsecs, (uint32_t)op, 0, 0);
 }
+
+int 
+sys_send(const void *buffer, size_t length)
+{
+	return sysenter(SYS_send, (uint32_t)buffer, length, 0, 0);
+}
diff --git a/user/testtime.c b/user/testtime.c
index 68e350c..26a9975 100644
--- a/user/testtime.c
+++ b/user/testtime.c
@@ -22,7 +22,9 @@ umain(int argc, char **argv)
 	int i;
 
 	// Wait for the console to calm down
-	for (i = 0; i < 50; i++)
+	// since I enabled disk interrupt, so count down will not be
+	// continous sometimes, so increase the yielding times
+	for (i = 0; i < 400; i++)
 		sys_yield();
 
 	cprintf("starting count down: ");
-- 
2.20.1

