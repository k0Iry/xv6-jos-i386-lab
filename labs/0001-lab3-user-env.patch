From 0b908b8e0bd4314ded92f2c4a1e0188b22376d4a Mon Sep 17 00:00:00 2001
From: Aaron <kljsandjb@me.com>
Date: Thu, 18 Jun 2020 18:47:15 +0200
Subject: [PATCH] lab3 user env

now we can hit SIGTRAP because the
hardware cannot handle switch from user to kernel space

fix showmappings function so it will skip unmapped pages
and continue print available mappings

passed divzero, softint, badsegment & breakpoint tests
---
 kern/env.c       | 73 +++++++++++++++++++++++++++++++++++++++++++++--
 kern/monitor.c   | 10 +++----
 kern/pmap.c      |  4 +++
 kern/trap.c      | 74 ++++++++++++++++++++++++++++++++++++++++++++++++
 kern/trapentry.S | 39 ++++++++++++++++++++++++-
 5 files changed, 191 insertions(+), 9 deletions(-)

diff --git a/kern/env.c b/kern/env.c
index db2fda9..3a121d6 100644
--- a/kern/env.c
+++ b/kern/env.c
@@ -116,6 +116,12 @@ env_init(void)
 {
 	// Set up envs array
 	// LAB 3: Your code here.
+	for (int i = NENV - 1; i >= 0; i--)
+	{
+		envs[i].env_id = 0;
+		envs[i].env_link = env_free_list;
+		env_free_list = envs + i;
+	}
 
 	// Per-CPU part of the initialization
 	env_init_percpu();
@@ -179,9 +185,18 @@ env_setup_vm(struct Env *e)
 	//    - The functions in kern/pmap.h are handy.
 
 	// LAB 3: Your code here.
-
+	p->pp_ref++;
+	e->env_pgdir = (pte_t *)page2kva(p);
+	// we can copy kern part of PDEs from kern_pgdir
+	// no need to allocate more physical memory and map again
+	for (int start = PDX(UTOP); start < 1024; start ++)
+	{
+		e->env_pgdir[start] = kern_pgdir[start];
+	}
 	// UVPT maps the env's own page table read-only.
 	// Permissions: kernel R, user R
+	// need to update, if we keep the copy from kern_pgdir,
+	// it will point to kern_pgdir itself, not env_pgdir
 	e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;
 
 	return 0;
@@ -267,6 +282,19 @@ region_alloc(struct Env *e, void *va, size_t len)
 	//   'va' and 'len' values that are not page-aligned.
 	//   You should round va down, and round (va + len) up.
 	//   (Watch out for corner-cases!)
+
+	// page that contains va & va + len
+	uint32_t start = (uint32_t)ROUNDDOWN(va, PGSIZE);
+	uint32_t end = (uint32_t)ROUNDUP(va + len, PGSIZE);
+
+	for (uint32_t va = start; va < end; va += PGSIZE)
+	{
+		pte_t *pgtbl = pgdir_walk(e->env_pgdir, (const void *)va, 1);
+		struct PageInfo *pg_info = page_alloc(0);
+		if (pg_info == NULL)
+			panic("page_alloc: %e", -E_NO_MEM);
+		*pgtbl = page2pa(pg_info) | PTE_P | PTE_U | PTE_W;
+	}
 }
 
 //
@@ -323,11 +351,34 @@ load_icode(struct Env *e, uint8_t *binary)
 	//  What?  (See env_run() and env_pop_tf() below.)
 
 	// LAB 3: Your code here.
-
+	struct Elf *elf_header = (struct Elf *)binary;
+	if (elf_header->e_magic != ELF_MAGIC)
+		panic("invalid elf file");
+
+	struct Proghdr *ph, *eph;
+	ph = (struct Proghdr *)((uint8_t *)elf_header + elf_header->e_phoff);
+	eph = ph + elf_header->e_phnum;
+
+	for (; ph < eph; ph++)
+	{
+		if (ph->p_type == ELF_PROG_LOAD && ph->p_filesz <= ph->p_memsz)
+		{
+			region_alloc(e, (void *)ph->p_va, ph->p_memsz);
+			lcr3(PADDR(e->env_pgdir));
+			memmove((void *)ph->p_va, (void*)(binary + ph->p_offset), ph->p_filesz);
+			lcr3(PADDR(kern_pgdir));
+		}
+	}
+	e->env_tf.tf_eip = elf_header->e_entry;
 	// Now map one page for the program's initial stack
 	// at virtual address USTACKTOP - PGSIZE.
 
 	// LAB 3: Your code here.
+	struct PageInfo *stack_page = page_alloc(ALLOC_ZERO);
+	if (page_insert(e->env_pgdir, stack_page, (void *)(USTACKTOP - PGSIZE), PTE_U | PTE_W) != 0)
+	{
+		panic("alloc user stack");
+	}
 }
 
 //
@@ -341,6 +392,11 @@ void
 env_create(uint8_t *binary, enum EnvType type)
 {
 	// LAB 3: Your code here.
+	struct Env *new_env;
+	if (env_alloc(&new_env, 0) != 0)
+		panic("env_alloc");
+	load_icode(new_env, binary);
+	new_env->env_type = type;
 }
 
 //
@@ -457,7 +513,18 @@ env_run(struct Env *e)
 	//	e->env_tf to sensible values.
 
 	// LAB 3: Your code here.
+	if (curenv != NULL && curenv != e)
+	{
+		if (curenv->env_status == ENV_RUNNING)
+			curenv->env_status = ENV_RUNNABLE;
+	}
+	curenv = e;
+	curenv->env_status = ENV_RUNNING;
+	curenv->env_runs ++;
+
+	lcr3(PADDR(curenv->env_pgdir));
+	env_pop_tf(&(curenv->env_tf));
 
-	panic("env_run not yet implemented");
+	// panic("env_run not yet implemented");
 }
 
diff --git a/kern/monitor.c b/kern/monitor.c
index 4959e59..0829208 100644
--- a/kern/monitor.c
+++ b/kern/monitor.c
@@ -109,16 +109,16 @@ int mon_showmappings(int argc, char **argv, struct Trapframe *tf)
 
 	size_t range = (high_addr - low_addr) / PGSIZE;
 
-	for (int i = 0; i <= range; i++)
+	for (int i = 0; i < range; i++)
 	{
 		pte_t *pgtbl_entry = NULL;
 		const void *vir_addr = (const void *)(low_addr + i * PGSIZE);
-		if (!(pgtbl_entry = pgdir_walk(entry_pgdir, vir_addr, 0)))
+		if (!(pgtbl_entry = pgdir_walk(entry_pgdir, vir_addr, 0)) || !(*pgtbl_entry & PTE_P))
 		{
-			if (!(pgtbl_entry = pgdir_walk(kern_pgdir, vir_addr, 0)))
+			if (!(pgtbl_entry = pgdir_walk(kern_pgdir, vir_addr, 0)) || !(*pgtbl_entry & PTE_P))
 			{
-				cprintf("Invalid mappings, perhaps accessing USER level, not supported yet\n");
-				return 1;
+				cprintf("Invalid mappings at 0x%08x, perhaps accessing USER level, not supported yet\n", vir_addr);
+				continue;
 			}
 		}
 		cprintf("\tVirtual address 0x%08x mapped to physical address 0x%08x\n", vir_addr, PTE_ADDR(*pgtbl_entry) + PGOFF(vir_addr));
diff --git a/kern/pmap.c b/kern/pmap.c
index 9b6334f..d58f72f 100644
--- a/kern/pmap.c
+++ b/kern/pmap.c
@@ -176,6 +176,9 @@ mem_init(void)
 	//////////////////////////////////////////////////////////////////////
 	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
 	// LAB 3: Your code here.
+	envs = (struct Env *) boot_alloc(NENV * sizeof(struct Env));
+	memset(envs, 0, NENV * sizeof(struct Env));
+	cprintf("envs are located starting from 0x%08x\n", PADDR(envs));
 
 	//////////////////////////////////////////////////////////////////////
 	// Now that we've allocated the initial kernel data structures, we set
@@ -208,6 +211,7 @@ mem_init(void)
 	//    - the new image at UENVS  -- kernel R, user R
 	//    - envs itself -- kernel RW, user NONE
 	// LAB 3: Your code here.
+	boot_map_region(kern_pgdir, UENVS, ROUNDUP(NENV * sizeof(struct Env), PGSIZE), PADDR(envs), PTE_U | PTE_W);
 
 	//////////////////////////////////////////////////////////////////////
 	// Use the physical memory that 'bootstack' refers to as the kernel
diff --git a/kern/trap.c b/kern/trap.c
index e27b556..f09eb48 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -25,6 +25,58 @@ struct Pseudodesc idt_pd = {
 	sizeof(idt) - 1, (uint32_t) idt
 };
 
+typedef void (*trap_handler)(void);
+
+void divide();
+void debug();
+void nmi();
+void brkpt();	// needs user level privilege
+void oflow();
+void bound();
+void illop();
+void device();
+void dblflt();
+void corproc();
+void tss();
+void segnp();
+void stack();
+void gpflt();
+void pgflt();	// needs kernel level privilege
+void res();
+void fperr();
+void align();
+void mchk();
+void simderr();
+void do_nothing(){}
+
+static trap_handler get_trap_handler(int trapno)
+{
+	static const trap_handler funcs[256] = {
+		divide,
+		debug,
+		nmi,
+		brkpt,
+		oflow,
+		bound,
+		illop,
+		device,
+		dblflt,
+		corproc,
+		tss,
+		segnp,
+		stack,
+		gpflt,
+		pgflt,
+		res,
+		fperr,
+		align,
+		mchk,
+		simderr,
+		[32 ... 255] = do_nothing
+	};
+
+	return funcs[trapno];
+}
 
 static const char *trapname(int trapno)
 {
@@ -65,6 +117,22 @@ trap_init(void)
 	extern struct Segdesc gdt[];
 
 	// LAB 3: Your code here.
+	int vector = 0;
+	for (; vector < 32; vector++)
+	{
+		// 0-31 for TRAPs
+		if (vector == T_BRKPT)
+		{
+			SETGATE(idt[vector], 1, GD_KT, get_trap_handler(vector), gdt[GD_UT >> 3].sd_dpl);
+			continue;
+		}
+		SETGATE(idt[vector], 1, GD_KT, get_trap_handler(vector), gdt[GD_KT >> 3].sd_dpl);
+	}
+	for (; vector < 256; vector++)
+	{
+		// 32 - 255 for IRQs (user defined)
+		SETGATE(idt[vector], 0, GD_KT, get_trap_handler(vector), gdt[GD_UT >> 3].sd_dpl);
+	}
 
 	// Per-CPU setup 
 	trap_init_percpu();
@@ -144,6 +212,12 @@ trap_dispatch(struct Trapframe *tf)
 {
 	// Handle processor exceptions.
 	// LAB 3: Your code here.
+	if (tf->tf_trapno == T_PGFLT)
+		page_fault_handler(tf);
+	if (tf->tf_trapno == T_BRKPT)
+	{
+		monitor(tf);
+	}
 
 	// Unexpected trap: The user process or the kernel has a bug.
 	print_trapframe(tf);
diff --git a/kern/trapentry.S b/kern/trapentry.S
index 22fc640..79aa12b 100644
--- a/kern/trapentry.S
+++ b/kern/trapentry.S
@@ -46,10 +46,47 @@
 /*
  * Lab 3: Your code here for generating entry points for the different traps.
  */
+TRAPHANDLER_NOEC(divide, T_DIVIDE)
+TRAPHANDLER_NOEC(debug, T_DEBUG)
+TRAPHANDLER_NOEC(nmi, T_NMI)
+TRAPHANDLER_NOEC(brkpt, T_BRKPT)
+TRAPHANDLER_NOEC(oflow, T_OFLOW)
+TRAPHANDLER_NOEC(bound, T_BOUND)
+TRAPHANDLER_NOEC(illop, T_ILLOP)
+TRAPHANDLER_NOEC(device, T_DEVICE)
+TRAPHANDLER_NOEC(corproc, 9)
+TRAPHANDLER_NOEC(fperr, T_FPERR)
+TRAPHANDLER_NOEC(mchk, T_MCHK)
+TRAPHANDLER_NOEC(simderr, T_SIMDERR)
 
-
+TRAPHANDLER(dblflt, T_DBLFLT)
+TRAPHANDLER(tss, T_TSS)
+TRAPHANDLER(segnp, T_SEGNP)
+TRAPHANDLER(stack, T_STACK)
+TRAPHANDLER(gpflt, T_GPFLT)
+TRAPHANDLER(pgflt, T_PGFLT)
+TRAPHANDLER(res,  15)
+TRAPHANDLER(align, T_ALIGN)
 
 /*
  * Lab 3: Your code here for _alltraps
  */
+.globl _alltraps;
+_alltraps:
+# push all rest registers on stack
+pushl %ds
+pushl %es
+pushal
+
+# Set up data segments.
+movw $(GD_KD), %ax
+movw %ax, %ds
+movw %ax, %es
+
+# Call trap(tf), where tf=%esp
+pushl %esp
+call trap
+
+# trap needs return back to user space
+# pop registers and return from interrupt (iret)
 
-- 
2.24.3 (Apple Git-128)

