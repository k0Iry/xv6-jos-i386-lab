From 4baf7cf0f7d754909159b1d9db8908e1c6dea64e Mon Sep 17 00:00:00 2001
From: Aaron <kljsandjb@me.com>
Date: Wed, 1 Jul 2020 19:51:32 +0000
Subject: [PATCH] starting with lab4...

finish Per-CPU State and Initialization, other than
ts_iomb initialization

Part A finished
---
 inc/lib.h        |  1 +
 kern/env.c       |  3 ++-
 kern/init.c      | 14 ++++++++++--
 kern/kernel.ld   |  1 -
 kern/mpentry.S   | 30 ++++++++++++++++++++++++
 kern/pmap.c      | 26 ++++++++++++++++++++-
 kern/sched.c     | 12 ++++++++++
 kern/syscall.c   | 70 ++++++++++++++++++++++++++++++++++++++++++++++++++------
 kern/trap.c      | 30 ++++++++++++++++--------
 kern/trapentry.S | 17 ++++++++++++++
 lib/syscall.c    | 20 ++++++++++++----
 11 files changed, 197 insertions(+), 27 deletions(-)

diff --git a/inc/lib.h b/inc/lib.h
index bff3fe1..2323960 100644
--- a/inc/lib.h
+++ b/inc/lib.h
@@ -55,6 +55,7 @@ int	sys_ipc_try_send(envid_t to_env, uint32_t value, void *pg, int perm);
 int	sys_ipc_recv(void *rcv_pg);
 
 // This must be inlined.  Exercise for reader: why?
+// Otherwise, child will call "fork" again and again...
 static inline envid_t __attribute__((always_inline))
 sys_exofork(void)
 {
diff --git a/kern/env.c b/kern/env.c
index a15fd9b..2163b03 100644
--- a/kern/env.c
+++ b/kern/env.c
@@ -55,7 +55,7 @@ struct Segdesc gdt[NCPU + 5] =
 
 	// Per-CPU TSS descriptors (starting from GD_TSS0) are initialized
 	// in trap_init_percpu()
-	[GD_TSS0 >> 3] = SEG_NULL
+	// [GD_TSS0 >> 3] = SEG_NULL
 };
 
 struct Pseudodesc gdt_pd = {
@@ -551,6 +551,7 @@ env_run(struct Env *e)
 	curenv->env_runs ++;
 
 	lcr3(PADDR(curenv->env_pgdir));
+	unlock_kernel();
 	env_pop_tf(&(curenv->env_tf));
 
 	// panic("env_run not yet implemented");
diff --git a/kern/init.c b/kern/init.c
index e5491ec..0a0faaa 100644
--- a/kern/init.c
+++ b/kern/init.c
@@ -43,6 +43,7 @@ i386_init(void)
 
 	// Acquire the big kernel lock before waking up APs
 	// Your code here:
+	lock_kernel();
 
 	// Starting non-boot CPUs
 	boot_aps();
@@ -52,7 +53,14 @@ i386_init(void)
 	ENV_CREATE(TEST, ENV_TYPE_USER);
 #else
 	// Touch all you want.
-	ENV_CREATE(user_primes, ENV_TYPE_USER);
+	ENV_CREATE(user_yield, ENV_TYPE_USER);
+	ENV_CREATE(user_yield, ENV_TYPE_USER);
+	ENV_CREATE(user_yield, ENV_TYPE_USER);
+	ENV_CREATE(user_yield, ENV_TYPE_USER);
+	ENV_CREATE(user_yield, ENV_TYPE_USER);
+	ENV_CREATE(user_yield, ENV_TYPE_USER);
+	ENV_CREATE(user_yield, ENV_TYPE_USER);
+	ENV_CREATE(user_yield, ENV_TYPE_USER);
 #endif // TEST*
 
 	// Schedule and run the first user environment!
@@ -109,9 +117,11 @@ mp_main(void)
 	// only one CPU can enter the scheduler at a time!
 	//
 	// Your code here:
+	lock_kernel();
+	sched_yield();
 
 	// Remove this after you finish Exercise 6
-	for (;;);
+	// for (;;);
 }
 
 /*
diff --git a/kern/kernel.ld b/kern/kernel.ld
index 1cf18ef..6263cea 100644
--- a/kern/kernel.ld
+++ b/kern/kernel.ld
@@ -54,7 +54,6 @@ SECTIONS
 		*(COMMON)
 		PROVIDE(end = .);
 	}
-	PROVIDE(end = .);
 
 
 	/DISCARD/ : {
diff --git a/kern/mpentry.S b/kern/mpentry.S
index 72dd827..ec03251 100644
--- a/kern/mpentry.S
+++ b/kern/mpentry.S
@@ -30,6 +30,32 @@
 #define RELOC(x) ((x) - KERNBASE)
 #define MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR)
 
+# MPBOOTPHYS is needed since mpentry.S is compiled and then linked to above KERNBASE
+# we cannot relay on this to calculate the global variables' addresses, current CPU
+# cannot dereference addresses that not even existed to it, it doesn't execute at linking
+# address
+
+# why boot.S doesn't need something like that? because boot loader is loaded and linked
+# at the same low address
+
+/* root@fb1f4f0cba44:/usr/src/app/lab# objdump -h obj/boot/boot.out
+
+obj/boot/boot.out:     file format elf32-i386
+
+Sections:
+Idx Name          Size      VMA       LMA       File off  Algn
+  0 .text         0000019f  00007c00  00007c00  00000074  2**2
+                  CONTENTS, ALLOC, LOAD, CODE
+  1 .eh_frame     000000a8  00007da0  00007da0  00000214  2**2
+                  CONTENTS, ALLOC, LOAD, READONLY, DATA
+  2 .stab         00000870  00000000  00000000  000002bc  2**2
+                  CONTENTS, READONLY, DEBUGGING
+  3 .stabstr      00000898  00000000  00000000  00000b2c  2**0
+                  CONTENTS, READONLY, DEBUGGING
+  4 .comment      0000002d  00000000  00000000  000013c4  2**0
+                  CONTENTS, READONLY
+*/
+
 .set PROT_MODE_CSEG, 0x8	# kernel code segment selector
 .set PROT_MODE_DSEG, 0x10	# kernel data segment selector
 
@@ -60,6 +86,10 @@ start32:
 	movw    %ax, %fs
 	movw    %ax, %gs
 
+	# just like cpu0, we enable PTE_PS bit
+	movl    %cr4, %eax
+	orl     $(CR4_PSE), %eax  # enable superpages (4MB)
+	movl    %eax, %cr4
 	# Set up initial page table. We cannot use kern_pgdir yet because
 	# we are still running at a low EIP.
 	movl    $(RELOC(entry_pgdir)), %eax
diff --git a/kern/pmap.c b/kern/pmap.c
index eb7d239..c727c95 100644
--- a/kern/pmap.c
+++ b/kern/pmap.c
@@ -293,6 +293,11 @@ mem_init_mp(void)
 	//
 	// LAB 4: Your code here:
 
+	for (int i = 0; i < NCPU; i++)
+	{
+		uintptr_t kstacktop = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);
+		boot_map_region(kern_pgdir, kstacktop - KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W);
+	}
 }
 
 // --------------------------------------------------------------
@@ -333,9 +338,16 @@ page_init(void)
 	// free pages!
 	pages[0].pp_ref = 1;
 	pages[0].pp_link = NULL;
+
+	size_t mpentry_pgnum = PGNUM(MPENTRY_PADDR);
+	pages[mpentry_pgnum].pp_ref = 1;
+	pages[mpentry_pgnum].pp_link = NULL;
+	
 	size_t i;
 	for (i = 1; i < npages_basemem; i++)
 	{
+		if (i == mpentry_pgnum)
+			continue;
 		pages[i].pp_ref = 0;
 		pages[i].pp_link = page_free_list;
 		page_free_list = &pages[i];
@@ -678,7 +690,19 @@ mmio_map_region(physaddr_t pa, size_t size)
 	// Hint: The staff solution uses boot_map_region.
 	//
 	// Your code here:
-	panic("mmio_map_region not implemented");
+	physaddr_t pa_page_start = ROUNDDOWN(pa, PGSIZE);	// physical page including the pa
+	physaddr_t pa_page_end = ROUNDUP(pa + size, PGSIZE);	// physical page end
+	size = pa_page_end - pa_page_start;		// update size, should now be multiple of PGSIZE
+	if (base + size < MMIOLIM)
+	{
+		boot_map_region(kern_pgdir, base, size, pa_page_start, PTE_PCD | PTE_PWT | PTE_W);
+		base += size;
+		return (void *)(base - size);
+	}
+	else
+	{
+		panic("exceeding MMIOLIM...");
+	}
 }
 
 static uintptr_t user_mem_check_addr;
diff --git a/kern/sched.c b/kern/sched.c
index f595bb1..4303618 100644
--- a/kern/sched.c
+++ b/kern/sched.c
@@ -29,6 +29,18 @@ sched_yield(void)
 	// below to halt the cpu.
 
 	// LAB 4: Your code here.
+	int i = 0;
+	for (; i < NENV; i++)
+	{
+		if (envs[i].env_status == ENV_RUNNABLE)
+		{
+			env_run(&envs[i]);
+		}
+	}
+	if (curenv != NULL && curenv->env_status == ENV_RUNNING)
+	{
+		env_run(curenv);
+	}
 
 	// sched_halt never returns
 	sched_halt();
diff --git a/kern/syscall.c b/kern/syscall.c
index 4e8145a..611c36b 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -23,7 +23,7 @@ sys_cputs(const char *s, size_t len)
 
 	// LAB 3: Your code here.
 	user_mem_assert(curenv, s, len, PTE_P);
-	cprintf("Will write from address: 0x%08x to address: 0x%08x\n", s, s + len);
+	// cprintf("Will write from address: 0x%08x to address: 0x%08x\n", s, s + len);
 	if ((uint32_t)ROUNDUP(s, PGSIZE) != USTACKTOP || (uint32_t)ROUNDUP(s + len, PGSIZE) != USTACKTOP)
 	{
 		env_destroy(curenv);
@@ -90,7 +90,15 @@ sys_exofork(void)
 	// will appear to return 0.
 
 	// LAB 4: Your code here.
-	panic("sys_exofork not implemented");
+	struct Env *child = NULL;
+	int ret = 0;
+	if ((ret = env_alloc(&child, curenv->env_id)) != 0)
+		return ret;
+	child->env_status = ENV_NOT_RUNNABLE;
+	child->env_tf = curenv->env_tf;
+	child->env_tf.tf_regs.reg_eax = 0;
+
+	return child->env_id;
 }
 
 // Set envid's env_status to status, which must be ENV_RUNNABLE
@@ -110,7 +118,16 @@ sys_env_set_status(envid_t envid, int status)
 	// envid's status.
 
 	// LAB 4: Your code here.
-	panic("sys_env_set_status not implemented");
+	if (status != ENV_NOT_RUNNABLE && status != ENV_RUNNABLE)
+		return -E_INVAL;
+
+	struct Env *env = NULL;
+	int ret = 0;
+	if ((ret = envid2env(envid, &env, 1)) != 0)
+		return ret;
+
+	env->env_status = status;
+	return 0;
 }
 
 // Set the page fault upcall for 'envid' by modifying the corresponding struct
@@ -155,7 +172,18 @@ sys_page_alloc(envid_t envid, void *va, int perm)
 	//   allocated!
 
 	// LAB 4: Your code here.
-	panic("sys_page_alloc not implemented");
+	struct Env *env = NULL;
+	if (envid2env(envid, &env, 1) != 0)
+		return -E_BAD_ENV;
+	if ((uintptr_t)va >= UTOP || (uintptr_t)va % PGSIZE)
+		return -E_INVAL;
+	if ((perm & PTE_P) == 0 || (perm & PTE_U) == 0 || (perm & ~PTE_SYSCALL) != 0)
+		return -E_INVAL;
+
+	struct PageInfo *page = page_alloc(0);
+	if (page == NULL)
+		return -E_NO_MEM;
+	return page_insert(env->env_pgdir, page, va, perm);
 }
 
 // Map the page of memory at 'srcva' in srcenvid's address space
@@ -184,9 +212,19 @@ sys_page_map(envid_t srcenvid, void *srcva,
 	//   parameters for correctness.
 	//   Use the third argument to page_lookup() to
 	//   check the current permissions on the page.
+	struct Env *srcenv, *dstenv;
+	if (envid2env(srcenvid, &srcenv, 1) != 0 || envid2env(dstenvid, &dstenv, 1) != 0)
+		return -E_BAD_ENV;
+	if ((uintptr_t)srcva >= UTOP || (uintptr_t)dstva >= UTOP || (uintptr_t)srcva % PGSIZE || (uintptr_t)dstva % PGSIZE)
+		return -E_INVAL;
 
-	// LAB 4: Your code here.
-	panic("sys_page_map not implemented");
+	pte_t *src_pgtbl_entry = NULL;
+	struct PageInfo *src_page = page_lookup(srcenv->env_pgdir, srcva, &src_pgtbl_entry);
+	if (src_page == NULL || (perm & PTE_P) == 0 || (perm & PTE_U) == 0 || (perm & ~PTE_SYSCALL) != 0)
+		return -E_INVAL;
+	if ((perm & PTE_W) && !(*src_pgtbl_entry & PTE_W))
+		return -E_INVAL;
+	return page_insert(dstenv->env_pgdir, src_page, dstva, perm);
 }
 
 // Unmap the page of memory at 'va' in the address space of 'envid'.
@@ -202,7 +240,13 @@ sys_page_unmap(envid_t envid, void *va)
 	// Hint: This function is a wrapper around page_remove().
 
 	// LAB 4: Your code here.
-	panic("sys_page_unmap not implemented");
+	struct Env *env = NULL;
+	if (envid2env(envid, &env, 1) != 0)
+		return -E_BAD_ENV;
+	if ((uintptr_t)va >= UTOP || (uintptr_t)va % PGSIZE)
+		return -E_INVAL;
+	page_remove(env->env_pgdir, va);
+	return 0;
 }
 
 // Try to send 'value' to the target env 'envid'.
@@ -289,6 +333,18 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
 		return sys_getenvid();
 	case SYS_env_destroy:
 		return sys_env_destroy(a1);
+	case SYS_page_alloc:
+		return sys_page_alloc(a1, (void *)a2, a3);
+	case SYS_page_map:
+		return sys_page_map(a1, (void *)a2, a3, (void *)a4, a5);
+	case SYS_page_unmap:
+		return sys_page_unmap(a1, (void *)a2);
+	case SYS_exofork:
+		return sys_exofork();
+	case SYS_env_set_status:
+		return sys_env_set_status(a1, a2);
+	case SYS_yield:
+		sys_yield();
 	case NSYSCALLS:
 	default:
 		return -E_INVAL;
diff --git a/kern/trap.c b/kern/trap.c
index 6dae2b4..1c6f1ae 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -73,12 +73,8 @@ void
 trap_init(void)
 {
 	extern struct Segdesc gdt[];
-	extern void sysenter_handler();
 
 	// LAB 3: Your code here.
-	wrmsr(0x174, GD_KT, 0);		// set (CPL = 0) CS & SS
-	wrmsr(0x176, (uint32_t)sysenter_handler, 0);		// the sysenter handler address
-	wrmsr(0x175, KSTACKTOP, 0);	// the stack where we drop in when trapped into kernel
 
 	int vector = 0;
 	for (; vector < 32; vector++)
@@ -129,21 +125,26 @@ trap_init_percpu(void)
 	// user space on that CPU.
 	//
 	// LAB 4: Your code here:
+	extern void sysenter_handler();
+	uintptr_t kstacktop_percpu = (uintptr_t)percpu_kstacks[thiscpu->cpu_id] + KSTKSIZE;
+	wrmsr(0x174, GD_KT, 0);		// set (CPL = 0) CS & SS
+	wrmsr(0x176, (uint32_t)sysenter_handler, 0);		// the sysenter handler address
+	wrmsr(0x175, kstacktop_percpu, 0);	// the stack where we drop in when trapped into kernel
 
 	// Setup a TSS so that we get the right stack
 	// when we trap to the kernel.
-	ts.ts_esp0 = KSTACKTOP;
-	ts.ts_ss0 = GD_KD;
-	ts.ts_iomb = sizeof(struct Taskstate);
+	thiscpu->cpu_ts.ts_esp0 = kstacktop_percpu;
+	thiscpu->cpu_ts.ts_ss0 = GD_KD;
+	// thiscpu->cpu_ts.ts_iomb = MMIOBASE; // how to initialize this io base?
 
 	// Initialize the TSS slot of the gdt.
-	gdt[GD_TSS0 >> 3] = SEG16(STS_T32A, (uint32_t) (&ts),
+	gdt[(GD_TSS0 >> 3) + thiscpu->cpu_id] = SEG16(STS_T32A, (uint32_t) (&thiscpu->cpu_ts),
 					sizeof(struct Taskstate) - 1, 0);
-	gdt[GD_TSS0 >> 3].sd_s = 0;
+	gdt[(GD_TSS0 >> 3) + thiscpu->cpu_id].sd_s = 0;
 
 	// Load the TSS selector (like other segment selectors, the
 	// bottom three bits are special; we leave them 0)
-	ltr(GD_TSS0);
+	ltr(GD_TSS0 + (thiscpu->cpu_id << 3)); // see env gdt init
 
 	// Load the IDT
 	lidt(&idt_pd);
@@ -268,6 +269,15 @@ trap(struct Trapframe *tf)
 		// Acquire the big kernel lock before doing any
 		// serious kernel work.
 		// LAB 4: Your code here.
+
+		// Question 2: Why do we still need separate kernel stacks for each CPU?
+		// Answer: 
+		// 1. CPU 0 got interrupted into the kernel from user space, it will push tf_0 on single stack 
+		// 2. CPU 1 got interrupted too, then tf_1 is pushed on stack, and wait for irq_0 return (CPU 0 holding the lock)
+		// 3. irq_0 return, it will pop tf_1 out and try to restore user state, but what it should pop is tf_0
+		// more: https://stackoverflow.com/a/13953815/6289529
+
+		lock_kernel();
 		assert(curenv);
 
 		// Garbage collect if current enviroment is a zombie
diff --git a/kern/trapentry.S b/kern/trapentry.S
index a1e5db3..bccd25d 100644
--- a/kern/trapentry.S
+++ b/kern/trapentry.S
@@ -53,6 +53,16 @@ default_handlers:
 .align 2
 # bypass trap to reach syscall directly
 sysenter_handler:
+pushl %ecx
+pushl %edx
+pushl %eax
+pushl $kernel_lock
+call spin_lock
+addl $4, %esp
+popl %eax
+popl %edx
+popl %ecx
+
 pushl %edi
 pushl %ebx
 pushl %ecx
@@ -64,6 +74,13 @@ call syscall
 # movl $0, %edx
 # movl $(GD_UT), %eax	/* no need, because of continuity, GD_UT will be found by adding 16(0x10) to GD_KT */
 # wrmsr
+pushl %eax
+pushl $kernel_lock
+call spin_unlock
+pause
+addl $4, %esp
+popl %eax
+
 movl %esi, %edx
 movl %ebp, %ecx
 sysexit
diff --git a/lib/syscall.c b/lib/syscall.c
index 3fa7936..ea67c9c 100644
--- a/lib/syscall.c
+++ b/lib/syscall.c
@@ -47,6 +47,8 @@ sysenter(int num, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4)
 	//
 	// https://reverseengineering.stackexchange.com/questions/2869/how-to-use-sysenter-under-linux
 
+	// we also need to lock kernel here
+
     int32_t ret;
 	asm volatile(
 		        "pushl %%ebp\n\t"
@@ -87,32 +89,40 @@ sys_env_destroy(envid_t envid)
 envid_t
 sys_getenvid(void)
 {
-	 return sysenter(SYS_getenvid, 0, 0, 0, 0);
-	 // return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
+	return sysenter(SYS_getenvid, 0, 0, 0, 0);
 }
 
 void
 sys_yield(void)
 {
+	// Question 4: Whenever the kernel switches from one environment to another, it must ensure the old environment's
+	// registers are saved so they can be restored properly later. Why? Where does this happen?
+	//
+	// Answer: the kernel switches from one env to another by calling 'sys_yield', which will use 'int 0x30' to save
+	// current env status in kernel stack, next time, it will use env_run to restore
+	//
+	// Note: this system call cannot be implemented by 'sysenter', since it needs to record any update of trapframe,
+	// 'sysenter' will not be able to do so
 	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
 }
 
 int
 sys_page_alloc(envid_t envid, void *va, int perm)
 {
-	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
+	return sysenter(SYS_page_alloc, envid, (uint32_t) va, perm, 0);
 }
 
 int
 sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
 {
+	// sysenter doesn't support 5 arguments
 	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
 }
 
 int
 sys_page_unmap(envid_t envid, void *va)
 {
-	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
+	return sysenter(SYS_page_unmap, envid, (uint32_t) va, 0, 0);
 }
 
 // sys_exofork is inlined in lib.h
@@ -120,7 +130,7 @@ sys_page_unmap(envid_t envid, void *va)
 int
 sys_env_set_status(envid_t envid, int status)
 {
-	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
+	return sysenter(SYS_env_set_status, envid, status, 0, 0);
 }
 
 int
-- 
2.11.0

