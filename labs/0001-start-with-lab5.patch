From 57b56fb6923d34c587fbb4fdf7520d050b4d40dc Mon Sep 17 00:00:00 2001
From: Aaron <kljsandjb@me.com>
Date: Sun, 23 Aug 2020 14:22:13 +0000
Subject: [PATCH] start with lab5

finished with test.c
finished testfile.c
adding some comments
---
 fs/bc.c       | 13 ++++++++-
 fs/fs.c       | 74 +++++++++++++++++++++++++++++++++++++++++++++++----
 fs/serv.c     | 22 +++++++++++++--
 kern/env.c    |  4 ++-
 kern/trap.c   | 11 ++++++++
 lib/exit.c    |  2 +-
 lib/file.c    | 12 ++++++++-
 lib/fork.c    | 16 +++++------
 lib/pgfault.c |  4 +--
 9 files changed, 137 insertions(+), 21 deletions(-)

diff --git a/fs/bc.c b/fs/bc.c
index e3922c4..c9ab106 100644
--- a/fs/bc.c
+++ b/fs/bc.c
@@ -48,6 +48,10 @@ bc_pgfault(struct UTrapframe *utf)
 	// the disk.
 	//
 	// LAB 5: you code here:
+	addr = ROUNDDOWN(addr, BLKSIZE);
+	if ((r = sys_page_alloc(0, addr, PTE_SYSCALL)) < 0)
+		panic("in bc_pgfault, sys_page_alloc: %e", r);
+	ide_read(blockno * BLKSIZE / SECTSIZE, addr, BLKSIZE / SECTSIZE);
 
 	// Clear the dirty bit for the disk block page since we just read the
 	// block from disk
@@ -77,7 +81,14 @@ flush_block(void *addr)
 		panic("flush_block of bad va %08x", addr);
 
 	// LAB 5: Your code here.
-	panic("flush_block not implemented");
+	if (va_is_mapped(addr) && va_is_dirty(addr))
+	{
+		addr = ROUNDDOWN(addr, BLKSIZE);
+		ide_write(blockno * BLKSIZE / SECTSIZE, addr, BLKSIZE / SECTSIZE);
+		int r;
+		if ((r = sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] & PTE_SYSCALL)) < 0)
+		    panic("in flush_block, sys_page_map: %e", r);
+	}
 }
 
 // Test that the block cache works, by smashing the superblock and
diff --git a/fs/fs.c b/fs/fs.c
index 45ecaf8..04b02e8 100644
--- a/fs/fs.c
+++ b/fs/fs.c
@@ -62,7 +62,16 @@ alloc_block(void)
 	// super->s_nblocks blocks in the disk altogether.
 
 	// LAB 5: Your code here.
-	panic("alloc_block not implemented");
+	// panic("alloc_block not implemented");
+	for (uint32_t i = 3; i < super->s_nblocks; i++)
+	{
+		if (block_is_free(i))
+		{
+			bitmap[i / 32] &= ~(1 << (i % 32));
+			flush_block(bitmap + i / 8);
+			return i;
+		}
+	}
 	return -E_NO_DISK;
 }
 
@@ -134,8 +143,39 @@ fs_init(void)
 static int
 file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)
 {
-       // LAB 5: Your code here.
-       panic("file_block_walk not implemented");
+	// LAB 5: Your code here.
+	if (filebno >= NDIRECT + NINDIRECT)
+		return -E_INVAL;
+	if (filebno < NDIRECT)
+	{
+		if (ppdiskbno)
+			*ppdiskbno = f->f_direct + filebno;
+		return 0;
+	}
+	// haven't got result from direct blocks, so query indirect ones...
+	uint32_t *indirect_block;
+	if (f->f_indirect == 0)
+	{
+		if (alloc == 0)
+			return -E_NOT_FOUND;
+		
+		// alloc a block for indirect block
+		f->f_indirect = alloc_block();
+		if (f->f_indirect < 0)
+			return f->f_indirect;
+		indirect_block = (uint32_t *)diskaddr(f->f_indirect);
+		// this should trigger a page fault which reads some data from disk
+		// and then we manage to clear the block
+		memset(indirect_block, 0, BLKSIZE);
+	}
+	else
+	{
+		indirect_block = (uint32_t *)diskaddr(f->f_indirect);
+	}
+	if (ppdiskbno)
+		*ppdiskbno = indirect_block + filebno - NDIRECT;
+
+	return 0;
 }
 
 // Set *blk to the address in memory where the filebno'th
@@ -149,8 +189,30 @@ file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool all
 int
 file_get_block(struct File *f, uint32_t filebno, char **blk)
 {
-       // LAB 5: Your code here.
-       panic("file_get_block not implemented");
+	// LAB 5: Your code here.
+	if (filebno >= NDIRECT + NINDIRECT)
+		return -E_INVAL;
+	int r = 0;
+	uint32_t *ppdiskbno;
+	if ((r = file_block_walk(f, filebno, &ppdiskbno, true)) < 0)
+		return r;
+	if (blk)
+	{
+		if (*ppdiskbno != 0)
+		{
+			*blk = diskaddr(*ppdiskbno);
+			return 0;
+		}
+		// demand allocation
+		int blkno = alloc_block();
+		if (blkno < 0)
+			return blkno;
+		// update the entry
+		*ppdiskbno = (uint32_t)blkno;
+		*blk = diskaddr(*ppdiskbno);
+	}
+
+	return 0;
 }
 
 // Try to find a file named "name" in dir.  If so, set *file to it.
@@ -173,6 +235,8 @@ dir_lookup(struct File *dir, const char *name, struct File **file)
 	for (i = 0; i < nblock; i++) {
 		if ((r = file_get_block(dir, i, &blk)) < 0)
 			return r;
+		// file system interprets the contents of a directory-file as a series of File structures,
+		// describing the files and subdirectories within the directory.
 		f = (struct File*) blk;
 		for (j = 0; j < BLKFILES; j++)
 			if (strcmp(f[j].f_name, name) == 0) {
diff --git a/fs/serv.c b/fs/serv.c
index 76c1d99..ff26e35 100644
--- a/fs/serv.c
+++ b/fs/serv.c
@@ -214,7 +214,16 @@ serve_read(envid_t envid, union Fsipc *ipc)
 		cprintf("serve_read %08x %08x %08x\n", envid, req->req_fileid, req->req_n);
 
 	// Lab 5: Your code here:
-	return 0;
+	int r;
+	struct OpenFile *o;
+	if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)
+		return r;
+	
+	if ((r = file_read(o->o_file, ret->ret_buf, req->req_n, o->o_fd->fd_offset)) < 0)
+		return r;
+
+	o->o_fd->fd_offset += r;
+	return r;
 }
 
 
@@ -229,7 +238,16 @@ serve_write(envid_t envid, struct Fsreq_write *req)
 		cprintf("serve_write %08x %08x %08x\n", envid, req->req_fileid, req->req_n);
 
 	// LAB 5: Your code here.
-	panic("serve_write not implemented");
+	int r;
+	struct OpenFile *o;
+	if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)
+		return r;
+	
+	if ((r = file_write(o->o_file, req->req_buf, req->req_n, o->o_fd->fd_offset)) < 0)
+		return r;
+
+	o->o_fd->fd_offset += r;
+	return r;
 }
 
 // Stat ipc->stat.req_fileid.  Return the file's struct Stat to the
diff --git a/kern/env.c b/kern/env.c
index 1ac611c..1f86f5e 100644
--- a/kern/env.c
+++ b/kern/env.c
@@ -274,7 +274,7 @@ env_alloc(struct Env **newenv_store, envid_t parent_id)
 	env_free_list = e->env_link;
 	*newenv_store = e;
 
-	// cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
+	cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
 	return 0;
 }
 
@@ -420,6 +420,8 @@ env_create(uint8_t *binary, enum EnvType type)
 	if (env_alloc(&new_env, 0) != 0)
 		panic("env_alloc");
 	load_icode(new_env, binary);
+	if (type == ENV_TYPE_FS)
+		new_env->env_tf.tf_eflags |= FL_IOPL_3;
 	new_env->env_type = type;
 }
 
diff --git a/kern/trap.c b/kern/trap.c
index 5f110a7..cff4268 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -310,6 +310,17 @@ trap(struct Trapframe *tf)
 		// Copy trap frame (which is currently on the stack)
 		// into 'curenv->env_tf', so that running the environment
 		// will restart at the trap point.
+
+		// The reason for this copy: difference from xv6
+		// in xv6, each process(env) has its own kernel stack, so each process(env) can
+		// always rely on its own stack even during task switch, since task switch always switch kernel stack.
+
+		// But in JOS here, each CPU got its own kernel stack instead of each process(env), process(env) only keeps a
+		// *snapshot* of trapframe when it gets trapped into the kernel, so that kernel
+		// can freely do task switch without worrying about the stack switch (we do switch always in env_run()).
+		// If we don't do this copy, only keep the pointer, when a timer interrupt comes in, the kernel stack would be
+		// replaced with another process's state, once we re-run the previous one, it will use the state from another
+		// process(env), which definitely is wrong!
 		curenv->env_tf = *tf;
 		// The trapframe on the stack should be ignored from here on.
 		tf = &curenv->env_tf;
diff --git a/lib/exit.c b/lib/exit.c
index cee3336..438fb5a 100644
--- a/lib/exit.c
+++ b/lib/exit.c
@@ -4,7 +4,7 @@
 void
 exit(void)
 {
-	close_all();
+	// close_all();
 	sys_env_destroy(0);
 }
 
diff --git a/lib/file.c b/lib/file.c
index 39025b2..7697693 100644
--- a/lib/file.c
+++ b/lib/file.c
@@ -141,7 +141,17 @@ devfile_write(struct Fd *fd, const void *buf, size_t n)
 	// remember that write is always allowed to write *fewer*
 	// bytes than requested.
 	// LAB 5: Your code here
-	panic("devfile_write not implemented");
+	int r;
+
+	fsipcbuf.write.req_fileid = fd->fd_file.id;
+	fsipcbuf.write.req_n = n;
+	memmove(fsipcbuf.write.req_buf, buf, n);
+	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
+		return r;
+
+	assert(r <= n);
+	assert(r <= sizeof(fsipcbuf.write.req_buf));
+	return r;
 }
 
 static int
diff --git a/lib/fork.c b/lib/fork.c
index 3f19405..d19bf33 100644
--- a/lib/fork.c
+++ b/lib/fork.c
@@ -41,15 +41,15 @@ pgfault(struct UTrapframe *utf)
 	//   You should make three system calls.
 
 	// LAB 4: Your code here.
-	envid_t envid = sys_getenvid();
+	// envid_t envid = sys_getenvid();
 	// cprintf("fault addr 0x%x, envid %x\n", addr, envid);
 	addr = ROUNDDOWN(addr, PGSIZE);	// page-size aligned
 
-	if ((r = sys_page_alloc(envid, PFTEMP, PTE_P | PTE_U | PTE_W)) != 0)
+	if ((r = sys_page_alloc(0, PFTEMP, PTE_SYSCALL)) != 0)
 		panic("sys_page_alloc, %e", r);
 	memmove((void *)PFTEMP, addr, PGSIZE);
 	// remap the addr with newly allocated writable page
-	if  ((r = sys_page_map(envid, PFTEMP, envid, addr, PTE_P | PTE_U | PTE_W)) != 0)
+	if  ((r = sys_page_map(0, PFTEMP, 0, addr, PTE_SYSCALL)) != 0)
 		panic("sys_page_map, %e, fault addr 0x%x", r, addr);
 }
 
@@ -71,7 +71,7 @@ duppage(envid_t envid, unsigned pn)
 
 	// LAB 4: Your code here.
 	int perm = PTE_P | PTE_U;	// at least PTE_P and PTE_U
-	envid_t curenvid = sys_getenvid();
+	// envid_t curenvid = sys_getenvid();
 
 	int is_wr = (uvpt[pn] & PTE_W) == PTE_W;
 	int is_cow = (uvpt[pn] & PTE_COW) == PTE_COW;
@@ -79,15 +79,15 @@ duppage(envid_t envid, unsigned pn)
 	if (is_wr || is_cow)
 	{
 		// create new mapping
-		if ((r = sys_page_map(curenvid, addr, envid, addr, perm | PTE_COW)) != 0)
+		if ((r = sys_page_map(0, addr, envid, addr, perm | PTE_COW)) != 0)
 			panic("sys_page_map, %e", r);
-		if ((r = sys_page_map(curenvid, addr, curenvid, addr, perm | PTE_COW)) != 0)
+		if ((r = sys_page_map(0, addr, 0, addr, perm | PTE_COW)) != 0)
 			panic("sys_page_map, %e", r);
 	}
 	else
 	{
 		// only remap child without PTE_COW
-		if ((r = sys_page_map(curenvid, addr, envid, addr, perm)) != 0)
+		if ((r = sys_page_map(0, addr, envid, addr, perm)) != 0)
 			panic("sys_page_map, %e", r);
 	}
 	return 0;
@@ -133,7 +133,7 @@ fork(void)
 	// because the child's pgdir doesn't map any page for (USTACKTOP - PGSIZE)
 	// set_pgfault_handler(pgfault);
 
-	if ((r = sys_page_alloc(child, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) != 0)
+	if ((r = sys_page_alloc(child, (void *)(UXSTACKTOP - PGSIZE), PTE_SYSCALL)) != 0)
 		panic("sys_page_alloc, %e", r);
 	extern void _pgfault_upcall(void);
 	if ((r = sys_env_set_pgfault_upcall(child, _pgfault_upcall)) != 0)
diff --git a/lib/pgfault.c b/lib/pgfault.c
index 0cb1b33..ab0138d 100644
--- a/lib/pgfault.c
+++ b/lib/pgfault.c
@@ -29,9 +29,9 @@ set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
 	if (_pgfault_handler == 0) {
 		// First time through!
 		// LAB 4: Your code here.
-		if ((r = sys_page_alloc(sys_getenvid(), (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) != 0)
+		if ((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) != 0)
 			panic("sys_page_alloc, %e", r);
-		if ((r = sys_env_set_pgfault_upcall(sys_getenvid(), _pgfault_upcall)) != 0)
+		if ((r = sys_env_set_pgfault_upcall(0, _pgfault_upcall)) != 0)
 			panic("sys_env_set_pgfault_upcall, %e", r);
 	}
 
-- 
2.20.1

