From 40ab703e04781bbc42f932d9a86b7c3f82fd23b5 Mon Sep 17 00:00:00 2001
From: Aaron <kljsandjb@me.com>
Date: Mon, 15 Jun 2020 12:57:55 +0200
Subject: [PATCH] using clang-format -i *.c *.h -sort-includes=false to make it
 look prettier

---
 asm.h       |  20 +-
 bio.c       |  43 ++-
 bootmain.c  |  52 ++--
 buf.h       |   5 +-
 cat.c       |  18 +-
 console.c   | 159 +++++------
 date.c      |   7 +-
 defs.h      | 254 ++++++++---------
 echo.c      |   8 +-
 elf.h       |  12 +-
 exec.c      |  85 +++---
 fcntl.h     |   8 +-
 file.c      |  73 ++---
 file.h      |  17 +-
 forktest.c  |  30 +-
 fs.c        | 272 ++++++++----------
 fs.h        |  40 ++-
 grep.c      |  75 +++--
 ide.c       |  92 +++----
 init.c      |  20 +-
 ioapic.c    |  46 ++--
 kalloc.c    |  45 ++-
 kbd.c       |  28 +-
 kbd.h       | 389 +++++++++++++++++++-------
 kill.c      |   8 +-
 lapic.c     | 187 ++++++-------
 ln.c        |   8 +-
 log.c       |  73 ++---
 ls.c        |  40 ++-
 main.c      | 101 ++++---
 memide.c    |  26 +-
 memlayout.h |  18 +-
 mkdir.c     |  10 +-
 mkfs.c      | 128 ++++-----
 mmu.h       | 144 +++++-----
 mp.c        |  74 +++--
 mp.h        |  78 +++---
 param.h     |  27 +-
 picirq.c    |  14 +-
 pipe.c      |  70 +++--
 printf.c    |  50 ++--
 proc.c      | 213 ++++++---------
 proc.h      |  44 +--
 rm.c        |  10 +-
 sbrktest.c  |  52 ++--
 sh.c        | 229 +++++++---------
 sleeplock.c |  21 +-
 sleeplock.h |   9 +-
 spinlock.c  |  58 ++--
 spinlock.h  |  11 +-
 stat.h      |   6 +-
 stressfs.c  |  12 +-
 string.c    |  61 ++---
 syscall.c   | 117 +++-----
 syscall.h   |  40 +--
 sysfile.c   | 235 +++++++---------
 sysproc.c   |  84 ++----
 trap.c      |  87 +++---
 traps.h     |  55 ++--
 types.h     |   4 +-
 uart.c      |  56 ++--
 ulib.c      |  62 ++---
 umalloc.c   |  46 ++--
 user.h      |  50 ++--
 usertests.c | 773 ++++++++++++++++++++++++----------------------------
 vm.c        | 228 +++++++---------
 wc.c        |  26 +-
 x86.h       | 140 ++++------
 zombie.c    |   8 +-
 69 files changed, 2545 insertions(+), 3046 deletions(-)

diff --git a/asm.h b/asm.h
index b8a7353..ae5349d 100644
--- a/asm.h
+++ b/asm.h
@@ -2,17 +2,17 @@
 // assembler macros to create x86 segments
 //
 
-#define SEG_NULLASM                                             \
-        .word 0, 0;                                             \
-        .byte 0, 0, 0, 0
+#define SEG_NULLASM                                                            \
+  .word 0, 0;                                                                  \
+  .byte 0, 0, 0, 0
 
 // The 0xC0 means the limit is in 4096-byte units
 // and (for executable segments) 32-bit mode.
-#define SEG_ASM(type,base,lim)                                  \
-        .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
-        .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
-                (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
+#define SEG_ASM(type, base, lim)                                               \
+  .word(((lim) >> 12) & 0xffff), ((base)&0xffff);                              \
+  .byte(((base) >> 16) & 0xff), (0x90 | (type)),                               \
+      (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
 
-#define STA_X     0x8       // Executable segment
-#define STA_W     0x2       // Writeable (non-executable segments)
-#define STA_R     0x2       // Readable (executable segments)
+#define STA_X 0x8 // Executable segment
+#define STA_W 0x2 // Writeable (non-executable segments)
+#define STA_R 0x2 // Readable (executable segments)
diff --git a/bio.c b/bio.c
index a45ff3e..68c0cc7 100644
--- a/bio.c
+++ b/bio.c
@@ -35,18 +35,16 @@ struct {
   struct buf head;
 } bcache;
 
-void
-binit(void)
-{
+void binit(void) {
   struct buf *b;
 
   initlock(&bcache.lock, "bcache");
 
-//PAGEBREAK!
+  // PAGEBREAK!
   // Create linked list of buffers
   bcache.head.prev = &bcache.head;
   bcache.head.next = &bcache.head;
-  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+  for (b = bcache.buf; b < bcache.buf + NBUF; b++) {
     b->next = bcache.head.next;
     b->prev = &bcache.head;
     initsleeplock(&b->lock, "buffer");
@@ -58,16 +56,14 @@ binit(void)
 // Look through buffer cache for block on device dev.
 // If not found, allocate a buffer.
 // In either case, return locked buffer.
-static struct buf*
-bget(uint dev, uint blockno)
-{
+static struct buf *bget(uint dev, uint blockno) {
   struct buf *b;
 
   acquire(&bcache.lock);
 
   // Is the block already cached?
-  for(b = bcache.head.next; b != &bcache.head; b = b->next){
-    if(b->dev == dev && b->blockno == blockno){
+  for (b = bcache.head.next; b != &bcache.head; b = b->next) {
+    if (b->dev == dev && b->blockno == blockno) {
       b->refcnt++;
       release(&bcache.lock);
       acquiresleep(&b->lock);
@@ -78,8 +74,8 @@ bget(uint dev, uint blockno)
   // Not cached; recycle an unused buffer.
   // Even if refcnt==0, B_DIRTY indicates a buffer is in use
   // because log.c has modified it but not yet committed it.
-  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
-    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
+  for (b = bcache.head.prev; b != &bcache.head; b = b->prev) {
+    if (b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
       b->dev = dev;
       b->blockno = blockno;
       b->flags = 0;
@@ -93,23 +89,19 @@ bget(uint dev, uint blockno)
 }
 
 // Return a locked buf with the contents of the indicated block.
-struct buf*
-bread(uint dev, uint blockno)
-{
+struct buf *bread(uint dev, uint blockno) {
   struct buf *b;
 
   b = bget(dev, blockno);
-  if((b->flags & B_VALID) == 0) {
+  if ((b->flags & B_VALID) == 0) {
     iderw(b);
   }
   return b;
 }
 
 // Write b's contents to disk.  Must be locked.
-void
-bwrite(struct buf *b)
-{
-  if(!holdingsleep(&b->lock))
+void bwrite(struct buf *b) {
+  if (!holdingsleep(&b->lock))
     panic("bwrite");
   b->flags |= B_DIRTY;
   iderw(b);
@@ -117,10 +109,8 @@ bwrite(struct buf *b)
 
 // Release a locked buffer.
 // Move to the head of the MRU list.
-void
-brelse(struct buf *b)
-{
-  if(!holdingsleep(&b->lock))
+void brelse(struct buf *b) {
+  if (!holdingsleep(&b->lock))
     panic("brelse");
 
   releasesleep(&b->lock);
@@ -136,9 +126,8 @@ brelse(struct buf *b)
     bcache.head.next->prev = b;
     bcache.head.next = b;
   }
-  
+
   release(&bcache.lock);
 }
-//PAGEBREAK!
+// PAGEBREAK!
 // Blank page.
-
diff --git a/bootmain.c b/bootmain.c
index 1f20e5b..df3e696 100644
--- a/bootmain.c
+++ b/bootmain.c
@@ -10,75 +10,67 @@
 #include "x86.h"
 #include "memlayout.h"
 
-#define SECTSIZE  512
+#define SECTSIZE 512
 
-void readseg(uchar*, uint, uint);
+void readseg(uchar *, uint, uint);
 
-void
-bootmain(void)
-{
+void bootmain(void) {
   struct elfhdr *elf;
   struct proghdr *ph, *eph;
   void (*entry)(void);
-  uchar* pa;
+  uchar *pa;
 
-  elf = (struct elfhdr*)0x10000;  // scratch space
+  elf = (struct elfhdr *)0x10000; // scratch space
 
   // Read 1st page off disk
-  readseg((uchar*)elf, 4096, 0);
+  readseg((uchar *)elf, 4096, 0);
 
   // Is this an ELF executable?
-  if(elf->magic != ELF_MAGIC)
-    return;  // let bootasm.S handle error
+  if (elf->magic != ELF_MAGIC)
+    return; // let bootasm.S handle error
 
   // Load each program segment (ignores ph flags).
-  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
+  ph = (struct proghdr *)((uchar *)elf + elf->phoff);
   eph = ph + elf->phnum;
-  for(; ph < eph; ph++){
-    pa = (uchar*)ph->paddr;
+  for (; ph < eph; ph++) {
+    pa = (uchar *)ph->paddr;
     readseg(pa, ph->filesz, ph->off);
-    if(ph->memsz > ph->filesz)
+    if (ph->memsz > ph->filesz)
       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
   }
 
   // Call the entry point from the ELF header.
   // Does not return!
-  entry = (void(*)(void))(elf->entry);
+  entry = (void (*)(void))(elf->entry);
   entry();
 }
 
-void
-waitdisk(void)
-{
+void waitdisk(void) {
   // Wait for disk ready.
-  while((inb(0x1F7) & 0xC0) != 0x40)
+  while ((inb(0x1F7) & 0xC0) != 0x40)
     ;
 }
 
 // Read a single sector at offset into dst.
-void
-readsect(void *dst, uint offset)
-{
+void readsect(void *dst, uint offset) {
   // Issue command.
   waitdisk();
-  outb(0x1F2, 1);   // count = 1
+  outb(0x1F2, 1); // count = 1
   outb(0x1F3, offset);
   outb(0x1F4, offset >> 8);
   outb(0x1F5, offset >> 16);
   outb(0x1F6, (offset >> 24) | 0xE0);
-  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
+  outb(0x1F7, 0x20); // cmd 0x20 - read sectors
 
   // Read data.
   waitdisk();
-  insl(0x1F0, dst, SECTSIZE/4);
+  insl(0x1F0, dst, SECTSIZE / 4);
 }
 
 // Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
 // Might copy more than asked.
-void
-readseg(uchar* pa, uint count, uint offset)
-{
-  uchar* epa;
+void readseg(uchar *pa, uint count, uint offset) {
+  uchar *epa;
 
   epa = pa + count;
 
@@ -91,6 +83,6 @@ readseg(uchar* pa, uint count, uint offset)
   // If this is too slow, we could read lots of sectors at a time.
   // We'd write more to memory than asked, but it doesn't matter --
   // we load in increasing order.
-  for(; pa < epa; pa += SECTSIZE, offset++)
+  for (; pa < epa; pa += SECTSIZE, offset++)
     readsect(pa, offset);
 }
diff --git a/buf.h b/buf.h
index 3266495..cc8f8a9 100644
--- a/buf.h
+++ b/buf.h
@@ -9,6 +9,5 @@ struct buf {
   struct buf *qnext; // disk queue
   uchar data[BSIZE];
 };
-#define B_VALID 0x2  // buffer has been read from disk
-#define B_DIRTY 0x4  // buffer needs to be written to disk
-
+#define B_VALID 0x2 // buffer has been read from disk
+#define B_DIRTY 0x4 // buffer needs to be written to disk
diff --git a/cat.c b/cat.c
index 5ddc820..3853bb2 100644
--- a/cat.c
+++ b/cat.c
@@ -4,35 +4,31 @@
 
 char buf[512];
 
-void
-cat(int fd)
-{
+void cat(int fd) {
   int n;
 
-  while((n = read(fd, buf, sizeof(buf))) > 0) {
+  while ((n = read(fd, buf, sizeof(buf))) > 0) {
     if (write(1, buf, n) != n) {
       printf(1, "cat: write error\n");
       exit();
     }
   }
-  if(n < 0){
+  if (n < 0) {
     printf(1, "cat: read error\n");
     exit();
   }
 }
 
-int
-main(int argc, char *argv[])
-{
+int main(int argc, char *argv[]) {
   int fd, i;
 
-  if(argc <= 1){
+  if (argc <= 1) {
     cat(0);
     exit();
   }
 
-  for(i = 1; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
+  for (i = 1; i < argc; i++) {
+    if ((fd = open(argv[i], 0)) < 0) {
       printf(1, "cat: cannot open %s\n", argv[i]);
       exit();
     }
diff --git a/console.c b/console.c
index a280d2b..1ee89c6 100644
--- a/console.c
+++ b/console.c
@@ -24,57 +24,53 @@ static struct {
   int locking;
 } cons;
 
-static void
-printint(int xx, int base, int sign)
-{
+static void printint(int xx, int base, int sign) {
   static char digits[] = "0123456789abcdef";
   char buf[16];
   int i;
   uint x;
 
-  if(sign && (sign = xx < 0))
+  if (sign && (sign = xx < 0))
     x = -xx;
   else
     x = xx;
 
   i = 0;
-  do{
+  do {
     buf[i++] = digits[x % base];
-  }while((x /= base) != 0);
+  } while ((x /= base) != 0);
 
-  if(sign)
+  if (sign)
     buf[i++] = '-';
 
-  while(--i >= 0)
+  while (--i >= 0)
     consputc(buf[i]);
 }
-//PAGEBREAK: 50
+// PAGEBREAK: 50
 
 // Print to the console. only understands %d, %x, %p, %s.
-void
-cprintf(char *fmt, ...)
-{
+void cprintf(char *fmt, ...) {
   int i, c, locking;
   uint *argp;
   char *s;
 
   locking = cons.locking;
-  if(locking)
+  if (locking)
     acquire(&cons.lock);
 
   if (fmt == 0)
     panic("null fmt");
 
-  argp = (uint*)(void*)(&fmt + 1);
-  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
-    if(c != '%'){
+  argp = (uint *)(void *)(&fmt + 1);
+  for (i = 0; (c = fmt[i] & 0xff) != 0; i++) {
+    if (c != '%') {
       consputc(c);
       continue;
     }
     c = fmt[++i] & 0xff;
-    if(c == 0)
+    if (c == 0)
       break;
-    switch(c){
+    switch (c) {
     case 'd':
       printint(*argp++, 10, 1);
       break;
@@ -83,9 +79,9 @@ cprintf(char *fmt, ...)
       printint(*argp++, 16, 0);
       break;
     case 's':
-      if((s = (char*)*argp++) == 0)
+      if ((s = (char *)*argp++) == 0)
         s = "(null)";
-      for(; *s; s++)
+      for (; *s; s++)
         consputc(*s);
       break;
     case '%':
@@ -99,13 +95,11 @@ cprintf(char *fmt, ...)
     }
   }
 
-  if(locking)
+  if (locking)
     release(&cons.lock);
 }
 
-void
-panic(char *s)
-{
+void panic(char *s) {
   int i;
   uint pcs[10];
 
@@ -116,63 +110,62 @@ panic(char *s)
   cprintf(s);
   cprintf("\n");
   getcallerpcs(&s, pcs);
-  for(i=0; i<10; i++)
+  for (i = 0; i < 10; i++)
     cprintf(" %p", pcs[i]);
   panicked = 1; // freeze other CPU
-  for(;;)
+  for (;;)
     ;
 }
 
-//PAGEBREAK: 50
+// PAGEBREAK: 50
 #define BACKSPACE 0x100
 #define CRTPORT 0x3d4
-static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
+static ushort *crt = (ushort *)P2V(0xb8000); // CGA memory
 
-static void
-cgaputc(int c)
-{
+static void cgaputc(int c) {
   int pos;
 
   // Cursor position: col + 80*row.
   outb(CRTPORT, 14);
-  pos = inb(CRTPORT+1) << 8;
+  pos = inb(CRTPORT + 1) << 8;
   outb(CRTPORT, 15);
-  pos |= inb(CRTPORT+1);
+  pos |= inb(CRTPORT + 1);
 
-  if(c == '\n')
-    pos += 80 - pos%80;
-  else if(c == BACKSPACE){
-    if(pos > 0) --pos;
+  if (c == '\n')
+    pos += 80 - pos % 80;
+  else if (c == BACKSPACE) {
+    if (pos > 0)
+      --pos;
   } else
-    crt[pos++] = (c&0xff) | 0x0700;  // black on white
+    crt[pos++] = (c & 0xff) | 0x0700; // black on white
 
-  if(pos < 0 || pos > 25*80)
+  if (pos < 0 || pos > 25 * 80)
     panic("pos under/overflow");
 
-  if((pos/80) >= 24){  // Scroll up.
-    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+  if ((pos / 80) >= 24) { // Scroll up.
+    memmove(crt, crt + 80, sizeof(crt[0]) * 23 * 80);
     pos -= 80;
-    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+    memset(crt + pos, 0, sizeof(crt[0]) * (24 * 80 - pos));
   }
 
   outb(CRTPORT, 14);
-  outb(CRTPORT+1, pos>>8);
+  outb(CRTPORT + 1, pos >> 8);
   outb(CRTPORT, 15);
-  outb(CRTPORT+1, pos);
+  outb(CRTPORT + 1, pos);
   crt[pos] = ' ' | 0x0700;
 }
 
-void
-consputc(int c)
-{
-  if(panicked){
+void consputc(int c) {
+  if (panicked) {
     cli();
-    for(;;)
+    for (;;)
       ;
   }
 
-  if(c == BACKSPACE){
-    uartputc('\b'); uartputc(' '); uartputc('\b');
+  if (c == BACKSPACE) {
+    uartputc('\b');
+    uartputc(' ');
+    uartputc('\b');
   } else
     uartputc(c);
   cgaputc(c);
@@ -181,44 +174,43 @@ consputc(int c)
 #define INPUT_BUF 128
 struct {
   char buf[INPUT_BUF];
-  uint r;  // Read index
-  uint w;  // Write index
-  uint e;  // Edit index
+  uint r; // Read index
+  uint w; // Write index
+  uint e; // Edit index
 } input;
 
-#define C(x)  ((x)-'@')  // Control-x
+#define C(x) ((x) - '@') // Control-x
 
-void
-consoleintr(int (*getc)(void))
-{
+void consoleintr(int (*getc)(void)) {
   int c, doprocdump = 0;
 
   acquire(&cons.lock);
-  while((c = getc()) >= 0){
-    switch(c){
-    case C('P'):  // Process listing.
+  while ((c = getc()) >= 0) {
+    switch (c) {
+    case C('P'): // Process listing.
       // procdump() locks cons.lock indirectly; invoke later
       doprocdump = 1;
       break;
-    case C('U'):  // Kill line.
-      while(input.e != input.w &&
-            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+    case C('U'): // Kill line.
+      while (input.e != input.w &&
+             input.buf[(input.e - 1) % INPUT_BUF] != '\n') {
         input.e--;
         consputc(BACKSPACE);
       }
       break;
-    case C('H'): case '\x7f':  // Backspace
-      if(input.e != input.w){
+    case C('H'):
+    case '\x7f': // Backspace
+      if (input.e != input.w) {
         input.e--;
         consputc(BACKSPACE);
       }
       break;
     default:
-      if(c != 0 && input.e-input.r < INPUT_BUF){
+      if (c != 0 && input.e - input.r < INPUT_BUF) {
         c = (c == '\r') ? '\n' : c;
         input.buf[input.e++ % INPUT_BUF] = c;
         consputc(c);
-        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
+        if (c == '\n' || c == C('D') || input.e == input.r + INPUT_BUF) {
           input.w = input.e;
           wakeup(&input.r);
         }
@@ -227,23 +219,21 @@ consoleintr(int (*getc)(void))
     }
   }
   release(&cons.lock);
-  if(doprocdump) {
-    procdump();  // now call procdump() wo. cons.lock held
+  if (doprocdump) {
+    procdump(); // now call procdump() wo. cons.lock held
   }
 }
 
-int
-consoleread(struct inode *ip, char *dst, int n)
-{
+int consoleread(struct inode *ip, char *dst, int n) {
   uint target;
   int c;
 
   iunlock(ip);
   target = n;
   acquire(&cons.lock);
-  while(n > 0){
-    while(input.r == input.w){
-      if(myproc()->killed){
+  while (n > 0) {
+    while (input.r == input.w) {
+      if (myproc()->killed) {
         release(&cons.lock);
         ilock(ip);
         return -1;
@@ -251,8 +241,8 @@ consoleread(struct inode *ip, char *dst, int n)
       sleep(&input.r, &cons.lock);
     }
     c = input.buf[input.r++ % INPUT_BUF];
-    if(c == C('D')){  // EOF
-      if(n < target){
+    if (c == C('D')) { // EOF
+      if (n < target) {
         // Save ^D for next time, to make sure
         // caller gets a 0-byte result.
         input.r--;
@@ -261,7 +251,7 @@ consoleread(struct inode *ip, char *dst, int n)
     }
     *dst++ = c;
     --n;
-    if(c == '\n')
+    if (c == '\n')
       break;
   }
   release(&cons.lock);
@@ -270,14 +260,12 @@ consoleread(struct inode *ip, char *dst, int n)
   return target - n;
 }
 
-int
-consolewrite(struct inode *ip, char *buf, int n)
-{
+int consolewrite(struct inode *ip, char *buf, int n) {
   int i;
 
   iunlock(ip);
   acquire(&cons.lock);
-  for(i = 0; i < n; i++)
+  for (i = 0; i < n; i++)
     consputc(buf[i] & 0xff);
   release(&cons.lock);
   ilock(ip);
@@ -285,9 +273,7 @@ consolewrite(struct inode *ip, char *buf, int n)
   return n;
 }
 
-void
-consoleinit(void)
-{
+void consoleinit(void) {
   initlock(&cons.lock, "console");
 
   devsw[CONSOLE].write = consolewrite;
@@ -296,4 +282,3 @@ consoleinit(void)
 
   ioapicenable(IRQ_KBD, 0);
 }
-
diff --git a/date.c b/date.c
index 64cd3bc..e89784b 100644
--- a/date.c
+++ b/date.c
@@ -2,9 +2,7 @@
 #include "user.h"
 #include "date.h"
 
-int
-main(int argc, char *argv[])
-{
+int main(int argc, char *argv[]) {
   struct rtcdate r;
 
   if (date(&r)) {
@@ -13,7 +11,8 @@ main(int argc, char *argv[])
   }
 
   // your code to print the time in any format you like...
-  // printf(1, "hour: %d, minute: %d, second: %d\n", r.hour, r.minute, r.second);
+  // printf(1, "hour: %d, minute: %d, second: %d\n", r.hour, r.minute,
+  // r.second);
 
   exit();
 }
\ No newline at end of file
diff --git a/defs.h b/defs.h
index 8237829..8627d58 100644
--- a/defs.h
+++ b/defs.h
@@ -11,180 +11,180 @@ struct stat;
 struct superblock;
 
 // bio.c
-void            binit(void);
-struct buf*     bread(uint, uint);
-void            brelse(struct buf*);
-void            bwrite(struct buf*);
+void binit(void);
+struct buf *bread(uint, uint);
+void brelse(struct buf *);
+void bwrite(struct buf *);
 
 // console.c
-void            consoleinit(void);
-void            cprintf(char*, ...);
-void            consoleintr(int(*)(void));
-void            panic(char*) __attribute__((noreturn));
+void consoleinit(void);
+void cprintf(char *, ...);
+void consoleintr(int (*)(void));
+void panic(char *) __attribute__((noreturn));
 
 // exec.c
-int             exec(char*, char**);
+int exec(char *, char **);
 
 // file.c
-struct file*    filealloc(void);
-void            fileclose(struct file*);
-struct file*    filedup(struct file*);
-void            fileinit(void);
-int             fileread(struct file*, char*, int n);
-int             filestat(struct file*, struct stat*);
-int             filewrite(struct file*, char*, int n);
+struct file *filealloc(void);
+void fileclose(struct file *);
+struct file *filedup(struct file *);
+void fileinit(void);
+int fileread(struct file *, char *, int n);
+int filestat(struct file *, struct stat *);
+int filewrite(struct file *, char *, int n);
 
 // fs.c
-void            readsb(int dev, struct superblock *sb);
-int             dirlink(struct inode*, char*, uint);
-struct inode*   dirlookup(struct inode*, char*, uint*);
-struct inode*   ialloc(uint, short);
-struct inode*   idup(struct inode*);
-void            iinit(int dev);
-void            ilock(struct inode*);
-void            iput(struct inode*);
-void            iunlock(struct inode*);
-void            iunlockput(struct inode*);
-void            iupdate(struct inode*);
-int             namecmp(const char*, const char*);
-struct inode*   namei(char*);
-struct inode*   nameiparent(char*, char*);
-int             readi(struct inode*, char*, uint, uint);
-void            stati(struct inode*, struct stat*);
-int             writei(struct inode*, char*, uint, uint);
+void readsb(int dev, struct superblock *sb);
+int dirlink(struct inode *, char *, uint);
+struct inode *dirlookup(struct inode *, char *, uint *);
+struct inode *ialloc(uint, short);
+struct inode *idup(struct inode *);
+void iinit(int dev);
+void ilock(struct inode *);
+void iput(struct inode *);
+void iunlock(struct inode *);
+void iunlockput(struct inode *);
+void iupdate(struct inode *);
+int namecmp(const char *, const char *);
+struct inode *namei(char *);
+struct inode *nameiparent(char *, char *);
+int readi(struct inode *, char *, uint, uint);
+void stati(struct inode *, struct stat *);
+int writei(struct inode *, char *, uint, uint);
 
 // ide.c
-void            ideinit(void);
-void            ideintr(void);
-void            iderw(struct buf*);
+void ideinit(void);
+void ideintr(void);
+void iderw(struct buf *);
 
 // ioapic.c
-void            ioapicenable(int irq, int cpu);
-extern uchar    ioapicid;
-void            ioapicinit(void);
+void ioapicenable(int irq, int cpu);
+extern uchar ioapicid;
+void ioapicinit(void);
 
 // kalloc.c
-char*           kalloc(void);
-void            kfree(char*);
-void            kinit1(void*, void*);
-void            kinit2(void*, void*);
+char *kalloc(void);
+void kfree(char *);
+void kinit1(void *, void *);
+void kinit2(void *, void *);
 
 // kbd.c
-void            kbdintr(void);
+void kbdintr(void);
 
 // lapic.c
-void            cmostime(struct rtcdate *r);
-int             lapicid(void);
-extern volatile uint*    lapic;
-void            lapiceoi(void);
-void            lapicinit(void);
-void            lapicstartap(uchar, uint);
-void            microdelay(int);
+void cmostime(struct rtcdate *r);
+int lapicid(void);
+extern volatile uint *lapic;
+void lapiceoi(void);
+void lapicinit(void);
+void lapicstartap(uchar, uint);
+void microdelay(int);
 
 // log.c
-void            initlog(int dev);
-void            log_write(struct buf*);
-void            begin_op();
-void            end_op();
+void initlog(int dev);
+void log_write(struct buf *);
+void begin_op();
+void end_op();
 
 // mp.c
-extern int      ismp;
-void            mpinit(void);
+extern int ismp;
+void mpinit(void);
 
 // picirq.c
-void            picenable(int);
-void            picinit(void);
+void picenable(int);
+void picinit(void);
 
 // pipe.c
-int             pipealloc(struct file**, struct file**);
-void            pipeclose(struct pipe*, int);
-int             piperead(struct pipe*, char*, int);
-int             pipewrite(struct pipe*, char*, int);
+int pipealloc(struct file **, struct file **);
+void pipeclose(struct pipe *, int);
+int piperead(struct pipe *, char *, int);
+int pipewrite(struct pipe *, char *, int);
 
-//PAGEBREAK: 16
+// PAGEBREAK: 16
 // proc.c
-int             cpuid(void);
-void            exit(void);
-int             fork(void);
+int cpuid(void);
+void exit(void);
+int fork(void);
 // int             growproc(int);
-int             kill(int);
-struct cpu*     mycpu(void);
-struct proc*    myproc();
-void            pinit(void);
-void            procdump(void);
-void            scheduler(void) __attribute__((noreturn));
-void            sched(void);
-void            setproc(struct proc*);
-void            sleep(void*, struct spinlock*);
-void            userinit(void);
-int             wait(void);
-void            wakeup(void*);
-void            yield(void);
+int kill(int);
+struct cpu *mycpu(void);
+struct proc *myproc();
+void pinit(void);
+void procdump(void);
+void scheduler(void) __attribute__((noreturn));
+void sched(void);
+void setproc(struct proc *);
+void sleep(void *, struct spinlock *);
+void userinit(void);
+int wait(void);
+void wakeup(void *);
+void yield(void);
 
 // swtch.S
-void            swtch(struct context**, struct context*);
+void swtch(struct context **, struct context *);
 
 // spinlock.c
-void            acquire(struct spinlock*);
-void            getcallerpcs(void*, uint*);
-int             holding(struct spinlock*);
-void            initlock(struct spinlock*, char*);
-void            release(struct spinlock*);
-void            pushcli(void);
-void            popcli(void);
+void acquire(struct spinlock *);
+void getcallerpcs(void *, uint *);
+int holding(struct spinlock *);
+void initlock(struct spinlock *, char *);
+void release(struct spinlock *);
+void pushcli(void);
+void popcli(void);
 
 // sleeplock.c
-void            acquiresleep(struct sleeplock*);
-void            releasesleep(struct sleeplock*);
-int             holdingsleep(struct sleeplock*);
-void            initsleeplock(struct sleeplock*, char*);
+void acquiresleep(struct sleeplock *);
+void releasesleep(struct sleeplock *);
+int holdingsleep(struct sleeplock *);
+void initsleeplock(struct sleeplock *, char *);
 
 // string.c
-int             memcmp(const void*, const void*, uint);
-void*           memmove(void*, const void*, uint);
-void*           memset(void*, int, uint);
-char*           safestrcpy(char*, const char*, int);
-int             strlen(const char*);
-int             strncmp(const char*, const char*, uint);
-char*           strncpy(char*, const char*, int);
+int memcmp(const void *, const void *, uint);
+void *memmove(void *, const void *, uint);
+void *memset(void *, int, uint);
+char *safestrcpy(char *, const char *, int);
+int strlen(const char *);
+int strncmp(const char *, const char *, uint);
+char *strncpy(char *, const char *, int);
 
 // syscall.c
-int             argint(int, int*);
-int             argptr(int, char**, int);
-int             argstr(int, char**);
-int             fetchint(uint, int*);
-int             fetchstr(uint, char**);
-void            syscall(void);
+int argint(int, int *);
+int argptr(int, char **, int);
+int argstr(int, char **);
+int fetchint(uint, int *);
+int fetchstr(uint, char **);
+void syscall(void);
 
 // timer.c
-void            timerinit(void);
+void timerinit(void);
 
 // trap.c
-void            idtinit(void);
-extern uint     ticks;
-void            tvinit(void);
+void idtinit(void);
+extern uint ticks;
+void tvinit(void);
 extern struct spinlock tickslock;
 
 // uart.c
-void            uartinit(void);
-void            uartintr(void);
-void            uartputc(int);
+void uartinit(void);
+void uartintr(void);
+void uartputc(int);
 
 // vm.c
-void            seginit(void);
-void            kvmalloc(void);
-pde_t*          setupkvm(void);
-char*           uva2ka(pde_t*, char*);
-int             allocuvm(pde_t*, uint, uint);
-int             deallocuvm(pde_t*, uint, uint);
-void            freevm(pde_t*);
-void            inituvm(pde_t*, char*, uint);
-int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
-pde_t*          copyuvm(pde_t*, uint);
-void            switchuvm(struct proc*);
-void            switchkvm(void);
-int             copyout(pde_t*, uint, void*, uint);
-void            clearpteu(pde_t *pgdir, char *uva);
+void seginit(void);
+void kvmalloc(void);
+pde_t *setupkvm(void);
+char *uva2ka(pde_t *, char *);
+int allocuvm(pde_t *, uint, uint);
+int deallocuvm(pde_t *, uint, uint);
+void freevm(pde_t *);
+void inituvm(pde_t *, char *, uint);
+int loaduvm(pde_t *, char *, struct inode *, uint, uint);
+pde_t *copyuvm(pde_t *, uint);
+void switchuvm(struct proc *);
+void switchkvm(void);
+int copyout(pde_t *, uint, void *, uint);
+void clearpteu(pde_t *pgdir, char *uva);
 
 // number of elements in fixed-size array
-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+#define NELEM(x) (sizeof(x) / sizeof((x)[0]))
diff --git a/echo.c b/echo.c
index 806dee0..ac54ae9 100644
--- a/echo.c
+++ b/echo.c
@@ -2,12 +2,10 @@
 #include "stat.h"
 #include "user.h"
 
-int
-main(int argc, char *argv[])
-{
+int main(int argc, char *argv[]) {
   int i;
 
-  for(i = 1; i < argc; i++)
-    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+  for (i = 1; i < argc; i++)
+    printf(1, "%s%s", argv[i], i + 1 < argc ? " " : "\n");
   exit();
 }
diff --git a/elf.h b/elf.h
index d16c967..d41e509 100644
--- a/elf.h
+++ b/elf.h
@@ -1,10 +1,10 @@
 // Format of an ELF executable file
 
-#define ELF_MAGIC 0x464C457FU  // "\x7FELF" in little endian
+#define ELF_MAGIC 0x464C457FU // "\x7FELF" in little endian
 
 // File header
 struct elfhdr {
-  uint magic;  // must equal ELF_MAGIC
+  uint magic; // must equal ELF_MAGIC
   uchar elf[12];
   ushort type;
   ushort machine;
@@ -34,9 +34,9 @@ struct proghdr {
 };
 
 // Values for Proghdr type
-#define ELF_PROG_LOAD           1
+#define ELF_PROG_LOAD 1
 
 // Flag bits for Proghdr flags
-#define ELF_PROG_FLAG_EXEC      1
-#define ELF_PROG_FLAG_WRITE     2
-#define ELF_PROG_FLAG_READ      4
+#define ELF_PROG_FLAG_EXEC 1
+#define ELF_PROG_FLAG_WRITE 2
+#define ELF_PROG_FLAG_READ 4
diff --git a/exec.c b/exec.c
index d8d6738..d360725 100644
--- a/exec.c
+++ b/exec.c
@@ -7,12 +7,10 @@
 #include "x86.h"
 #include "elf.h"
 
-int
-exec(char *path, char **argv)
-{
+int exec(char *path, char **argv) {
   char *s, *last;
   int i, off;
-  uint argc, sz, sp, ustack[3+MAXARG+1];
+  uint argc, sz, sp, ustack[3 + MAXARG + 1];
   struct elfhdr elf;
   struct inode *ip;
   struct proghdr ph;
@@ -21,7 +19,7 @@ exec(char *path, char **argv)
 
   begin_op();
 
-  if((ip = namei(path)) == 0){
+  if ((ip = namei(path)) == 0) {
     end_op();
     cprintf("exec: fail\n");
     return -1;
@@ -30,30 +28,32 @@ exec(char *path, char **argv)
   pgdir = 0;
 
   // Check ELF header
-  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
+  if (readi(ip, (char *)&elf, 0, sizeof(elf)) != sizeof(elf))
     goto bad;
-  if(elf.magic != ELF_MAGIC)
+  if (elf.magic != ELF_MAGIC)
     goto bad;
 
-  if((pgdir = setupkvm()) == 0)
+  if ((pgdir = setupkvm()) == 0)
     goto bad;
 
   // Load program into memory.
   sz = 0;
-  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
-    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
+  for (i = 0, off = elf.phoff; i < elf.phnum; i++, off += sizeof(ph)) {
+    if (readi(ip, (char *)&ph, off, sizeof(ph)) != sizeof(ph))
       goto bad;
-    if(ph.type != ELF_PROG_LOAD)
+    if (ph.type != ELF_PROG_LOAD)
       continue;
-    if(ph.memsz < ph.filesz)
+    if (ph.memsz < ph.filesz)
       goto bad;
-    if(ph.vaddr + ph.memsz < ph.vaddr)  // check overflow to avoid attack, loaduvm will otherwise load code in kernel space
+    if (ph.vaddr + ph.memsz <
+        ph.vaddr) // check overflow to avoid attack, loaduvm will otherwise load
+                  // code in kernel space
       goto bad;
-    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+    if ((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
       goto bad;
-    if(ph.vaddr % PGSIZE != 0)
+    if (ph.vaddr % PGSIZE != 0)
       goto bad;
-    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+    if (loaduvm(pgdir, (char *)ph.vaddr, ip, ph.off, ph.filesz) < 0)
       goto bad;
   }
   iunlockput(ip);
@@ -63,24 +63,27 @@ exec(char *path, char **argv)
   // Allocate two pages at the next page boundary.
   // Make the first inaccessible.  Use the second as the user stack.
   sz = PGROUNDUP(sz);
-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+  if ((sz = allocuvm(pgdir, sz, sz + 2 * PGSIZE)) == 0)
     goto bad;
-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE)); // guarding a user stack with an unmapped page
+  clearpteu(
+      pgdir,
+      (char *)(sz - 2 * PGSIZE)); // guarding a user stack with an unmapped page
   sp = sz;
 
   // Push argument strings, prepare rest of stack in ustack.
-  for(argc = 0; argv[argc]; argc++) {
-    if(argc >= MAXARG)
+  for (argc = 0; argv[argc]; argc++) {
+    if (argc >= MAXARG)
       goto bad;
-    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;  // if argv is too large, might hit inaccessible area
-    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+    sp = (sp - (strlen(argv[argc]) + 1)) &
+         ~3; // if argv is too large, might hit inaccessible area
+    if (copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
       goto bad;
-    ustack[3+argc] = sp;    // save the address of each argument
+    ustack[3 + argc] = sp; // save the address of each argument
   }
-  ustack[3+argc] = 0;
+  ustack[3 + argc] = 0;
 
   // ustack structure (will be copied to user runtime stack):
-  /*|     0      |*/   /*high*/
+  /*|     0      |*/ /*high*/
   /*|------------|*/
   /*|  &argv[0]  |*/
   /*|  &argv[1]  |*/
@@ -89,41 +92,43 @@ exec(char *path, char **argv)
   /*|------------|*/
   /*|  argv ptr  |*/
   /*|   argc     |*/
-  /*| 0xffffffff |*/   /*low*/
+  /*| 0xffffffff |*/ /*low*/
 
-  ustack[0] = 0xffffffff;  // fake return PC
+  ustack[0] = 0xffffffff; // fake return PC
   ustack[1] = argc;
-  ustack[2] = sp - (argc+1)*4;  // argv pointer
+  ustack[2] = sp - (argc + 1) * 4; // argv pointer
 
-  sp -= (3+argc+1) * 4;
-  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+  sp -= (3 + argc + 1) * 4;
+  if (copyout(pgdir, sp, ustack, (3 + argc + 1) * 4) < 0)
     goto bad;
 
   // Save program name for debugging.
-  for(last=s=path; *s; s++)
-    if(*s == '/')
-      last = s+1;
+  for (last = s = path; *s; s++)
+    if (*s == '/')
+      last = s + 1;
   safestrcpy(curproc->name, last, sizeof(curproc->name));
 
-  // A process’s most important pieces of kernel state are its page table, its kernel stack, and its run state
-  // below we change the page table, its kernel stack, leaving run state as the same
+  // A process’s most important pieces of kernel state are its page table, its
+  // kernel stack, and its run state below we change the page table, its kernel
+  // stack, leaving run state as the same
 
   // Commit to the user image.
   oldpgdir = curproc->pgdir;
   curproc->pgdir = pgdir;
   curproc->sz = sz;
-  curproc->tf->eip = elf.entry;  // main
+  curproc->tf->eip = elf.entry; // main
   curproc->tf->esp = sp;
   switchuvm(curproc);
   freevm(oldpgdir);
   return 0;
   // drop into trapret, restore new process context with new image installed,
-  // the curproc's kernel stack contains new information needed (eip, esp, pgdir...)
+  // the curproc's kernel stack contains new information needed (eip, esp,
+  // pgdir...)
 
- bad:
-  if(pgdir)
+bad:
+  if (pgdir)
     freevm(pgdir);
-  if(ip){
+  if (ip) {
     iunlockput(ip);
     end_op();
   }
diff --git a/fcntl.h b/fcntl.h
index d565483..20c2756 100644
--- a/fcntl.h
+++ b/fcntl.h
@@ -1,4 +1,4 @@
-#define O_RDONLY  0x000
-#define O_WRONLY  0x001
-#define O_RDWR    0x002
-#define O_CREATE  0x200
+#define O_RDONLY 0x000
+#define O_WRONLY 0x001
+#define O_RDWR 0x002
+#define O_CREATE 0x200
diff --git a/file.c b/file.c
index 24b32c2..22bd6fc 100644
--- a/file.c
+++ b/file.c
@@ -16,21 +16,15 @@ struct {
   struct file file[NFILE];
 } ftable;
 
-void
-fileinit(void)
-{
-  initlock(&ftable.lock, "ftable");
-}
+void fileinit(void) { initlock(&ftable.lock, "ftable"); }
 
 // Allocate a file structure.
-struct file*
-filealloc(void)
-{
+struct file *filealloc(void) {
   struct file *f;
 
   acquire(&ftable.lock);
-  for(f = ftable.file; f < ftable.file + NFILE; f++){
-    if(f->ref == 0){
+  for (f = ftable.file; f < ftable.file + NFILE; f++) {
+    if (f->ref == 0) {
       f->ref = 1;
       release(&ftable.lock);
       return f;
@@ -41,11 +35,9 @@ filealloc(void)
 }
 
 // Increment ref count for file f.
-struct file*
-filedup(struct file *f)
-{
+struct file *filedup(struct file *f) {
   acquire(&ftable.lock);
-  if(f->ref < 1)
+  if (f->ref < 1)
     panic("filedup");
   f->ref++;
   release(&ftable.lock);
@@ -53,15 +45,13 @@ filedup(struct file *f)
 }
 
 // Close file f.  (Decrement ref count, close when reaches 0.)
-void
-fileclose(struct file *f)
-{
+void fileclose(struct file *f) {
   struct file ff;
 
   acquire(&ftable.lock);
-  if(f->ref < 1)
+  if (f->ref < 1)
     panic("fileclose");
-  if(--f->ref > 0){
+  if (--f->ref > 0) {
     release(&ftable.lock);
     return;
   }
@@ -70,9 +60,9 @@ fileclose(struct file *f)
   f->type = FD_NONE;
   release(&ftable.lock);
 
-  if(ff.type == FD_PIPE)
+  if (ff.type == FD_PIPE)
     pipeclose(ff.pipe, ff.writable);
-  else if(ff.type == FD_INODE){
+  else if (ff.type == FD_INODE) {
     begin_op();
     iput(ff.ip);
     end_op();
@@ -80,10 +70,8 @@ fileclose(struct file *f)
 }
 
 // Get metadata about file f.
-int
-filestat(struct file *f, struct stat *st)
-{
-  if(f->type == FD_INODE){
+int filestat(struct file *f, struct stat *st) {
+  if (f->type == FD_INODE) {
     ilock(f->ip);
     stati(f->ip, st);
     iunlock(f->ip);
@@ -93,18 +81,16 @@ filestat(struct file *f, struct stat *st)
 }
 
 // Read from file f.
-int
-fileread(struct file *f, char *addr, int n)
-{
+int fileread(struct file *f, char *addr, int n) {
   int r;
 
-  if(f->readable == 0)
+  if (f->readable == 0)
     return -1;
-  if(f->type == FD_PIPE)
+  if (f->type == FD_PIPE)
     return piperead(f->pipe, addr, n);
-  if(f->type == FD_INODE){
+  if (f->type == FD_INODE) {
     ilock(f->ip);
-    if((r = readi(f->ip, addr, f->off, n)) > 0)
+    if ((r = readi(f->ip, addr, f->off, n)) > 0)
       f->off += r;
     iunlock(f->ip);
     return r;
@@ -112,29 +98,27 @@ fileread(struct file *f, char *addr, int n)
   panic("fileread");
 }
 
-//PAGEBREAK!
+// PAGEBREAK!
 // Write to file f.
-int
-filewrite(struct file *f, char *addr, int n)
-{
+int filewrite(struct file *f, char *addr, int n) {
   int r;
 
-  if(f->writable == 0)
+  if (f->writable == 0)
     return -1;
-  if(f->type == FD_PIPE)
+  if (f->type == FD_PIPE)
     return pipewrite(f->pipe, addr, n);
-  if(f->type == FD_INODE){
+  if (f->type == FD_INODE) {
     // write a few blocks at a time to avoid exceeding
     // the maximum log transaction size, including
     // i-node, indirect block, allocation blocks,
     // and 2 blocks of slop for non-aligned writes.
     // this really belongs lower down, since writei()
     // might be writing a device like the console.
-    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
+    int max = ((MAXOPBLOCKS - 1 - 1 - 2) / 2) * 512;
     int i = 0;
-    while(i < n){
+    while (i < n) {
       int n1 = n - i;
-      if(n1 > max)
+      if (n1 > max)
         n1 = max;
 
       begin_op();
@@ -144,9 +128,9 @@ filewrite(struct file *f, char *addr, int n)
       iunlock(f->ip);
       end_op();
 
-      if(r < 0)
+      if (r < 0)
         break;
-      if(r != n1)
+      if (r != n1)
         panic("short filewrite");
       i += r;
     }
@@ -154,4 +138,3 @@ filewrite(struct file *f, char *addr, int n)
   }
   panic("filewrite");
 }
-
diff --git a/file.h b/file.h
index 0990c82..4e613d7 100644
--- a/file.h
+++ b/file.h
@@ -8,28 +8,27 @@ struct file {
   uint off;
 };
 
-
 // in-memory copy of an inode
 struct inode {
-  uint dev;           // Device number
-  uint inum;          // Inode number
-  int ref;            // Reference count
+  uint dev;              // Device number
+  uint inum;             // Inode number
+  int ref;               // Reference count
   struct sleeplock lock; // protects everything below here
-  int valid;          // inode has been read from disk?
+  int valid;             // inode has been read from disk?
 
-  short type;         // copy of disk inode
+  short type; // copy of disk inode
   short major;
   short minor;
   short nlink;
   uint size;
-  uint addrs[NDIRECT+1];
+  uint addrs[NDIRECT + 1];
 };
 
 // table mapping major device number to
 // device functions
 struct devsw {
-  int (*read)(struct inode*, char*, int);
-  int (*write)(struct inode*, char*, int);
+  int (*read)(struct inode *, char *, int);
+  int (*write)(struct inode *, char *, int);
 };
 
 extern struct devsw devsw[];
diff --git a/forktest.c b/forktest.c
index 8bc984d..6a26d3e 100644
--- a/forktest.c
+++ b/forktest.c
@@ -5,42 +5,36 @@
 #include "stat.h"
 #include "user.h"
 
-#define N  1000
+#define N 1000
 
-void
-printf(int fd, const char *s, ...)
-{
-  write(fd, s, strlen(s));
-}
+void printf(int fd, const char *s, ...) { write(fd, s, strlen(s)); }
 
-void
-forktest(void)
-{
+void forktest(void) {
   int n, pid;
 
   printf(1, "fork test\n");
 
-  for(n=0; n<N; n++){
+  for (n = 0; n < N; n++) {
     pid = fork();
-    if(pid < 0)
+    if (pid < 0)
       break;
-    if(pid == 0)
+    if (pid == 0)
       exit();
   }
 
-  if(n == N){
+  if (n == N) {
     printf(1, "fork claimed to work N times!\n", N);
     exit();
   }
 
-  for(; n > 0; n--){
-    if(wait() < 0){
+  for (; n > 0; n--) {
+    if (wait() < 0) {
       printf(1, "wait stopped early\n");
       exit();
     }
   }
 
-  if(wait() != -1){
+  if (wait() != -1) {
     printf(1, "wait got too many\n");
     exit();
   }
@@ -48,9 +42,7 @@ forktest(void)
   printf(1, "fork test OK\n");
 }
 
-int
-main(void)
-{
+int main(void) {
   forktest();
   exit();
 }
diff --git a/fs.c b/fs.c
index f77275f..ea08c95 100644
--- a/fs.c
+++ b/fs.c
@@ -22,15 +22,13 @@
 #include "file.h"
 
 #define min(a, b) ((a) < (b) ? (a) : (b))
-static void itrunc(struct inode*);
+static void itrunc(struct inode *);
 // there should be one superblock per disk device, but we run with
 // only one device
-struct superblock sb; 
+struct superblock sb;
 
 // Read the super block.
-void
-readsb(int dev, struct superblock *sb)
-{
+void readsb(int dev, struct superblock *sb) {
   struct buf *bp;
 
   bp = bread(dev, 1);
@@ -39,9 +37,7 @@ readsb(int dev, struct superblock *sb)
 }
 
 // Zero a block.
-static void
-bzero(int dev, int bno)
-{
+static void bzero(int dev, int bno) {
   struct buf *bp;
 
   bp = bread(dev, bno);
@@ -53,19 +49,17 @@ bzero(int dev, int bno)
 // Blocks.
 
 // Allocate a zeroed disk block.
-static uint
-balloc(uint dev)
-{
+static uint balloc(uint dev) {
   int b, bi, m;
   struct buf *bp;
 
   bp = 0;
-  for(b = 0; b < sb.size; b += BPB){
+  for (b = 0; b < sb.size; b += BPB) {
     bp = bread(dev, BBLOCK(b, sb));
-    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+    for (bi = 0; bi < BPB && b + bi < sb.size; bi++) {
       m = 1 << (bi % 8);
-      if((bp->data[bi/8] & m) == 0){  // Is block free?
-        bp->data[bi/8] |= m;  // Mark block in use.
+      if ((bp->data[bi / 8] & m) == 0) { // Is block free?
+        bp->data[bi / 8] |= m;           // Mark block in use.
         log_write(bp);
         brelse(bp);
         bzero(dev, b + bi);
@@ -78,18 +72,16 @@ balloc(uint dev)
 }
 
 // Free a disk block.
-static void
-bfree(int dev, uint b)
-{
+static void bfree(int dev, uint b) {
   struct buf *bp;
   int bi, m;
 
   bp = bread(dev, BBLOCK(b, sb));
   bi = b % BPB;
   m = 1 << (bi % 8);
-  if((bp->data[bi/8] & m) == 0)
+  if ((bp->data[bi / 8] & m) == 0)
     panic("freeing free block");
-  bp->data[bi/8] &= ~m;
+  bp->data[bi / 8] &= ~m;
   log_write(bp);
   brelse(bp);
 }
@@ -168,43 +160,39 @@ struct {
   struct inode inode[NINODE];
 } icache;
 
-void
-iinit(int dev)
-{
+void iinit(int dev) {
   int i = 0;
-  
+
   initlock(&icache.lock, "icache");
-  for(i = 0; i < NINODE; i++) {
+  for (i = 0; i < NINODE; i++) {
     initsleeplock(&icache.inode[i].lock, "inode");
   }
 
   readsb(dev, &sb);
   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
- inodestart %d bmap start %d\n", sb.size, sb.nblocks,
-          sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
+ inodestart %d bmap start %d\n",
+          sb.size, sb.nblocks, sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
           sb.bmapstart);
 }
 
-static struct inode* iget(uint dev, uint inum);
+static struct inode *iget(uint dev, uint inum);
 
-//PAGEBREAK!
+// PAGEBREAK!
 // Allocate an inode on device dev.
 // Mark it as allocated by  giving it type type.
 // Returns an unlocked but allocated and referenced inode.
-struct inode*
-ialloc(uint dev, short type)
-{
+struct inode *ialloc(uint dev, short type) {
   int inum;
   struct buf *bp;
   struct dinode *dip;
 
-  for(inum = 1; inum < sb.ninodes; inum++){
+  for (inum = 1; inum < sb.ninodes; inum++) {
     bp = bread(dev, IBLOCK(inum, sb));
-    dip = (struct dinode*)bp->data + inum%IPB;
-    if(dip->type == 0){  // a free inode
+    dip = (struct dinode *)bp->data + inum % IPB;
+    if (dip->type == 0) { // a free inode
       memset(dip, 0, sizeof(*dip));
       dip->type = type;
-      log_write(bp);   // mark it allocated on the disk
+      log_write(bp); // mark it allocated on the disk
       brelse(bp);
       return iget(dev, inum);
     }
@@ -217,14 +205,12 @@ ialloc(uint dev, short type)
 // Must be called after every change to an ip->xxx field
 // that lives on disk, since i-node cache is write-through.
 // Caller must hold ip->lock.
-void
-iupdate(struct inode *ip)
-{
+void iupdate(struct inode *ip) {
   struct buf *bp;
   struct dinode *dip;
 
   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
-  dip = (struct dinode*)bp->data + ip->inum%IPB;
+  dip = (struct dinode *)bp->data + ip->inum % IPB;
   dip->type = ip->type;
   dip->major = ip->major;
   dip->minor = ip->minor;
@@ -238,27 +224,25 @@ iupdate(struct inode *ip)
 // Find the inode with number inum on device dev
 // and return the in-memory copy. Does not lock
 // the inode and does not read it from disk.
-static struct inode*
-iget(uint dev, uint inum)
-{
+static struct inode *iget(uint dev, uint inum) {
   struct inode *ip, *empty;
 
   acquire(&icache.lock);
 
   // Is the inode already cached?
   empty = 0;
-  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
-    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+  for (ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++) {
+    if (ip->ref > 0 && ip->dev == dev && ip->inum == inum) {
       ip->ref++;
       release(&icache.lock);
       return ip;
     }
-    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+    if (empty == 0 && ip->ref == 0) // Remember empty slot.
       empty = ip;
   }
 
   // Recycle an inode cache entry.
-  if(empty == 0)
+  if (empty == 0)
     panic("iget: no inodes");
 
   ip = empty;
@@ -273,9 +257,7 @@ iget(uint dev, uint inum)
 
 // Increment reference count for ip.
 // Returns ip to enable ip = idup(ip1) idiom.
-struct inode*
-idup(struct inode *ip)
-{
+struct inode *idup(struct inode *ip) {
   acquire(&icache.lock);
   ip->ref++;
   release(&icache.lock);
@@ -284,20 +266,18 @@ idup(struct inode *ip)
 
 // Lock the given inode.
 // Reads the inode from disk if necessary.
-void
-ilock(struct inode *ip)
-{
+void ilock(struct inode *ip) {
   struct buf *bp;
   struct dinode *dip;
 
-  if(ip == 0 || ip->ref < 1)
+  if (ip == 0 || ip->ref < 1)
     panic("ilock");
 
   acquiresleep(&ip->lock);
 
-  if(ip->valid == 0){
+  if (ip->valid == 0) {
     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
-    dip = (struct dinode*)bp->data + ip->inum%IPB;
+    dip = (struct dinode *)bp->data + ip->inum % IPB;
     ip->type = dip->type;
     ip->major = dip->major;
     ip->minor = dip->minor;
@@ -306,16 +286,14 @@ ilock(struct inode *ip)
     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
     brelse(bp);
     ip->valid = 1;
-    if(ip->type == 0)
+    if (ip->type == 0)
       panic("ilock: no type");
   }
 }
 
 // Unlock the given inode.
-void
-iunlock(struct inode *ip)
-{
-  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+void iunlock(struct inode *ip) {
+  if (ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
     panic("iunlock");
 
   releasesleep(&ip->lock);
@@ -328,15 +306,13 @@ iunlock(struct inode *ip)
 // to it, free the inode (and its content) on disk.
 // All calls to iput() must be inside a transaction in
 // case it has to free the inode.
-void
-iput(struct inode *ip)
-{
+void iput(struct inode *ip) {
   acquiresleep(&ip->lock);
-  if(ip->valid && ip->nlink == 0){
+  if (ip->valid && ip->nlink == 0) {
     acquire(&icache.lock);
     int r = ip->ref;
     release(&icache.lock);
-    if(r == 1){
+    if (r == 1) {
       // inode has no links and no other references: truncate and free.
       itrunc(ip);
       ip->type = 0;
@@ -352,14 +328,12 @@ iput(struct inode *ip)
 }
 
 // Common idiom: unlock, then put.
-void
-iunlockput(struct inode *ip)
-{
+void iunlockput(struct inode *ip) {
   iunlock(ip);
   iput(ip);
 }
 
-//PAGEBREAK!
+// PAGEBREAK!
 // Inode content
 //
 // The content (data) associated with each inode is stored
@@ -369,26 +343,24 @@ iunlockput(struct inode *ip)
 
 // Return the disk block address of the nth block in inode ip.
 // If there is no such block, bmap allocates one.
-static uint
-bmap(struct inode *ip, uint bn)
-{
+static uint bmap(struct inode *ip, uint bn) {
   uint addr, *a;
   struct buf *bp;
 
-  if(bn < NDIRECT){
-    if((addr = ip->addrs[bn]) == 0)
+  if (bn < NDIRECT) {
+    if ((addr = ip->addrs[bn]) == 0)
       ip->addrs[bn] = addr = balloc(ip->dev);
     return addr;
   }
   bn -= NDIRECT;
 
-  if(bn < NINDIRECT){
+  if (bn < NINDIRECT) {
     // Load indirect block, allocating if necessary.
-    if((addr = ip->addrs[NDIRECT]) == 0)
+    if ((addr = ip->addrs[NDIRECT]) == 0)
       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
     bp = bread(ip->dev, addr);
-    a = (uint*)bp->data;
-    if((addr = a[bn]) == 0){
+    a = (uint *)bp->data;
+    if ((addr = a[bn]) == 0) {
       a[bn] = addr = balloc(ip->dev);
       log_write(bp);
     }
@@ -404,25 +376,23 @@ bmap(struct inode *ip, uint bn)
 // to it (no directory entries referring to it)
 // and has no in-memory reference to it (is
 // not an open file or current directory).
-static void
-itrunc(struct inode *ip)
-{
+static void itrunc(struct inode *ip) {
   int i, j;
   struct buf *bp;
   uint *a;
 
-  for(i = 0; i < NDIRECT; i++){
-    if(ip->addrs[i]){
+  for (i = 0; i < NDIRECT; i++) {
+    if (ip->addrs[i]) {
       bfree(ip->dev, ip->addrs[i]);
       ip->addrs[i] = 0;
     }
   }
 
-  if(ip->addrs[NDIRECT]){
+  if (ip->addrs[NDIRECT]) {
     bp = bread(ip->dev, ip->addrs[NDIRECT]);
-    a = (uint*)bp->data;
-    for(j = 0; j < NINDIRECT; j++){
-      if(a[j])
+    a = (uint *)bp->data;
+    for (j = 0; j < NINDIRECT; j++) {
+      if (a[j])
         bfree(ip->dev, a[j]);
     }
     brelse(bp);
@@ -436,9 +406,7 @@ itrunc(struct inode *ip)
 
 // Copy stat information from inode.
 // Caller must hold ip->lock.
-void
-stati(struct inode *ip, struct stat *st)
-{
+void stati(struct inode *ip, struct stat *st) {
   st->dev = ip->dev;
   st->ino = ip->inum;
   st->type = ip->type;
@@ -446,30 +414,28 @@ stati(struct inode *ip, struct stat *st)
   st->size = ip->size;
 }
 
-//PAGEBREAK!
+// PAGEBREAK!
 // Read data from inode.
 // Caller must hold ip->lock.
-int
-readi(struct inode *ip, char *dst, uint off, uint n)
-{
+int readi(struct inode *ip, char *dst, uint off, uint n) {
   uint tot, m;
   struct buf *bp;
 
-  if(ip->type == T_DEV){
-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+  if (ip->type == T_DEV) {
+    if (ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
       return -1;
     return devsw[ip->major].read(ip, dst, n);
   }
 
-  if(off > ip->size || off + n < off)
+  if (off > ip->size || off + n < off)
     return -1;
-  if(off + n > ip->size)
+  if (off + n > ip->size)
     n = ip->size - off;
 
-  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
-    m = min(n - tot, BSIZE - off%BSIZE);
-    memmove(dst, bp->data + off%BSIZE, m);
+  for (tot = 0; tot < n; tot += m, off += m, dst += m) {
+    bp = bread(ip->dev, bmap(ip, off / BSIZE));
+    m = min(n - tot, BSIZE - off % BSIZE);
+    memmove(dst, bp->data + off % BSIZE, m);
     brelse(bp);
   }
   return n;
@@ -478,66 +444,58 @@ readi(struct inode *ip, char *dst, uint off, uint n)
 // PAGEBREAK!
 // Write data to inode.
 // Caller must hold ip->lock.
-int
-writei(struct inode *ip, char *src, uint off, uint n)
-{
+int writei(struct inode *ip, char *src, uint off, uint n) {
   uint tot, m;
   struct buf *bp;
 
-  if(ip->type == T_DEV){
-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+  if (ip->type == T_DEV) {
+    if (ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
       return -1;
     return devsw[ip->major].write(ip, src, n);
   }
 
-  if(off > ip->size || off + n < off)
+  if (off > ip->size || off + n < off)
     return -1;
-  if(off + n > MAXFILE*BSIZE)
+  if (off + n > MAXFILE * BSIZE)
     return -1;
 
-  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
-    m = min(n - tot, BSIZE - off%BSIZE);
-    memmove(bp->data + off%BSIZE, src, m);
+  for (tot = 0; tot < n; tot += m, off += m, src += m) {
+    bp = bread(ip->dev, bmap(ip, off / BSIZE));
+    m = min(n - tot, BSIZE - off % BSIZE);
+    memmove(bp->data + off % BSIZE, src, m);
     log_write(bp);
     brelse(bp);
   }
 
-  if(n > 0 && off > ip->size){
+  if (n > 0 && off > ip->size) {
     ip->size = off;
     iupdate(ip);
   }
   return n;
 }
 
-//PAGEBREAK!
+// PAGEBREAK!
 // Directories
 
-int
-namecmp(const char *s, const char *t)
-{
-  return strncmp(s, t, DIRSIZ);
-}
+int namecmp(const char *s, const char *t) { return strncmp(s, t, DIRSIZ); }
 
 // Look for a directory entry in a directory.
 // If found, set *poff to byte offset of entry.
-struct inode*
-dirlookup(struct inode *dp, char *name, uint *poff)
-{
+struct inode *dirlookup(struct inode *dp, char *name, uint *poff) {
   uint off, inum;
   struct dirent de;
 
-  if(dp->type != T_DIR)
+  if (dp->type != T_DIR)
     panic("dirlookup not DIR");
 
-  for(off = 0; off < dp->size; off += sizeof(de)){
-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+  for (off = 0; off < dp->size; off += sizeof(de)) {
+    if (readi(dp, (char *)&de, off, sizeof(de)) != sizeof(de))
       panic("dirlookup read");
-    if(de.inum == 0)
+    if (de.inum == 0)
       continue;
-    if(namecmp(name, de.name) == 0){
+    if (namecmp(name, de.name) == 0) {
       // entry matches path element
-      if(poff)
+      if (poff)
         *poff = off;
       inum = de.inum;
       return iget(dp->dev, inum);
@@ -548,36 +506,34 @@ dirlookup(struct inode *dp, char *name, uint *poff)
 }
 
 // Write a new directory entry (name, inum) into the directory dp.
-int
-dirlink(struct inode *dp, char *name, uint inum)
-{
+int dirlink(struct inode *dp, char *name, uint inum) {
   int off;
   struct dirent de;
   struct inode *ip;
 
   // Check that name is not present.
-  if((ip = dirlookup(dp, name, 0)) != 0){
+  if ((ip = dirlookup(dp, name, 0)) != 0) {
     iput(ip);
     return -1;
   }
 
   // Look for an empty dirent.
-  for(off = 0; off < dp->size; off += sizeof(de)){
-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+  for (off = 0; off < dp->size; off += sizeof(de)) {
+    if (readi(dp, (char *)&de, off, sizeof(de)) != sizeof(de))
       panic("dirlink read");
-    if(de.inum == 0)
+    if (de.inum == 0)
       break;
   }
 
   strncpy(de.name, name, DIRSIZ);
   de.inum = inum;
-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+  if (writei(dp, (char *)&de, off, sizeof(de)) != sizeof(de))
     panic("dirlink");
 
   return 0;
 }
 
-//PAGEBREAK!
+// PAGEBREAK!
 // Paths
 
 // Copy the next path element from path into name.
@@ -592,27 +548,25 @@ dirlink(struct inode *dp, char *name, uint inum)
 //   skipelem("a", name) = "", setting name = "a"
 //   skipelem("", name) = skipelem("////", name) = 0
 //
-static char*
-skipelem(char *path, char *name)
-{
+static char *skipelem(char *path, char *name) {
   char *s;
   int len;
 
-  while(*path == '/')
+  while (*path == '/')
     path++;
-  if(*path == 0)
+  if (*path == 0)
     return 0;
   s = path;
-  while(*path != '/' && *path != 0)
+  while (*path != '/' && *path != 0)
     path++;
   len = path - s;
-  if(len >= DIRSIZ)
+  if (len >= DIRSIZ)
     memmove(name, s, DIRSIZ);
   else {
     memmove(name, s, len);
     name[len] = 0;
   }
-  while(*path == '/')
+  while (*path == '/')
     path++;
   return path;
 }
@@ -621,50 +575,44 @@ skipelem(char *path, char *name)
 // If parent != 0, return the inode for the parent and copy the final
 // path element into name, which must have room for DIRSIZ bytes.
 // Must be called inside a transaction since it calls iput().
-static struct inode*
-namex(char *path, int nameiparent, char *name)
-{
+static struct inode *namex(char *path, int nameiparent, char *name) {
   struct inode *ip, *next;
 
-  if(*path == '/')
+  if (*path == '/')
     ip = iget(ROOTDEV, ROOTINO);
   else
     ip = idup(myproc()->cwd);
 
-  while((path = skipelem(path, name)) != 0){
+  while ((path = skipelem(path, name)) != 0) {
     ilock(ip);
-    if(ip->type != T_DIR){
+    if (ip->type != T_DIR) {
       iunlockput(ip);
       return 0;
     }
-    if(nameiparent && *path == '\0'){
+    if (nameiparent && *path == '\0') {
       // Stop one level early.
       iunlock(ip);
       return ip;
     }
-    if((next = dirlookup(ip, name, 0)) == 0){
+    if ((next = dirlookup(ip, name, 0)) == 0) {
       iunlockput(ip);
       return 0;
     }
     iunlockput(ip);
     ip = next;
   }
-  if(nameiparent){
+  if (nameiparent) {
     iput(ip);
     return 0;
   }
   return ip;
 }
 
-struct inode*
-namei(char *path)
-{
+struct inode *namei(char *path) {
   char name[DIRSIZ];
   return namex(path, 0, name);
 }
 
-struct inode*
-nameiparent(char *path, char *name)
-{
+struct inode *nameiparent(char *path, char *name) {
   return namex(path, 1, name);
 }
diff --git a/fs.h b/fs.h
index 3214f1d..ff03b95 100644
--- a/fs.h
+++ b/fs.h
@@ -1,9 +1,8 @@
 // On-disk file system format.
 // Both the kernel and user programs use this header file.
 
-
-#define ROOTINO 1  // root i-number
-#define BSIZE 512  // block size
+#define ROOTINO 1 // root i-number
+#define BSIZE 512 // block size
 
 // Disk layout:
 // [ boot block | super block | log | inode blocks |
@@ -12,13 +11,13 @@
 // mkfs computes the super block and builds an initial file system. The
 // super block describes the disk layout:
 struct superblock {
-  uint size;         // Size of file system image (blocks)
-  uint nblocks;      // Number of data blocks
-  uint ninodes;      // Number of inodes.
-  uint nlog;         // Number of log blocks
-  uint logstart;     // Block number of first log block
-  uint inodestart;   // Block number of first inode block
-  uint bmapstart;    // Block number of first free map block
+  uint size;       // Size of file system image (blocks)
+  uint nblocks;    // Number of data blocks
+  uint ninodes;    // Number of inodes.
+  uint nlog;       // Number of log blocks
+  uint logstart;   // Block number of first log block
+  uint inodestart; // Block number of first inode block
+  uint bmapstart;  // Block number of first free map block
 };
 
 #define NDIRECT 12
@@ -27,25 +26,25 @@ struct superblock {
 
 // On-disk inode structure
 struct dinode {
-  short type;           // File type
-  short major;          // Major device number (T_DEV only)
-  short minor;          // Minor device number (T_DEV only)
-  short nlink;          // Number of links to inode in file system
-  uint size;            // Size of file (bytes)
-  uint addrs[NDIRECT+1];   // Data block addresses
+  short type;              // File type
+  short major;             // Major device number (T_DEV only)
+  short minor;             // Minor device number (T_DEV only)
+  short nlink;             // Number of links to inode in file system
+  uint size;               // Size of file (bytes)
+  uint addrs[NDIRECT + 1]; // Data block addresses
 };
 
 // Inodes per block.
-#define IPB           (BSIZE / sizeof(struct dinode))
+#define IPB (BSIZE / sizeof(struct dinode))
 
 // Block containing inode i
-#define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
+#define IBLOCK(i, sb) ((i) / IPB + sb.inodestart)
 
 // Bitmap bits per block
-#define BPB           (BSIZE*8)
+#define BPB (BSIZE * 8)
 
 // Block of free map containing bit for block b
-#define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
+#define BBLOCK(b, sb) (b / BPB + sb.bmapstart)
 
 // Directory is a file containing a sequence of dirent structures.
 #define DIRSIZ 14
@@ -54,4 +53,3 @@ struct dirent {
   ushort inum;
   char name[DIRSIZ];
 };
-
diff --git a/grep.c b/grep.c
index adc4835..7c88945 100644
--- a/grep.c
+++ b/grep.c
@@ -5,55 +5,51 @@
 #include "user.h"
 
 char buf[1024];
-int match(char*, char*);
+int match(char *, char *);
 
-void
-grep(char *pattern, int fd)
-{
+void grep(char *pattern, int fd) {
   int n, m;
   char *p, *q;
 
   m = 0;
-  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+  while ((n = read(fd, buf + m, sizeof(buf) - m - 1)) > 0) {
     m += n;
     buf[m] = '\0';
     p = buf;
-    while((q = strchr(p, '\n')) != 0){
+    while ((q = strchr(p, '\n')) != 0) {
       *q = 0;
-      if(match(pattern, p)){
+      if (match(pattern, p)) {
         *q = '\n';
-        write(1, p, q+1 - p);
+        write(1, p, q + 1 - p);
       }
-      p = q+1;
+      p = q + 1;
     }
-    if(p == buf)
+    if (p == buf)
       m = 0;
-    if(m > 0){
+    if (m > 0) {
       m -= p - buf;
       memmove(buf, p, m);
     }
   }
 }
 
-int
-main(int argc, char *argv[])
-{
+int main(int argc, char *argv[]) {
   int fd, i;
   char *pattern;
 
-  if(argc <= 1){
+  if (argc <= 1) {
     printf(2, "usage: grep pattern [file ...]\n");
     exit();
   }
   pattern = argv[1];
 
-  if(argc <= 2){
+  if (argc <= 2) {
     grep(pattern, 0);
     exit();
   }
 
-  for(i = 2; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
+  for (i = 2; i < argc; i++) {
+    if ((fd = open(argv[i], 0)) < 0) {
       printf(1, "grep: cannot open %s\n", argv[i]);
       exit();
     }
@@ -66,42 +62,37 @@ main(int argc, char *argv[])
 // Regexp matcher from Kernighan & Pike,
 // The Practice of Programming, Chapter 9.
 
-int matchhere(char*, char*);
-int matchstar(int, char*, char*);
+int matchhere(char *, char *);
+int matchstar(int, char *, char *);
 
-int
-match(char *re, char *text)
-{
-  if(re[0] == '^')
-    return matchhere(re+1, text);
-  do{  // must look at empty string
-    if(matchhere(re, text))
+int match(char *re, char *text) {
+  if (re[0] == '^')
+    return matchhere(re + 1, text);
+  do { // must look at empty string
+    if (matchhere(re, text))
       return 1;
-  }while(*text++ != '\0');
+  } while (*text++ != '\0');
   return 0;
 }
 
 // matchhere: search for re at beginning of text
-int matchhere(char *re, char *text)
-{
-  if(re[0] == '\0')
+int matchhere(char *re, char *text) {
+  if (re[0] == '\0')
     return 1;
-  if(re[1] == '*')
-    return matchstar(re[0], re+2, text);
-  if(re[0] == '$' && re[1] == '\0')
+  if (re[1] == '*')
+    return matchstar(re[0], re + 2, text);
+  if (re[0] == '$' && re[1] == '\0')
     return *text == '\0';
-  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
-    return matchhere(re+1, text+1);
+  if (*text != '\0' && (re[0] == '.' || re[0] == *text))
+    return matchhere(re + 1, text + 1);
   return 0;
 }
 
 // matchstar: search for c*re at beginning of text
-int matchstar(int c, char *re, char *text)
-{
-  do{  // a * matches zero or more instances
-    if(matchhere(re, text))
+int matchstar(int c, char *re, char *text) {
+  do { // a * matches zero or more instances
+    if (matchhere(re, text))
       return 1;
-  }while(*text!='\0' && (*text++==c || c=='.'));
+  } while (*text != '\0' && (*text++ == c || c == '.'));
   return 0;
 }
-
diff --git a/ide.c b/ide.c
index b4c0b1f..58c9810 100644
--- a/ide.c
+++ b/ide.c
@@ -13,13 +13,13 @@
 #include "fs.h"
 #include "buf.h"
 
-#define SECTOR_SIZE   512
-#define IDE_BSY       0x80
-#define IDE_DRDY      0x40
-#define IDE_DF        0x20
-#define IDE_ERR       0x01
+#define SECTOR_SIZE 512
+#define IDE_BSY 0x80
+#define IDE_DRDY 0x40
+#define IDE_DF 0x20
+#define IDE_ERR 0x01
 
-#define IDE_CMD_READ  0x20
+#define IDE_CMD_READ 0x20
 #define IDE_CMD_WRITE 0x30
 #define IDE_CMD_RDMUL 0xc4
 #define IDE_CMD_WRMUL 0xc5
@@ -32,24 +32,20 @@ static struct spinlock idelock;
 static struct buf *idequeue;
 
 static int havedisk1;
-static void idestart(struct buf*);
+static void idestart(struct buf *);
 
 // Wait for IDE disk to become ready.
-static int
-idewait(int checkerr)
-{
+static int idewait(int checkerr) {
   int r;
 
-  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
+  while (((r = inb(0x1f7)) & (IDE_BSY | IDE_DRDY)) != IDE_DRDY)
     ;
-  if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
+  if (checkerr && (r & (IDE_DF | IDE_ERR)) != 0)
     return -1;
   return 0;
 }
 
-void
-ideinit(void)
-{
+void ideinit(void) {
   int i;
 
   initlock(&idelock, "ide");
@@ -57,66 +53,63 @@ ideinit(void)
   idewait(0);
 
   // Check if disk 1 is present
-  outb(0x1f6, 0xe0 | (1<<4));
-  for(i=0; i<1000; i++){
-    if(inb(0x1f7) != 0){
+  outb(0x1f6, 0xe0 | (1 << 4));
+  for (i = 0; i < 1000; i++) {
+    if (inb(0x1f7) != 0) {
       havedisk1 = 1;
       break;
     }
   }
 
   // Switch back to disk 0.
-  outb(0x1f6, 0xe0 | (0<<4));
+  outb(0x1f6, 0xe0 | (0 << 4));
 }
 
 // Start the request for b.  Caller must hold idelock.
-static void
-idestart(struct buf *b)
-{
-  if(b == 0)
+static void idestart(struct buf *b) {
+  if (b == 0)
     panic("idestart");
-  if(b->blockno >= FSSIZE)
+  if (b->blockno >= FSSIZE)
     panic("incorrect blockno");
-  int sector_per_block =  BSIZE/SECTOR_SIZE;
+  int sector_per_block = BSIZE / SECTOR_SIZE;
   int sector = b->blockno * sector_per_block;
-  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
+  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ : IDE_CMD_RDMUL;
   int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
 
-  if (sector_per_block > 7) panic("idestart");
+  if (sector_per_block > 7)
+    panic("idestart");
 
   idewait(0);
-  outb(0x3f6, 0);  // generate interrupt
-  outb(0x1f2, sector_per_block);  // number of sectors
+  outb(0x3f6, 0);                // generate interrupt
+  outb(0x1f2, sector_per_block); // number of sectors
   outb(0x1f3, sector & 0xff);
   outb(0x1f4, (sector >> 8) & 0xff);
   outb(0x1f5, (sector >> 16) & 0xff);
-  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
-  if(b->flags & B_DIRTY){
+  outb(0x1f6, 0xe0 | ((b->dev & 1) << 4) | ((sector >> 24) & 0x0f));
+  if (b->flags & B_DIRTY) {
     outb(0x1f7, write_cmd);
-    outsl(0x1f0, b->data, BSIZE/4);
+    outsl(0x1f0, b->data, BSIZE / 4);
   } else {
     outb(0x1f7, read_cmd);
   }
 }
 
 // Interrupt handler.
-void
-ideintr(void)
-{
+void ideintr(void) {
   struct buf *b;
 
   // First queued buffer is the active request.
   acquire(&idelock);
 
-  if((b = idequeue) == 0){
+  if ((b = idequeue) == 0) {
     release(&idelock);
     return;
   }
   idequeue = b->qnext;
 
   // Read data if needed.
-  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
-    insl(0x1f0, b->data, BSIZE/4);
+  if (!(b->flags & B_DIRTY) && idewait(1) >= 0)
+    insl(0x1f0, b->data, BSIZE / 4);
 
   // Wake process waiting for this buf.
   b->flags |= B_VALID;
@@ -124,45 +117,42 @@ ideintr(void)
   wakeup(b);
 
   // Start disk on next buf in queue.
-  if(idequeue != 0)
+  if (idequeue != 0)
     idestart(idequeue);
 
   release(&idelock);
 }
 
-//PAGEBREAK!
+// PAGEBREAK!
 // Sync buf with disk.
 // If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
 // Else if B_VALID is not set, read buf from disk, set B_VALID.
-void
-iderw(struct buf *b)
-{
+void iderw(struct buf *b) {
   struct buf **pp;
 
-  if(!holdingsleep(&b->lock))
+  if (!holdingsleep(&b->lock))
     panic("iderw: buf not locked");
-  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+  if ((b->flags & (B_VALID | B_DIRTY)) == B_VALID)
     panic("iderw: nothing to do");
-  if(b->dev != 0 && !havedisk1)
+  if (b->dev != 0 && !havedisk1)
     panic("iderw: ide disk 1 not present");
 
-  acquire(&idelock);  //DOC:acquire-lock
+  acquire(&idelock); // DOC:acquire-lock
 
   // Append b to idequeue.
   b->qnext = 0;
-  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+  for (pp = &idequeue; *pp; pp = &(*pp)->qnext) // DOC:insert-queue
     ;
   *pp = b;
 
   // Start disk if necessary.
-  if(idequeue == b)
+  if (idequeue == b)
     idestart(b);
 
   // Wait for request to finish.
-  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+  while ((b->flags & (B_VALID | B_DIRTY)) != B_VALID) {
     sleep(b, &idelock);
   }
 
-
   release(&idelock);
 }
diff --git a/init.c b/init.c
index 046b551..ffca867 100644
--- a/init.c
+++ b/init.c
@@ -5,33 +5,31 @@
 #include "user.h"
 #include "fcntl.h"
 
-char *argv[] = { "sh", 0 };
+char *argv[] = {"sh", 0};
 
-int
-main(void)
-{
+int main(void) {
   int pid, wpid;
 
-  if(open("console", O_RDWR) < 0){
+  if (open("console", O_RDWR) < 0) {
     mknod("console", 1, 1);
     open("console", O_RDWR);
   }
-  dup(0);  // stdout
-  dup(0);  // stderr
+  dup(0); // stdout
+  dup(0); // stderr
 
-  for(;;){
+  for (;;) {
     printf(1, "init: starting sh\n");
     pid = fork();
-    if(pid < 0){
+    if (pid < 0) {
       printf(1, "init: fork failed\n");
       exit();
     }
-    if(pid == 0){
+    if (pid == 0) {
       exec("sh", argv);
       printf(1, "init: exec sh failed\n");
       exit();
     }
-    while((wpid=wait()) >= 0 && wpid != pid)
+    while ((wpid = wait()) >= 0 && wpid != pid)
       printf(1, "zombie!\n");
   }
 }
diff --git a/ioapic.c b/ioapic.c
index cb0f015..a165945 100644
--- a/ioapic.c
+++ b/ioapic.c
@@ -6,21 +6,21 @@
 #include "defs.h"
 #include "traps.h"
 
-#define IOAPIC  0xFEC00000   // Default physical address of IO APIC
+#define IOAPIC 0xFEC00000 // Default physical address of IO APIC
 
-#define REG_ID     0x00  // Register index: ID
-#define REG_VER    0x01  // Register index: version
-#define REG_TABLE  0x10  // Redirection table base
+#define REG_ID 0x00    // Register index: ID
+#define REG_VER 0x01   // Register index: version
+#define REG_TABLE 0x10 // Redirection table base
 
 // The redirection table starts at REG_TABLE and uses
 // two registers to configure each interrupt.
 // The first (low) register in a pair contains configuration bits.
 // The second (high) register contains a bitmask telling which
 // CPUs can serve that interrupt.
-#define INT_DISABLED   0x00010000  // Interrupt disabled
-#define INT_LEVEL      0x00008000  // Level-triggered (vs edge-)
-#define INT_ACTIVELOW  0x00002000  // Active low (vs high)
-#define INT_LOGICAL    0x00000800  // Destination is CPU id (vs APIC ID)
+#define INT_DISABLED 0x00010000  // Interrupt disabled
+#define INT_LEVEL 0x00008000     // Level-triggered (vs edge-)
+#define INT_ACTIVELOW 0x00002000 // Active low (vs high)
+#define INT_LOGICAL 0x00000800   // Destination is CPU id (vs APIC ID)
 
 volatile struct ioapic *ioapic;
 
@@ -31,45 +31,37 @@ struct ioapic {
   uint data;
 };
 
-static uint
-ioapicread(int reg)
-{
+static uint ioapicread(int reg) {
   ioapic->reg = reg;
   return ioapic->data;
 }
 
-static void
-ioapicwrite(int reg, uint data)
-{
+static void ioapicwrite(int reg, uint data) {
   ioapic->reg = reg;
   ioapic->data = data;
 }
 
-void
-ioapicinit(void)
-{
+void ioapicinit(void) {
   int i, id, maxintr;
 
-  ioapic = (volatile struct ioapic*)IOAPIC;
+  ioapic = (volatile struct ioapic *)IOAPIC;
   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
   id = ioapicread(REG_ID) >> 24;
-  if(id != ioapicid)
+  if (id != ioapicid)
     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
 
   // Mark all interrupts edge-triggered, active high, disabled,
   // and not routed to any CPUs.
-  for(i = 0; i <= maxintr; i++){
-    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
-    ioapicwrite(REG_TABLE+2*i+1, 0);
+  for (i = 0; i <= maxintr; i++) {
+    ioapicwrite(REG_TABLE + 2 * i, INT_DISABLED | (T_IRQ0 + i));
+    ioapicwrite(REG_TABLE + 2 * i + 1, 0);
   }
 }
 
-void
-ioapicenable(int irq, int cpunum)
-{
+void ioapicenable(int irq, int cpunum) {
   // Mark interrupt edge-triggered, active high,
   // enabled, and routed to the given cpunum,
   // which happens to be that cpu's APIC ID.
-  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
-  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
+  ioapicwrite(REG_TABLE + 2 * irq, T_IRQ0 + irq);
+  ioapicwrite(REG_TABLE + 2 * irq + 1, cpunum << 24);
 }
diff --git a/kalloc.c b/kalloc.c
index 3f6e10b..e34b504 100644
--- a/kalloc.c
+++ b/kalloc.c
@@ -28,69 +28,58 @@ struct {
 // the pages mapped by entrypgdir on free list.
 // 2. main() calls kinit2() with the rest of the physical pages
 // after installing a full page table that maps them on all cores.
-void
-kinit1(void *vstart, void *vend)
-{
+void kinit1(void *vstart, void *vend) {
   initlock(&kmem.lock, "kmem");
   kmem.use_lock = 0;
   freerange(vstart, vend);
 }
 
-void
-kinit2(void *vstart, void *vend)
-{
+void kinit2(void *vstart, void *vend) {
   freerange(vstart, vend);
   kmem.use_lock = 1;
 }
 
-void
-freerange(void *vstart, void *vend)
-{
+void freerange(void *vstart, void *vend) {
   char *p;
-  p = (char*)PGROUNDUP((uint)vstart);
-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+  p = (char *)PGROUNDUP((uint)vstart);
+  for (; p + PGSIZE <= (char *)vend; p += PGSIZE)
     kfree(p);
 }
-//PAGEBREAK: 21
+// PAGEBREAK: 21
 // Free the page of physical memory pointed at by v,
 // which normally should have been returned by a
 // call to kalloc().  (The exception is when
 // initializing the allocator; see kinit above.)
-void
-kfree(char *v)
-{
+void kfree(char *v) {
   struct run *r;
 
-  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
+  if ((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
     panic("kfree");
 
   // Fill with junk to catch dangling refs.
   memset(v, 1, PGSIZE);
 
-  if(kmem.use_lock)
+  if (kmem.use_lock)
     acquire(&kmem.lock);
-  r = (struct run*)v;
-  r->next = kmem.freelist;  // store struct in page itself
+  r = (struct run *)v;
+  r->next = kmem.freelist; // store struct in page itself
   kmem.freelist = r;
-  if(kmem.use_lock)
+  if (kmem.use_lock)
     release(&kmem.lock);
 }
 
 // Allocate one 4096-byte page of physical memory.
 // Returns a pointer that the kernel can use.
 // Returns 0 if the memory cannot be allocated.
-char*
-kalloc(void)
-{
+char *kalloc(void) {
   struct run *r;
 
-  if(kmem.use_lock)
+  if (kmem.use_lock)
     acquire(&kmem.lock);
   r = kmem.freelist;
-  if(r)
+  if (r)
     kmem.freelist = r->next;
-  if(kmem.use_lock)
+  if (kmem.use_lock)
     release(&kmem.lock);
-  return (char*)r;
+  return (char *)r;
 }
-
diff --git a/kbd.c b/kbd.c
index 32c1463..f80fa7c 100644
--- a/kbd.c
+++ b/kbd.c
@@ -3,29 +3,25 @@
 #include "defs.h"
 #include "kbd.h"
 
-int
-kbdgetc(void)
-{
+int kbdgetc(void) {
   static uint shift;
-  static uchar *charcode[4] = {
-    normalmap, shiftmap, ctlmap, ctlmap
-  };
+  static uchar *charcode[4] = {normalmap, shiftmap, ctlmap, ctlmap};
   uint st, data, c;
 
   st = inb(KBSTATP);
-  if((st & KBS_DIB) == 0)
+  if ((st & KBS_DIB) == 0)
     return -1;
   data = inb(KBDATAP);
 
-  if(data == 0xE0){
+  if (data == 0xE0) {
     shift |= E0ESC;
     return 0;
-  } else if(data & 0x80){
+  } else if (data & 0x80) {
     // Key released
     data = (shift & E0ESC ? data : data & 0x7F);
     shift &= ~(shiftcode[data] | E0ESC);
     return 0;
-  } else if(shift & E0ESC){
+  } else if (shift & E0ESC) {
     // Last character was an E0 escape; or with 0x80
     data |= 0x80;
     shift &= ~E0ESC;
@@ -34,17 +30,13 @@ kbdgetc(void)
   shift |= shiftcode[data];
   shift ^= togglecode[data];
   c = charcode[shift & (CTL | SHIFT)][data];
-  if(shift & CAPSLOCK){
-    if('a' <= c && c <= 'z')
+  if (shift & CAPSLOCK) {
+    if ('a' <= c && c <= 'z')
       c += 'A' - 'a';
-    else if('A' <= c && c <= 'Z')
+    else if ('A' <= c && c <= 'Z')
       c += 'a' - 'A';
   }
   return c;
 }
 
-void
-kbdintr(void)
-{
-  consoleintr(kbdgetc);
-}
+void kbdintr(void) { consoleintr(kbdgetc); }
diff --git a/kbd.h b/kbd.h
index babbd6e..30dbd84 100644
--- a/kbd.h
+++ b/kbd.h
@@ -1,112 +1,309 @@
 // PC keyboard interface constants
 
-#define KBSTATP         0x64    // kbd controller status port(I)
-#define KBS_DIB         0x01    // kbd data in buffer
-#define KBDATAP         0x60    // kbd data port(I)
+#define KBSTATP 0x64 // kbd controller status port(I)
+#define KBS_DIB 0x01 // kbd data in buffer
+#define KBDATAP 0x60 // kbd data port(I)
 
-#define NO              0
+#define NO 0
 
-#define SHIFT           (1<<0)
-#define CTL             (1<<1)
-#define ALT             (1<<2)
+#define SHIFT (1 << 0)
+#define CTL (1 << 1)
+#define ALT (1 << 2)
 
-#define CAPSLOCK        (1<<3)
-#define NUMLOCK         (1<<4)
-#define SCROLLLOCK      (1<<5)
+#define CAPSLOCK (1 << 3)
+#define NUMLOCK (1 << 4)
+#define SCROLLLOCK (1 << 5)
 
-#define E0ESC           (1<<6)
+#define E0ESC (1 << 6)
 
 // Special keycodes
-#define KEY_HOME        0xE0
-#define KEY_END         0xE1
-#define KEY_UP          0xE2
-#define KEY_DN          0xE3
-#define KEY_LF          0xE4
-#define KEY_RT          0xE5
-#define KEY_PGUP        0xE6
-#define KEY_PGDN        0xE7
-#define KEY_INS         0xE8
-#define KEY_DEL         0xE9
+#define KEY_HOME 0xE0
+#define KEY_END 0xE1
+#define KEY_UP 0xE2
+#define KEY_DN 0xE3
+#define KEY_LF 0xE4
+#define KEY_RT 0xE5
+#define KEY_PGUP 0xE6
+#define KEY_PGDN 0xE7
+#define KEY_INS 0xE8
+#define KEY_DEL 0xE9
 
 // C('A') == Control-A
 #define C(x) (x - '@')
 
-static uchar shiftcode[256] =
-{
-  [0x1D] CTL,
-  [0x2A] SHIFT,
-  [0x36] SHIFT,
-  [0x38] ALT,
-  [0x9D] CTL,
-  [0xB8] ALT
-};
+static uchar shiftcode[256] = {
+    [0x1D] CTL, [0x2A] SHIFT, [0x36] SHIFT, [0x38] ALT, [0x9D] CTL, [0xB8] ALT};
 
-static uchar togglecode[256] =
-{
-  [0x3A] CAPSLOCK,
-  [0x45] NUMLOCK,
-  [0x46] SCROLLLOCK
-};
+static uchar togglecode[256] = {
+    [0x3A] CAPSLOCK, [0x45] NUMLOCK, [0x46] SCROLLLOCK};
 
-static uchar normalmap[256] =
-{
-  NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  // 0x00
-  '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
-  'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  // 0x10
-  'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
-  'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  // 0x20
-  '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
-  'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  // 0x30
-  NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
-  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
-  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
-  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
-  [0x9C] '\n',      // KP_Enter
-  [0xB5] '/',       // KP_Div
-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
-  [0x97] KEY_HOME,  [0xCF] KEY_END,
-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
-};
+static uchar normalmap[256] = {NO,
+                               0x1B,
+                               '1',
+                               '2',
+                               '3',
+                               '4',
+                               '5',
+                               '6', // 0x00
+                               '7',
+                               '8',
+                               '9',
+                               '0',
+                               '-',
+                               '=',
+                               '\b',
+                               '\t',
+                               'q',
+                               'w',
+                               'e',
+                               'r',
+                               't',
+                               'y',
+                               'u',
+                               'i', // 0x10
+                               'o',
+                               'p',
+                               '[',
+                               ']',
+                               '\n',
+                               NO,
+                               'a',
+                               's',
+                               'd',
+                               'f',
+                               'g',
+                               'h',
+                               'j',
+                               'k',
+                               'l',
+                               ';', // 0x20
+                               '\'',
+                               '`',
+                               NO,
+                               '\\',
+                               'z',
+                               'x',
+                               'c',
+                               'v',
+                               'b',
+                               'n',
+                               'm',
+                               ',',
+                               '.',
+                               '/',
+                               NO,
+                               '*', // 0x30
+                               NO,
+                               ' ',
+                               NO,
+                               NO,
+                               NO,
+                               NO,
+                               NO,
+                               NO,
+                               NO,
+                               NO,
+                               NO,
+                               NO,
+                               NO,
+                               NO,
+                               NO,
+                               '7', // 0x40
+                               '8',
+                               '9',
+                               '-',
+                               '4',
+                               '5',
+                               '6',
+                               '+',
+                               '1',
+                               '2',
+                               '3',
+                               '0',
+                               '.',
+                               NO,
+                               NO,
+                               NO,
+                               NO,          // 0x50
+                               [0x9C] '\n', // KP_Enter
+                               [0xB5] '/',  // KP_Div
+                               [0xC8] KEY_UP,
+                               [0xD0] KEY_DN,
+                               [0xC9] KEY_PGUP,
+                               [0xD1] KEY_PGDN,
+                               [0xCB] KEY_LF,
+                               [0xCD] KEY_RT,
+                               [0x97] KEY_HOME,
+                               [0xCF] KEY_END,
+                               [0xD2] KEY_INS,
+                               [0xD3] KEY_DEL};
 
-static uchar shiftmap[256] =
-{
-  NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  // 0x00
-  '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
-  'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  // 0x10
-  'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
-  'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  // 0x20
-  '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
-  'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  // 0x30
-  NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
-  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
-  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
-  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
-  [0x9C] '\n',      // KP_Enter
-  [0xB5] '/',       // KP_Div
-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
-  [0x97] KEY_HOME,  [0xCF] KEY_END,
-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
-};
-
-static uchar ctlmap[256] =
-{
-  NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
-  NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
-  C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
-  C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
-  C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
-  NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
-  C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
-  [0x9C] '\r',      // KP_Enter
-  [0xB5] C('/'),    // KP_Div
-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
-  [0x97] KEY_HOME,  [0xCF] KEY_END,
-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
-};
+static uchar shiftmap[256] = {NO,
+                              033,
+                              '!',
+                              '@',
+                              '#',
+                              '$',
+                              '%',
+                              '^', // 0x00
+                              '&',
+                              '*',
+                              '(',
+                              ')',
+                              '_',
+                              '+',
+                              '\b',
+                              '\t',
+                              'Q',
+                              'W',
+                              'E',
+                              'R',
+                              'T',
+                              'Y',
+                              'U',
+                              'I', // 0x10
+                              'O',
+                              'P',
+                              '{',
+                              '}',
+                              '\n',
+                              NO,
+                              'A',
+                              'S',
+                              'D',
+                              'F',
+                              'G',
+                              'H',
+                              'J',
+                              'K',
+                              'L',
+                              ':', // 0x20
+                              '"',
+                              '~',
+                              NO,
+                              '|',
+                              'Z',
+                              'X',
+                              'C',
+                              'V',
+                              'B',
+                              'N',
+                              'M',
+                              '<',
+                              '>',
+                              '?',
+                              NO,
+                              '*', // 0x30
+                              NO,
+                              ' ',
+                              NO,
+                              NO,
+                              NO,
+                              NO,
+                              NO,
+                              NO,
+                              NO,
+                              NO,
+                              NO,
+                              NO,
+                              NO,
+                              NO,
+                              NO,
+                              '7', // 0x40
+                              '8',
+                              '9',
+                              '-',
+                              '4',
+                              '5',
+                              '6',
+                              '+',
+                              '1',
+                              '2',
+                              '3',
+                              '0',
+                              '.',
+                              NO,
+                              NO,
+                              NO,
+                              NO,          // 0x50
+                              [0x9C] '\n', // KP_Enter
+                              [0xB5] '/',  // KP_Div
+                              [0xC8] KEY_UP,
+                              [0xD0] KEY_DN,
+                              [0xC9] KEY_PGUP,
+                              [0xD1] KEY_PGDN,
+                              [0xCB] KEY_LF,
+                              [0xCD] KEY_RT,
+                              [0x97] KEY_HOME,
+                              [0xCF] KEY_END,
+                              [0xD2] KEY_INS,
+                              [0xD3] KEY_DEL};
 
+static uchar ctlmap[256] = {NO,
+                            NO,
+                            NO,
+                            NO,
+                            NO,
+                            NO,
+                            NO,
+                            NO,
+                            NO,
+                            NO,
+                            NO,
+                            NO,
+                            NO,
+                            NO,
+                            NO,
+                            NO,
+                            C('Q'),
+                            C('W'),
+                            C('E'),
+                            C('R'),
+                            C('T'),
+                            C('Y'),
+                            C('U'),
+                            C('I'),
+                            C('O'),
+                            C('P'),
+                            NO,
+                            NO,
+                            '\r',
+                            NO,
+                            C('A'),
+                            C('S'),
+                            C('D'),
+                            C('F'),
+                            C('G'),
+                            C('H'),
+                            C('J'),
+                            C('K'),
+                            C('L'),
+                            NO,
+                            NO,
+                            NO,
+                            NO,
+                            C('\\'),
+                            C('Z'),
+                            C('X'),
+                            C('C'),
+                            C('V'),
+                            C('B'),
+                            C('N'),
+                            C('M'),
+                            NO,
+                            NO,
+                            C('/'),
+                            NO,
+                            NO,
+                            [0x9C] '\r',   // KP_Enter
+                            [0xB5] C('/'), // KP_Div
+                            [0xC8] KEY_UP,
+                            [0xD0] KEY_DN,
+                            [0xC9] KEY_PGUP,
+                            [0xD1] KEY_PGDN,
+                            [0xCB] KEY_LF,
+                            [0xCD] KEY_RT,
+                            [0x97] KEY_HOME,
+                            [0xCF] KEY_END,
+                            [0xD2] KEY_INS,
+                            [0xD3] KEY_DEL};
diff --git a/kill.c b/kill.c
index 364f6af..9ad1972 100644
--- a/kill.c
+++ b/kill.c
@@ -2,16 +2,14 @@
 #include "stat.h"
 #include "user.h"
 
-int
-main(int argc, char **argv)
-{
+int main(int argc, char **argv) {
   int i;
 
-  if(argc < 2){
+  if (argc < 2) {
     printf(2, "usage: kill pid...\n");
     exit();
   }
-  for(i=1; i<argc; i++)
+  for (i = 1; i < argc; i++)
     kill(atoi(argv[i]));
   exit();
 }
diff --git a/lapic.c b/lapic.c
index b22bbd7..50b1a68 100644
--- a/lapic.c
+++ b/lapic.c
@@ -11,50 +11,46 @@
 #include "x86.h"
 
 // Local APIC registers, divided by 4 for use as uint[] indices.
-#define ID      (0x0020/4)   // ID
-#define VER     (0x0030/4)   // Version
-#define TPR     (0x0080/4)   // Task Priority
-#define EOI     (0x00B0/4)   // EOI
-#define SVR     (0x00F0/4)   // Spurious Interrupt Vector
-  #define ENABLE     0x00000100   // Unit Enable
-#define ESR     (0x0280/4)   // Error Status
-#define ICRLO   (0x0300/4)   // Interrupt Command
-  #define INIT       0x00000500   // INIT/RESET
-  #define STARTUP    0x00000600   // Startup IPI
-  #define DELIVS     0x00001000   // Delivery status
-  #define ASSERT     0x00004000   // Assert interrupt (vs deassert)
-  #define DEASSERT   0x00000000
-  #define LEVEL      0x00008000   // Level triggered
-  #define BCAST      0x00080000   // Send to all APICs, including self.
-  #define BUSY       0x00001000
-  #define FIXED      0x00000000
-#define ICRHI   (0x0310/4)   // Interrupt Command [63:32]
-#define TIMER   (0x0320/4)   // Local Vector Table 0 (TIMER)
-  #define X1         0x0000000B   // divide counts by 1
-  #define PERIODIC   0x00020000   // Periodic
-#define PCINT   (0x0340/4)   // Performance Counter LVT
-#define LINT0   (0x0350/4)   // Local Vector Table 1 (LINT0)
-#define LINT1   (0x0360/4)   // Local Vector Table 2 (LINT1)
-#define ERROR   (0x0370/4)   // Local Vector Table 3 (ERROR)
-  #define MASKED     0x00010000   // Interrupt masked
-#define TICR    (0x0380/4)   // Timer Initial Count
-#define TCCR    (0x0390/4)   // Timer Current Count
-#define TDCR    (0x03E0/4)   // Timer Divide Configuration
-
-volatile uint *lapic;  // Initialized in mp.c
-
-//PAGEBREAK!
-static void
-lapicw(int index, int value)
-{
+#define ID (0x0020 / 4)    // ID
+#define VER (0x0030 / 4)   // Version
+#define TPR (0x0080 / 4)   // Task Priority
+#define EOI (0x00B0 / 4)   // EOI
+#define SVR (0x00F0 / 4)   // Spurious Interrupt Vector
+#define ENABLE 0x00000100  // Unit Enable
+#define ESR (0x0280 / 4)   // Error Status
+#define ICRLO (0x0300 / 4) // Interrupt Command
+#define INIT 0x00000500    // INIT/RESET
+#define STARTUP 0x00000600 // Startup IPI
+#define DELIVS 0x00001000  // Delivery status
+#define ASSERT 0x00004000  // Assert interrupt (vs deassert)
+#define DEASSERT 0x00000000
+#define LEVEL 0x00008000 // Level triggered
+#define BCAST 0x00080000 // Send to all APICs, including self.
+#define BUSY 0x00001000
+#define FIXED 0x00000000
+#define ICRHI (0x0310 / 4)  // Interrupt Command [63:32]
+#define TIMER (0x0320 / 4)  // Local Vector Table 0 (TIMER)
+#define X1 0x0000000B       // divide counts by 1
+#define PERIODIC 0x00020000 // Periodic
+#define PCINT (0x0340 / 4)  // Performance Counter LVT
+#define LINT0 (0x0350 / 4)  // Local Vector Table 1 (LINT0)
+#define LINT1 (0x0360 / 4)  // Local Vector Table 2 (LINT1)
+#define ERROR (0x0370 / 4)  // Local Vector Table 3 (ERROR)
+#define MASKED 0x00010000   // Interrupt masked
+#define TICR (0x0380 / 4)   // Timer Initial Count
+#define TCCR (0x0390 / 4)   // Timer Current Count
+#define TDCR (0x03E0 / 4)   // Timer Divide Configuration
+
+volatile uint *lapic; // Initialized in mp.c
+
+// PAGEBREAK!
+static void lapicw(int index, int value) {
   lapic[index] = value;
-  lapic[ID];  // wait for write to finish, by reading
+  lapic[ID]; // wait for write to finish, by reading
 }
 
-void
-lapicinit(void)
-{
-  if(!lapic)
+void lapicinit(void) {
+  if (!lapic)
     return;
 
   // Enable local APIC; set spurious interrupt vector.
@@ -74,7 +70,7 @@ lapicinit(void)
 
   // Disable performance counter overflow interrupts
   // on machines that provide that interrupt entry.
-  if(((lapic[VER]>>16) & 0xFF) >= 4)
+  if (((lapic[VER] >> 16) & 0xFF) >= 4)
     lapicw(PCINT, MASKED);
 
   // Map error interrupt to IRQ_ERROR.
@@ -90,111 +86,96 @@ lapicinit(void)
   // Send an Init Level De-Assert to synchronise arbitration ID's.
   lapicw(ICRHI, 0);
   lapicw(ICRLO, BCAST | INIT | LEVEL);
-  while(lapic[ICRLO] & DELIVS)
+  while (lapic[ICRLO] & DELIVS)
     ;
 
   // Enable interrupts on the APIC (but not on the processor).
   lapicw(TPR, 0);
 }
 
-int
-lapicid(void)
-{
+int lapicid(void) {
   if (!lapic)
     return 0;
   return lapic[ID] >> 24;
 }
 
 // Acknowledge interrupt.
-void
-lapiceoi(void)
-{
-  if(lapic)
+void lapiceoi(void) {
+  if (lapic)
     lapicw(EOI, 0);
 }
 
 // Spin for a given number of microseconds.
 // On real hardware would want to tune this dynamically.
-void
-microdelay(int us)
-{
-}
+void microdelay(int us) {}
 
-#define CMOS_PORT    0x70
-#define CMOS_RETURN  0x71
+#define CMOS_PORT 0x70
+#define CMOS_RETURN 0x71
 
 // Start additional processor running entry code at addr.
 // See Appendix B of MultiProcessor Specification.
-void
-lapicstartap(uchar apicid, uint addr)
-{
+void lapicstartap(uchar apicid, uint addr) {
   int i;
   ushort *wrv;
 
   // "The BSP must initialize CMOS shutdown code to 0AH
   // and the warm reset vector (DWORD based at 40:67) to point at
   // the AP startup code prior to the [universal startup algorithm]."
-  outb(CMOS_PORT, 0xF);  // offset 0xF is shutdown code
-  outb(CMOS_PORT+1, 0x0A);
-  wrv = (ushort*)P2V((0x40<<4 | 0x67));  // Warm reset vector
+  outb(CMOS_PORT, 0xF); // offset 0xF is shutdown code
+  outb(CMOS_PORT + 1, 0x0A);
+  wrv = (ushort *)P2V((0x40 << 4 | 0x67)); // Warm reset vector
   wrv[0] = 0;
   wrv[1] = addr >> 4;
 
   // "Universal startup algorithm."
   // Send INIT (level-triggered) interrupt to reset other CPU.
-  lapicw(ICRHI, apicid<<24);
+  lapicw(ICRHI, apicid << 24);
   lapicw(ICRLO, INIT | LEVEL | ASSERT);
   microdelay(200);
   lapicw(ICRLO, INIT | LEVEL);
-  microdelay(100);    // should be 10ms, but too slow in Bochs!
+  microdelay(100); // should be 10ms, but too slow in Bochs!
 
   // Send startup IPI (twice!) to enter code.
   // Regular hardware is supposed to only accept a STARTUP
   // when it is in the halted state due to an INIT.  So the second
   // should be ignored, but it is part of the official Intel algorithm.
   // Bochs complains about the second one.  Too bad for Bochs.
-  for(i = 0; i < 2; i++){
-    lapicw(ICRHI, apicid<<24);
-    lapicw(ICRLO, STARTUP | (addr>>12));
+  for (i = 0; i < 2; i++) {
+    lapicw(ICRHI, apicid << 24);
+    lapicw(ICRLO, STARTUP | (addr >> 12));
     microdelay(200);
   }
 }
 
-#define CMOS_STATA   0x0a
-#define CMOS_STATB   0x0b
-#define CMOS_UIP    (1 << 7)        // RTC update in progress
-
-#define SECS    0x00
-#define MINS    0x02
-#define HOURS   0x04
-#define DAY     0x07
-#define MONTH   0x08
-#define YEAR    0x09
-
-static uint
-cmos_read(uint reg)
-{
-  outb(CMOS_PORT,  reg);
+#define CMOS_STATA 0x0a
+#define CMOS_STATB 0x0b
+#define CMOS_UIP (1 << 7) // RTC update in progress
+
+#define SECS 0x00
+#define MINS 0x02
+#define HOURS 0x04
+#define DAY 0x07
+#define MONTH 0x08
+#define YEAR 0x09
+
+static uint cmos_read(uint reg) {
+  outb(CMOS_PORT, reg);
   microdelay(200);
 
   return inb(CMOS_RETURN);
 }
 
-static void
-fill_rtcdate(struct rtcdate *r)
-{
+static void fill_rtcdate(struct rtcdate *r) {
   r->second = cmos_read(SECS);
   r->minute = cmos_read(MINS);
-  r->hour   = cmos_read(HOURS);
-  r->day    = cmos_read(DAY);
-  r->month  = cmos_read(MONTH);
-  r->year   = cmos_read(YEAR);
+  r->hour = cmos_read(HOURS);
+  r->day = cmos_read(DAY);
+  r->month = cmos_read(MONTH);
+  r->year = cmos_read(YEAR);
 }
 
 // qemu seems to use 24-hour GWT and the values are BCD encoded
-void
-cmostime(struct rtcdate *r)
-{
+void cmostime(struct rtcdate *r) {
   struct rtcdate t1, t2;
   int sb, bcd;
 
@@ -203,25 +184,25 @@ cmostime(struct rtcdate *r)
   bcd = (sb & (1 << 2)) == 0;
 
   // make sure CMOS doesn't modify time while we read it
-  for(;;) {
+  for (;;) {
     fill_rtcdate(&t1);
-    if(cmos_read(CMOS_STATA) & CMOS_UIP)
-        continue;
+    if (cmos_read(CMOS_STATA) & CMOS_UIP)
+      continue;
     fill_rtcdate(&t2);
-    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
+    if (memcmp(&t1, &t2, sizeof(t1)) == 0)
       break;
   }
 
   // convert
-  if(bcd) {
-#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
+  if (bcd) {
+#define CONV(x) (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
     CONV(second);
     CONV(minute);
-    CONV(hour  );
-    CONV(day   );
-    CONV(month );
-    CONV(year  );
-#undef     CONV
+    CONV(hour);
+    CONV(day);
+    CONV(month);
+    CONV(year);
+#undef CONV
   }
 
   *r = t1;
diff --git a/ln.c b/ln.c
index cf8a64e..75703a2 100644
--- a/ln.c
+++ b/ln.c
@@ -2,14 +2,12 @@
 #include "stat.h"
 #include "user.h"
 
-int
-main(int argc, char *argv[])
-{
-  if(argc != 3){
+int main(int argc, char *argv[]) {
+  if (argc != 3) {
     printf(2, "Usage: ln old new\n");
     exit();
   }
-  if(link(argv[1], argv[2]) < 0)
+  if (link(argv[1], argv[2]) < 0)
     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
   exit();
 }
diff --git a/log.c b/log.c
index a64c0f6..5febc37 100644
--- a/log.c
+++ b/log.c
@@ -50,9 +50,7 @@ struct log log;
 static void recover_from_log(void);
 static void commit();
 
-void
-initlog(int dev)
-{
+void initlog(int dev) {
   if (sizeof(struct logheader) >= BSIZE)
     panic("initlog: too big logheader");
 
@@ -66,27 +64,23 @@ initlog(int dev)
 }
 
 // Copy committed blocks from log to their home location
-static void
-install_trans(void)
-{
+static void install_trans(void) {
   int tail;
 
   for (tail = 0; tail < log.lh.n; tail++) {
-    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
-    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
-    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
-    bwrite(dbuf);  // write dst to disk
+    struct buf *lbuf = bread(log.dev, log.start + tail + 1); // read log block
+    struct buf *dbuf = bread(log.dev, log.lh.block[tail]);   // read dst
+    memmove(dbuf->data, lbuf->data, BSIZE); // copy block to dst
+    bwrite(dbuf);                           // write dst to disk
     brelse(lbuf);
     brelse(dbuf);
   }
 }
 
 // Read the log header from disk into the in-memory log header
-static void
-read_head(void)
-{
+static void read_head(void) {
   struct buf *buf = bread(log.dev, log.start);
-  struct logheader *lh = (struct logheader *) (buf->data);
+  struct logheader *lh = (struct logheader *)(buf->data);
   int i;
   log.lh.n = lh->n;
   for (i = 0; i < log.lh.n; i++) {
@@ -98,11 +92,9 @@ read_head(void)
 // Write in-memory log header to disk.
 // This is the true point at which the
 // current transaction commits.
-static void
-write_head(void)
-{
+static void write_head(void) {
   struct buf *buf = bread(log.dev, log.start);
-  struct logheader *hb = (struct logheader *) (buf->data);
+  struct logheader *hb = (struct logheader *)(buf->data);
   int i;
   hb->n = log.lh.n;
   for (i = 0; i < log.lh.n; i++) {
@@ -112,9 +104,7 @@ write_head(void)
   brelse(buf);
 }
 
-static void
-recover_from_log(void)
-{
+static void recover_from_log(void) {
   read_head();
   install_trans(); // if committed, copy from log to disk
   log.lh.n = 0;
@@ -122,14 +112,12 @@ recover_from_log(void)
 }
 
 // called at the start of each FS system call.
-void
-begin_op(void)
-{
+void begin_op(void) {
   acquire(&log.lock);
-  while(1){
-    if(log.committing){
+  while (1) {
+    if (log.committing) {
       sleep(&log, &log.lock);
-    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
+    } else if (log.lh.n + (log.outstanding + 1) * MAXOPBLOCKS > LOGSIZE) {
       // this op might exhaust log space; wait for commit.
       sleep(&log, &log.lock);
     } else {
@@ -142,16 +130,14 @@ begin_op(void)
 
 // called at the end of each FS system call.
 // commits if this was the last outstanding operation.
-void
-end_op(void)
-{
+void end_op(void) {
   int do_commit = 0;
 
   acquire(&log.lock);
   log.outstanding -= 1;
-  if(log.committing)
+  if (log.committing)
     panic("log.committing");
-  if(log.outstanding == 0){
+  if (log.outstanding == 0) {
     do_commit = 1;
     log.committing = 1;
   } else {
@@ -162,7 +148,7 @@ end_op(void)
   }
   release(&log.lock);
 
-  if(do_commit){
+  if (do_commit) {
     // call commit w/o holding locks, since not allowed
     // to sleep with locks.
     commit();
@@ -174,30 +160,26 @@ end_op(void)
 }
 
 // Copy modified blocks from cache to log.
-static void
-write_log(void)
-{
+static void write_log(void) {
   int tail;
 
   for (tail = 0; tail < log.lh.n; tail++) {
-    struct buf *to = bread(log.dev, log.start+tail+1); // log block
+    struct buf *to = bread(log.dev, log.start + tail + 1); // log block
     struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
     memmove(to->data, from->data, BSIZE);
-    bwrite(to);  // write the log
+    bwrite(to); // write the log
     brelse(from);
     brelse(to);
   }
 }
 
-static void
-commit()
-{
+static void commit() {
   if (log.lh.n > 0) {
     write_log();     // Write modified blocks from cache to log
     write_head();    // Write header to disk -- the real commit
     install_trans(); // Now install writes to home locations
     log.lh.n = 0;
-    write_head();    // Erase the transaction from the log
+    write_head(); // Erase the transaction from the log
   }
 }
 
@@ -210,9 +192,7 @@ commit()
 //   modify bp->data[]
 //   log_write(bp)
 //   brelse(bp)
-void
-log_write(struct buf *b)
-{
+void log_write(struct buf *b) {
   int i;
 
   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
@@ -222,7 +202,7 @@ log_write(struct buf *b)
 
   acquire(&log.lock);
   for (i = 0; i < log.lh.n; i++) {
-    if (log.lh.block[i] == b->blockno)   // log absorbtion
+    if (log.lh.block[i] == b->blockno) // log absorbtion
       break;
   }
   log.lh.block[i] = b->blockno;
@@ -231,4 +211,3 @@ log_write(struct buf *b)
   b->flags |= B_DIRTY; // prevent eviction
   release(&log.lock);
 }
-
diff --git a/ls.c b/ls.c
index 2862913..fe87ccc 100644
--- a/ls.c
+++ b/ls.c
@@ -3,63 +3,59 @@
 #include "user.h"
 #include "fs.h"
 
-char*
-fmtname(char *path)
-{
-  static char buf[DIRSIZ+1];
+char *fmtname(char *path) {
+  static char buf[DIRSIZ + 1];
   char *p;
 
   // Find first character after last slash.
-  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+  for (p = path + strlen(path); p >= path && *p != '/'; p--)
     ;
   p++;
 
   // Return blank-padded name.
-  if(strlen(p) >= DIRSIZ)
+  if (strlen(p) >= DIRSIZ)
     return p;
   memmove(buf, p, strlen(p));
-  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+  memset(buf + strlen(p), ' ', DIRSIZ - strlen(p));
   return buf;
 }
 
-void
-ls(char *path)
-{
+void ls(char *path) {
   char buf[512], *p;
   int fd;
   struct dirent de;
   struct stat st;
 
-  if((fd = open(path, 0)) < 0){
+  if ((fd = open(path, 0)) < 0) {
     printf(2, "ls: cannot open %s\n", path);
     return;
   }
 
-  if(fstat(fd, &st) < 0){
+  if (fstat(fd, &st) < 0) {
     printf(2, "ls: cannot stat %s\n", path);
     close(fd);
     return;
   }
 
-  switch(st.type){
+  switch (st.type) {
   case T_FILE:
     printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
     break;
 
   case T_DIR:
-    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+    if (strlen(path) + 1 + DIRSIZ + 1 > sizeof buf) {
       printf(1, "ls: path too long\n");
       break;
     }
     strcpy(buf, path);
-    p = buf+strlen(buf);
+    p = buf + strlen(buf);
     *p++ = '/';
-    while(read(fd, &de, sizeof(de)) == sizeof(de)){
-      if(de.inum == 0)
+    while (read(fd, &de, sizeof(de)) == sizeof(de)) {
+      if (de.inum == 0)
         continue;
       memmove(p, de.name, DIRSIZ);
       p[DIRSIZ] = 0;
-      if(stat(buf, &st) < 0){
+      if (stat(buf, &st) < 0) {
         printf(1, "ls: cannot stat %s\n", buf);
         continue;
       }
@@ -70,16 +66,14 @@ ls(char *path)
   close(fd);
 }
 
-int
-main(int argc, char *argv[])
-{
+int main(int argc, char *argv[]) {
   int i;
 
-  if(argc < 2){
+  if (argc < 2) {
     ls(".");
     exit();
   }
-  for(i=1; i<argc; i++)
+  for (i = 1; i < argc; i++)
     ls(argv[i]);
   exit();
 }
diff --git a/main.c b/main.c
index 20f2c2f..abd2dfe 100644
--- a/main.c
+++ b/main.c
@@ -7,40 +7,36 @@
 #include "x86.h"
 
 static void startothers(void);
-static void mpmain(void)  __attribute__((noreturn));
+static void mpmain(void) __attribute__((noreturn));
 extern pde_t *kpgdir;
 extern char end[]; // first address after kernel loaded from ELF file
 
 // Bootstrap processor starts running C code here.
 // Allocate a real stack and switch to it, first
 // doing some setup required for memory allocator to work.
-int
-main(void)
-{
-  kinit1(end, P2V(4*1024*1024)); // phys page allocator
-  kvmalloc();      // kernel page table, after this, entrypgdir will expire
-  mpinit();        // detect other processors
-  lapicinit();     // interrupt controller
-  seginit();       // segment descriptors
-  picinit();       // disable pic
-  ioapicinit();    // another interrupt controller
-  consoleinit();   // console hardware
-  uartinit();      // serial port
-  pinit();         // process table
-  tvinit();        // trap vectors
-  binit();         // buffer cache
-  fileinit();      // file table
-  ideinit();       // disk 
-  startothers();   // start other processors
-  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
-  userinit();      // first user process
-  mpmain();        // finish this processor's setup
+int main(void) {
+  kinit1(end, P2V(4 * 1024 * 1024)); // phys page allocator
+  kvmalloc();    // kernel page table, after this, entrypgdir will expire
+  mpinit();      // detect other processors
+  lapicinit();   // interrupt controller
+  seginit();     // segment descriptors
+  picinit();     // disable pic
+  ioapicinit();  // another interrupt controller
+  consoleinit(); // console hardware
+  uartinit();    // serial port
+  pinit();       // process table
+  tvinit();      // trap vectors
+  binit();       // buffer cache
+  fileinit();    // file table
+  ideinit();     // disk
+  startothers(); // start other processors
+  kinit2(P2V(4 * 1024 * 1024), P2V(PHYSTOP)); // must come after startothers()
+  userinit();                                 // first user process
+  mpmain();                                   // finish this processor's setup
 }
 
 // Other CPUs jump here from entryother.S.
-static void
-mpenter(void)
-{
+static void mpenter(void) {
   switchkvm();
   seginit();
   lapicinit();
@@ -48,21 +44,17 @@ mpenter(void)
 }
 
 // Common CPU setup code.
-static void
-mpmain(void)
-{
+static void mpmain(void) {
   cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
-  idtinit();       // load idt register
+  idtinit();                    // load idt register
   xchg(&(mycpu()->started), 1); // tell startothers() we're up
-  scheduler();     // start running processes
+  scheduler();                  // start running processes
 }
 
-pde_t entrypgdir[];  // For entry.S
+pde_t entrypgdir[]; // For entry.S
 
 // Start the non-boot (AP) processors.
-static void
-startothers(void)
-{
+static void startothers(void) {
   extern uchar _binary_entryother_start[], _binary_entryother_size[];
   uchar *code;
   struct cpu *c;
@@ -74,22 +66,22 @@ startothers(void)
   code = P2V(0x7000);
   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
 
-  for(c = cpus; c < cpus+ncpu; c++){
-    if(c == mycpu())  // We've started already.
+  for (c = cpus; c < cpus + ncpu; c++) {
+    if (c == mycpu()) // We've started already.
       continue;
 
     // Tell entryother.S what stack to use, where to enter, and what
     // pgdir to use. We cannot use kpgdir yet, because the AP processor
     // is running in low  memory, so we use entrypgdir for the APs too.
     stack = kalloc();
-    *(void**)(code-4) = stack + KSTACKSIZE;
-    *(void(**)(void))(code-8) = mpenter;
-    *(int**)(code-12) = (void *) V2P(entrypgdir);
+    *(void **)(code - 4) = stack + KSTACKSIZE;
+    *(void (**)(void))(code - 8) = mpenter;
+    *(int **)(code - 12) = (void *)V2P(entrypgdir);
 
     lapicstartap(c->apicid, V2P(code));
 
     // wait for cpu to finish mpmain()
-    while(c->started == 0)
+    while (c->started == 0)
       ;
   }
 }
@@ -99,23 +91,22 @@ startothers(void)
 // hence the __aligned__ attribute.
 // PTE_PS in a page directory entry enables 4Mbyte pages.
 
-// When PTE_PS is enabled, the pgdir entries below (entrypgdir[0] and entrypgdir[512])
-// directly point to a physical page(4MB), only 1 level addressing
-
-// if PTE_PS is clear, these entries point to a page table page (4K), in this case we
-// also need to setup page table separately, to have 2 levels addressing
-__attribute__((__aligned__(PGSIZE)))
-pde_t entrypgdir[NPDENTRIES] = {
-  // Map VA's [0, 4MB) to PA's [0, 4MB)
-  [0] = (0) | PTE_P | PTE_W | PTE_PS,
-  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
-  [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
+// When PTE_PS is enabled, the pgdir entries below (entrypgdir[0] and
+// entrypgdir[512]) directly point to a physical page(4MB), only 1 level
+// addressing
+
+// if PTE_PS is clear, these entries point to a page table page (4K), in this
+// case we also need to setup page table separately, to have 2 levels addressing
+__attribute__((__aligned__(PGSIZE))) pde_t entrypgdir[NPDENTRIES] = {
+    // Map VA's [0, 4MB) to PA's [0, 4MB)
+    [0] = (0) | PTE_P | PTE_W | PTE_PS,
+    // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
+    [KERNBASE >> PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
 };
 
-//PAGEBREAK!
+// PAGEBREAK!
 // Blank page.
-//PAGEBREAK!
+// PAGEBREAK!
 // Blank page.
-//PAGEBREAK!
+// PAGEBREAK!
 // Blank page.
-
diff --git a/memide.c b/memide.c
index ba267ac..73fb1a9 100644
--- a/memide.c
+++ b/memide.c
@@ -18,40 +18,34 @@ extern uchar _binary_fs_img_start[], _binary_fs_img_size[];
 static int disksize;
 static uchar *memdisk;
 
-void
-ideinit(void)
-{
+void ideinit(void) {
   memdisk = _binary_fs_img_start;
-  disksize = (uint)_binary_fs_img_size/BSIZE;
+  disksize = (uint)_binary_fs_img_size / BSIZE;
 }
 
 // Interrupt handler.
-void
-ideintr(void)
-{
+void ideintr(void) {
   // no-op
 }
 
 // Sync buf with disk.
 // If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
 // Else if B_VALID is not set, read buf from disk, set B_VALID.
-void
-iderw(struct buf *b)
-{
+void iderw(struct buf *b) {
   uchar *p;
 
-  if(!holdingsleep(&b->lock))
+  if (!holdingsleep(&b->lock))
     panic("iderw: buf not locked");
-  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+  if ((b->flags & (B_VALID | B_DIRTY)) == B_VALID)
     panic("iderw: nothing to do");
-  if(b->dev != 1)
+  if (b->dev != 1)
     panic("iderw: request not for disk 1");
-  if(b->blockno >= disksize)
+  if (b->blockno >= disksize)
     panic("iderw: block out of range");
 
-  p = memdisk + b->blockno*BSIZE;
+  p = memdisk + b->blockno * BSIZE;
 
-  if(b->flags & B_DIRTY){
+  if (b->flags & B_DIRTY) {
     b->flags &= ~B_DIRTY;
     memmove(p, b->data, BSIZE);
   } else
diff --git a/memlayout.h b/memlayout.h
index d1615f7..b05adb2 100644
--- a/memlayout.h
+++ b/memlayout.h
@@ -1,15 +1,15 @@
 // Memory layout
 
-#define EXTMEM  0x100000            // Start of extended memory
-#define PHYSTOP 0xE000000           // Top physical memory
-#define DEVSPACE 0xFE000000         // Other devices are at high addresses
+#define EXTMEM 0x100000     // Start of extended memory
+#define PHYSTOP 0xE000000   // Top physical memory
+#define DEVSPACE 0xFE000000 // Other devices are at high addresses
 
 // Key addresses for address space layout (see kmap in vm.c for layout)
-#define KERNBASE 0x80000000         // First kernel virtual address
-#define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
+#define KERNBASE 0x80000000          // First kernel virtual address
+#define KERNLINK (KERNBASE + EXTMEM) // Address where kernel is linked
 
-#define V2P(a) (((uint) (a)) - KERNBASE)
-#define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
+#define V2P(a) (((uint)(a)) - KERNBASE)
+#define P2V(a) ((void *)(((char *)(a)) + KERNBASE))
 
-#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
-#define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts
+#define V2P_WO(x) ((x)-KERNBASE)   // same as V2P, but without casts
+#define P2V_WO(x) ((x) + KERNBASE) // same as P2V, but without casts
diff --git a/mkdir.c b/mkdir.c
index 6e4c954..29b1198 100644
--- a/mkdir.c
+++ b/mkdir.c
@@ -2,18 +2,16 @@
 #include "stat.h"
 #include "user.h"
 
-int
-main(int argc, char *argv[])
-{
+int main(int argc, char *argv[]) {
   int i;
 
-  if(argc < 2){
+  if (argc < 2) {
     printf(2, "Usage: mkdir files...\n");
     exit();
   }
 
-  for(i = 1; i < argc; i++){
-    if(mkdir(argv[i]) < 0){
+  for (i = 1; i < argc; i++) {
+    if (mkdir(argv[i]) < 0) {
       printf(2, "mkdir: %s failed to create\n", argv[i]);
       break;
     }
diff --git a/mkfs.c b/mkfs.c
index 8e011a7..e850ff6 100644
--- a/mkfs.c
+++ b/mkfs.c
@@ -5,14 +5,19 @@
 #include <fcntl.h>
 #include <assert.h>
 
-#define stat xv6_stat  // avoid clash with host struct stat
+#define stat xv6_stat // avoid clash with host struct stat
 #include "types.h"
 #include "fs.h"
 #include "stat.h"
 #include "param.h"
 
 #ifndef static_assert
-#define static_assert(a, b) do { switch (0) case 0: case (a): ; } while (0)
+#define static_assert(a, b)                                                    \
+  do {                                                                         \
+    switch (0)                                                                 \
+    case 0:                                                                    \
+    case (a):;                                                                 \
+  } while (0)
 #endif
 
 #define NINODES 200
@@ -20,11 +25,11 @@
 // Disk layout:
 // [ boot block | sb block | log | inode blocks | free bit map | data blocks ]
 
-int nbitmap = FSSIZE/(BSIZE*8) + 1;
+int nbitmap = FSSIZE / (BSIZE * 8) + 1;
 int ninodeblocks = NINODES / IPB + 1;
 int nlog = LOGSIZE;
-int nmeta;    // Number of meta blocks (boot, sb, nlog, inode, bitmap)
-int nblocks;  // Number of data blocks
+int nmeta;   // Number of meta blocks (boot, sb, nlog, inode, bitmap)
+int nblocks; // Number of data blocks
 
 int fsfd;
 struct superblock sb;
@@ -32,31 +37,26 @@ char zeroes[BSIZE];
 uint freeinode = 1;
 uint freeblock;
 
-
 void balloc(int);
-void wsect(uint, void*);
-void winode(uint, struct dinode*);
+void wsect(uint, void *);
+void winode(uint, struct dinode *);
 void rinode(uint inum, struct dinode *ip);
 void rsect(uint sec, void *buf);
 uint ialloc(ushort type);
 void iappend(uint inum, void *p, int n);
 
 // convert to intel byte order
-ushort
-xshort(ushort x)
-{
+ushort xshort(ushort x) {
   ushort y;
-  uchar *a = (uchar*)&y;
+  uchar *a = (uchar *)&y;
   a[0] = x;
   a[1] = x >> 8;
   return y;
 }
 
-uint
-xint(uint x)
-{
+uint xint(uint x) {
   uint y;
-  uchar *a = (uchar*)&y;
+  uchar *a = (uchar *)&y;
   a[0] = x;
   a[1] = x >> 8;
   a[2] = x >> 16;
@@ -64,19 +64,16 @@ xint(uint x)
   return y;
 }
 
-int
-main(int argc, char *argv[])
-{
+int main(int argc, char *argv[]) {
   int i, cc, fd;
   uint rootino, inum, off;
   struct dirent de;
   char buf[BSIZE];
   struct dinode din;
 
-
   static_assert(sizeof(int) == 4, "Integers must be 4 bytes!");
 
-  if(argc < 2){
+  if (argc < 2) {
     fprintf(stderr, "Usage: mkfs fs.img files...\n");
     exit(1);
   }
@@ -84,8 +81,8 @@ main(int argc, char *argv[])
   assert((BSIZE % sizeof(struct dinode)) == 0);
   assert((BSIZE % sizeof(struct dirent)) == 0);
 
-  fsfd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0666);
-  if(fsfd < 0){
+  fsfd = open(argv[1], O_RDWR | O_CREAT | O_TRUNC, 0666);
+  if (fsfd < 0) {
     perror(argv[1]);
     exit(1);
   }
@@ -99,15 +96,16 @@ main(int argc, char *argv[])
   sb.ninodes = xint(NINODES);
   sb.nlog = xint(nlog);
   sb.logstart = xint(2);
-  sb.inodestart = xint(2+nlog);
-  sb.bmapstart = xint(2+nlog+ninodeblocks);
+  sb.inodestart = xint(2 + nlog);
+  sb.bmapstart = xint(2 + nlog + ninodeblocks);
 
-  printf("nmeta %d (boot, super, log blocks %u inode blocks %u, bitmap blocks %u) blocks %d total %d\n",
+  printf("nmeta %d (boot, super, log blocks %u inode blocks %u, bitmap blocks "
+         "%u) blocks %d total %d\n",
          nmeta, nlog, ninodeblocks, nbitmap, nblocks, FSSIZE);
 
-  freeblock = nmeta;     // the first free block that we can allocate
+  freeblock = nmeta; // the first free block that we can allocate
 
-  for(i = 0; i < FSSIZE; i++)
+  for (i = 0; i < FSSIZE; i++)
     wsect(i, zeroes);
 
   memset(buf, 0, sizeof(buf));
@@ -127,10 +125,10 @@ main(int argc, char *argv[])
   strcpy(de.name, "..");
   iappend(rootino, &de, sizeof(de));
 
-  for(i = 2; i < argc; i++){
+  for (i = 2; i < argc; i++) {
     assert(index(argv[i], '/') == 0);
 
-    if((fd = open(argv[i], 0)) < 0){
+    if ((fd = open(argv[i], 0)) < 0) {
       perror(argv[i]);
       exit(1);
     }
@@ -139,7 +137,7 @@ main(int argc, char *argv[])
     // The binaries are named _rm, _cat, etc. to keep the
     // build operating system from trying to execute them
     // in place of system binaries like rm and cat.
-    if(argv[i][0] == '_')
+    if (argv[i][0] == '_')
       ++argv[i];
 
     inum = ialloc(T_FILE);
@@ -149,7 +147,7 @@ main(int argc, char *argv[])
     strncpy(de.name, argv[i], DIRSIZ);
     iappend(rootino, &de, sizeof(de));
 
-    while((cc = read(fd, buf, sizeof(buf))) > 0)
+    while ((cc = read(fd, buf, sizeof(buf))) > 0)
       iappend(inum, buf, cc);
 
     close(fd);
@@ -158,7 +156,7 @@ main(int argc, char *argv[])
   // fix size of root inode dir
   rinode(rootino, &din);
   off = xint(din.size);
-  off = ((off/BSIZE) + 1) * BSIZE;
+  off = ((off / BSIZE) + 1) * BSIZE;
   din.size = xint(off);
   winode(rootino, &din);
 
@@ -167,62 +165,52 @@ main(int argc, char *argv[])
   exit(0);
 }
 
-void
-wsect(uint sec, void *buf)
-{
-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
+void wsect(uint sec, void *buf) {
+  if (lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE) {
     perror("lseek");
     exit(1);
   }
-  if(write(fsfd, buf, BSIZE) != BSIZE){
+  if (write(fsfd, buf, BSIZE) != BSIZE) {
     perror("write");
     exit(1);
   }
 }
 
-void
-winode(uint inum, struct dinode *ip)
-{
+void winode(uint inum, struct dinode *ip) {
   char buf[BSIZE];
   uint bn;
   struct dinode *dip;
 
   bn = IBLOCK(inum, sb);
   rsect(bn, buf);
-  dip = ((struct dinode*)buf) + (inum % IPB);
+  dip = ((struct dinode *)buf) + (inum % IPB);
   *dip = *ip;
   wsect(bn, buf);
 }
 
-void
-rinode(uint inum, struct dinode *ip)
-{
+void rinode(uint inum, struct dinode *ip) {
   char buf[BSIZE];
   uint bn;
   struct dinode *dip;
 
   bn = IBLOCK(inum, sb);
   rsect(bn, buf);
-  dip = ((struct dinode*)buf) + (inum % IPB);
+  dip = ((struct dinode *)buf) + (inum % IPB);
   *ip = *dip;
 }
 
-void
-rsect(uint sec, void *buf)
-{
-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
+void rsect(uint sec, void *buf) {
+  if (lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE) {
     perror("lseek");
     exit(1);
   }
-  if(read(fsfd, buf, BSIZE) != BSIZE){
+  if (read(fsfd, buf, BSIZE) != BSIZE) {
     perror("read");
     exit(1);
   }
 }
 
-uint
-ialloc(ushort type)
-{
+uint ialloc(ushort type) {
   uint inum = freeinode++;
   struct dinode din;
 
@@ -234,17 +222,15 @@ ialloc(ushort type)
   return inum;
 }
 
-void
-balloc(int used)
-{
+void balloc(int used) {
   uchar buf[BSIZE];
   int i;
 
   printf("balloc: first %d blocks have been allocated\n", used);
-  assert(used < BSIZE*8);
+  assert(used < BSIZE * 8);
   bzero(buf, BSIZE);
-  for(i = 0; i < used; i++){
-    buf[i/8] = buf[i/8] | (0x1 << (i%8));
+  for (i = 0; i < used; i++) {
+    buf[i / 8] = buf[i / 8] | (0x1 << (i % 8));
   }
   printf("balloc: write bitmap block at sector %d\n", sb.bmapstart);
   wsect(sb.bmapstart, buf);
@@ -252,10 +238,8 @@ balloc(int used)
 
 #define min(a, b) ((a) < (b) ? (a) : (b))
 
-void
-iappend(uint inum, void *xp, int n)
-{
-  char *p = (char*)xp;
+void iappend(uint inum, void *xp, int n) {
+  char *p = (char *)xp;
   uint fbn, off, n1;
   struct dinode din;
   char buf[BSIZE];
@@ -265,24 +249,24 @@ iappend(uint inum, void *xp, int n)
   rinode(inum, &din);
   off = xint(din.size);
   // printf("append inum %d at off %d sz %d\n", inum, off, n);
-  while(n > 0){
+  while (n > 0) {
     fbn = off / BSIZE;
     assert(fbn < MAXFILE);
-    if(fbn < NDIRECT){
-      if(xint(din.addrs[fbn]) == 0){
+    if (fbn < NDIRECT) {
+      if (xint(din.addrs[fbn]) == 0) {
         din.addrs[fbn] = xint(freeblock++);
       }
       x = xint(din.addrs[fbn]);
     } else {
-      if(xint(din.addrs[NDIRECT]) == 0){
+      if (xint(din.addrs[NDIRECT]) == 0) {
         din.addrs[NDIRECT] = xint(freeblock++);
       }
-      rsect(xint(din.addrs[NDIRECT]), (char*)indirect);
-      if(indirect[fbn - NDIRECT] == 0){
+      rsect(xint(din.addrs[NDIRECT]), (char *)indirect);
+      if (indirect[fbn - NDIRECT] == 0) {
         indirect[fbn - NDIRECT] = xint(freeblock++);
-        wsect(xint(din.addrs[NDIRECT]), (char*)indirect);
+        wsect(xint(din.addrs[NDIRECT]), (char *)indirect);
       }
-      x = xint(indirect[fbn-NDIRECT]);
+      x = xint(indirect[fbn - NDIRECT]);
     }
     n1 = min(n, (fbn + 1) * BSIZE - off);
     rsect(x, buf);
diff --git a/mmu.h b/mmu.h
index a82d8e2..d55ca9b 100644
--- a/mmu.h
+++ b/mmu.h
@@ -2,24 +2,24 @@
 // x86 memory management unit (MMU).
 
 // Eflags register
-#define FL_IF           0x00000200      // Interrupt Enable
+#define FL_IF 0x00000200 // Interrupt Enable
 
 // Control Register flags
-#define CR0_PE          0x00000001      // Protection Enable
-#define CR0_WP          0x00010000      // Write Protect
-#define CR0_PG          0x80000000      // Paging
+#define CR0_PE 0x00000001 // Protection Enable
+#define CR0_WP 0x00010000 // Write Protect
+#define CR0_PG 0x80000000 // Paging
 
-#define CR4_PSE         0x00000010      // Page size extension
+#define CR4_PSE 0x00000010 // Page size extension
 
 // various segment selectors.
-#define SEG_KCODE 1  // kernel code
-#define SEG_KDATA 2  // kernel data+stack
-#define SEG_UCODE 3  // user code
-#define SEG_UDATA 4  // user data+stack
-#define SEG_TSS   5  // this process's task state
+#define SEG_KCODE 1 // kernel code
+#define SEG_KDATA 2 // kernel data+stack
+#define SEG_UCODE 3 // user code
+#define SEG_UDATA 4 // user data+stack
+#define SEG_TSS 5   // this process's task state
 
 // cpu->gdt[NSEGS] holds the above segments.
-#define NSEGS     6
+#define NSEGS 6
 
 #ifndef __ASSEMBLER__
 // Segment Descriptor
@@ -40,27 +40,29 @@ struct segdesc {
 };
 
 // Normal segment
-#define SEG(type, base, lim, dpl) (struct segdesc)    \
-{ ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
-  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
-  (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
-#define SEG16(type, base, lim, dpl) (struct segdesc)  \
-{ (lim) & 0xffff, (uint)(base) & 0xffff,              \
-  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
-  (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
+#define SEG(type, base, lim, dpl)                                              \
+  (struct segdesc) {                                                           \
+    ((lim) >> 12) & 0xffff, (uint)(base)&0xffff, ((uint)(base) >> 16) & 0xff,  \
+        type, 1, dpl, 1, (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24     \
+  }
+#define SEG16(type, base, lim, dpl)                                            \
+  (struct segdesc) {                                                           \
+    (lim) & 0xffff, (uint)(base)&0xffff, ((uint)(base) >> 16) & 0xff, type, 1, \
+        dpl, 1, (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24              \
+  }
 #endif
 
-#define DPL_USER    0x3     // User DPL
+#define DPL_USER 0x3 // User DPL
 
 // Application segment type bits
-#define STA_X       0x8     // Executable segment
-#define STA_W       0x2     // Writeable (non-executable segments)
-#define STA_R       0x2     // Readable (executable segments)
+#define STA_X 0x8 // Executable segment
+#define STA_W 0x2 // Writeable (non-executable segments)
+#define STA_R 0x2 // Readable (executable segments)
 
 // System segment type bits
-#define STS_T32A    0x9     // Available 32-bit TSS
-#define STS_IG32    0xE     // 32-bit Interrupt Gate
-#define STS_TG32    0xF     // 32-bit Trap Gate
+#define STS_T32A 0x9 // Available 32-bit TSS
+#define STS_IG32 0xE // 32-bit Interrupt Gate
+#define STS_TG32 0xF // 32-bit Trap Gate
 
 // A virtual address 'la' has a three-part structure as follows:
 //
@@ -71,43 +73,43 @@ struct segdesc {
 //  \--- PDX(va) --/ \--- PTX(va) --/
 
 // page directory index
-#define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
+#define PDX(va) (((uint)(va) >> PDXSHIFT) & 0x3FF)
 
 // page table index
-#define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
+#define PTX(va) (((uint)(va) >> PTXSHIFT) & 0x3FF)
 
 // construct virtual address from indexes and offset
 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
 
 // Page directory and page table constants.
-#define NPDENTRIES      1024    // # directory entries per page directory
-#define NPTENTRIES      1024    // # PTEs per page table
-#define PGSIZE          4096    // bytes mapped by a page
+#define NPDENTRIES 1024 // # directory entries per page directory
+#define NPTENTRIES 1024 // # PTEs per page table
+#define PGSIZE 4096     // bytes mapped by a page
 
-#define PTXSHIFT        12      // offset of PTX in a linear address
-#define PDXSHIFT        22      // offset of PDX in a linear address
+#define PTXSHIFT 12 // offset of PTX in a linear address
+#define PDXSHIFT 22 // offset of PDX in a linear address
 
-#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
-#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
+#define PGROUNDUP(sz) (((sz) + PGSIZE - 1) & ~(PGSIZE - 1))
+#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE - 1))
 
 // Page table/directory entry flags.
-#define PTE_P           0x001   // Present
-#define PTE_W           0x002   // Writeable
-#define PTE_U           0x004   // User
-#define PTE_PS          0x080   // Page Size
+#define PTE_P 0x001  // Present
+#define PTE_W 0x002  // Writeable
+#define PTE_U 0x004  // User
+#define PTE_PS 0x080 // Page Size
 
 // Address in page table or page directory entry
-#define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
-#define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
+#define PTE_ADDR(pte) ((uint)(pte) & ~0xFFF)
+#define PTE_FLAGS(pte) ((uint)(pte)&0xFFF)
 
 #ifndef __ASSEMBLER__
 typedef uint pte_t;
 
 // Task state segment format
 struct taskstate {
-  uint link;         // Old ts selector
-  uint esp0;         // Stack pointers and segment selectors
-  ushort ss0;        //   after an increase in privilege level
+  uint link;  // Old ts selector
+  uint esp0;  // Stack pointers and segment selectors
+  ushort ss0; //   after an increase in privilege level
   ushort padding1;
   uint *esp1;
   ushort ss1;
@@ -115,10 +117,10 @@ struct taskstate {
   uint *esp2;
   ushort ss2;
   ushort padding3;
-  void *cr3;         // Page directory base
-  uint *eip;         // Saved state from last task switch
+  void *cr3; // Page directory base
+  uint *eip; // Saved state from last task switch
   uint eflags;
-  uint eax;          // More saved state (registers)
+  uint eax; // More saved state (registers)
   uint ecx;
   uint edx;
   uint ebx;
@@ -126,7 +128,7 @@ struct taskstate {
   uint *ebp;
   uint esi;
   uint edi;
-  ushort es;         // Even more saved state (segment selectors)
+  ushort es; // Even more saved state (segment selectors)
   ushort padding4;
   ushort cs;
   ushort padding5;
@@ -140,21 +142,21 @@ struct taskstate {
   ushort padding9;
   ushort ldt;
   ushort padding10;
-  ushort t;          // Trap on task switch
-  ushort iomb;       // I/O map base address
+  ushort t;    // Trap on task switch
+  ushort iomb; // I/O map base address
 };
 
 // Gate descriptors for interrupts and traps
 struct gatedesc {
-  uint off_15_0 : 16;   // low 16 bits of offset in segment
-  uint cs : 16;         // code segment selector
-  uint args : 5;        // # args, 0 for interrupt/trap gates
-  uint rsv1 : 3;        // reserved(should be zero I guess)
-  uint type : 4;        // type(STS_{IG32,TG32})
-  uint s : 1;           // must be 0 (system)
-  uint dpl : 2;         // descriptor(meaning new) privilege level
-  uint p : 1;           // Present
-  uint off_31_16 : 16;  // high bits of offset in segment
+  uint off_15_0 : 16;  // low 16 bits of offset in segment
+  uint cs : 16;        // code segment selector
+  uint args : 5;       // # args, 0 for interrupt/trap gates
+  uint rsv1 : 3;       // reserved(should be zero I guess)
+  uint type : 4;       // type(STS_{IG32,TG32})
+  uint s : 1;          // must be 0 (system)
+  uint dpl : 2;        // descriptor(meaning new) privilege level
+  uint p : 1;          // Present
+  uint off_31_16 : 16; // high bits of offset in segment
 };
 
 // Set up a normal interrupt/trap gate descriptor.
@@ -165,17 +167,17 @@ struct gatedesc {
 // - dpl: Descriptor Privilege Level -
 //        the privilege level required for software to invoke
 //        this interrupt/trap gate explicitly using an int instruction.
-#define SETGATE(gate, istrap, sel, off, d)                \
-{                                                         \
-  (gate).off_15_0 = (uint)(off) & 0xffff;                \
-  (gate).cs = (sel);                                      \
-  (gate).args = 0;                                        \
-  (gate).rsv1 = 0;                                        \
-  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
-  (gate).s = 0;                                           \
-  (gate).dpl = (d);                                       \
-  (gate).p = 1;                                           \
-  (gate).off_31_16 = (uint)(off) >> 16;                  \
-}
+#define SETGATE(gate, istrap, sel, off, d)                                     \
+  {                                                                            \
+    (gate).off_15_0 = (uint)(off)&0xffff;                                      \
+    (gate).cs = (sel);                                                         \
+    (gate).args = 0;                                                           \
+    (gate).rsv1 = 0;                                                           \
+    (gate).type = (istrap) ? STS_TG32 : STS_IG32;                              \
+    (gate).s = 0;                                                              \
+    (gate).dpl = (d);                                                          \
+    (gate).p = 1;                                                              \
+    (gate).off_31_16 = (uint)(off) >> 16;                                      \
+  }
 
 #endif
diff --git a/mp.c b/mp.c
index 79bb0ad..e0de8df 100644
--- a/mp.c
+++ b/mp.c
@@ -15,28 +15,24 @@ struct cpu cpus[NCPU];
 int ncpu;
 uchar ioapicid;
 
-static uchar
-sum(uchar *addr, int len)
-{
+static uchar sum(uchar *addr, int len) {
   int i, sum;
 
   sum = 0;
-  for(i=0; i<len; i++)
+  for (i = 0; i < len; i++)
     sum += addr[i];
   return sum;
 }
 
 // Look for an MP structure in the len bytes at addr.
-static struct mp*
-mpsearch1(uint a, int len)
-{
+static struct mp *mpsearch1(uint a, int len) {
   uchar *e, *p, *addr;
 
   addr = P2V(a);
-  e = addr+len;
-  for(p = addr; p < e; p += sizeof(struct mp))
-    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
-      return (struct mp*)p;
+  e = addr + len;
+  for (p = addr; p < e; p += sizeof(struct mp))
+    if (memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+      return (struct mp *)p;
   return 0;
 }
 
@@ -45,20 +41,18 @@ mpsearch1(uint a, int len)
 // 1) in the first KB of the EBDA;
 // 2) in the last KB of system base memory;
 // 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
-static struct mp*
-mpsearch(void)
-{
+static struct mp *mpsearch(void) {
   uchar *bda;
   uint p;
   struct mp *mp;
 
-  bda = (uchar *) P2V(0x400);
-  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
-    if((mp = mpsearch1(p, 1024)))
+  bda = (uchar *)P2V(0x400);
+  if ((p = ((bda[0x0F] << 8) | bda[0x0E]) << 4)) {
+    if ((mp = mpsearch1(p, 1024)))
       return mp;
   } else {
-    p = ((bda[0x14]<<8)|bda[0x13])*1024;
-    if((mp = mpsearch1(p-1024, 1024)))
+    p = ((bda[0x14] << 8) | bda[0x13]) * 1024;
+    if ((mp = mpsearch1(p - 1024, 1024)))
       return mp;
   }
   return mpsearch1(0xF0000, 0x10000);
@@ -69,28 +63,24 @@ mpsearch(void)
 // Check for correct signature, calculate the checksum and,
 // if correct, check the version.
 // To do: check extended table checksum.
-static struct mpconf*
-mpconfig(struct mp **pmp)
-{
+static struct mpconf *mpconfig(struct mp **pmp) {
   struct mpconf *conf;
   struct mp *mp;
 
-  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+  if ((mp = mpsearch()) == 0 || mp->physaddr == 0)
     return 0;
-  conf = (struct mpconf*) P2V((uint) mp->physaddr);
-  if(memcmp(conf, "PCMP", 4) != 0)
+  conf = (struct mpconf *)P2V((uint)mp->physaddr);
+  if (memcmp(conf, "PCMP", 4) != 0)
     return 0;
-  if(conf->version != 1 && conf->version != 4)
+  if (conf->version != 1 && conf->version != 4)
     return 0;
-  if(sum((uchar*)conf, conf->length) != 0)
+  if (sum((uchar *)conf, conf->length) != 0)
     return 0;
   *pmp = mp;
   return conf;
 }
 
-void
-mpinit(void)
-{
+void mpinit(void) {
   uchar *p, *e;
   int ismp;
   struct mp *mp;
@@ -98,22 +88,22 @@ mpinit(void)
   struct mpproc *proc;
   struct mpioapic *ioapic;
 
-  if((conf = mpconfig(&mp)) == 0)
+  if ((conf = mpconfig(&mp)) == 0)
     panic("Expect to run on an SMP");
   ismp = 1;
-  lapic = (uint*)conf->lapicaddr;
-  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
-    switch(*p){
+  lapic = (uint *)conf->lapicaddr;
+  for (p = (uchar *)(conf + 1), e = (uchar *)conf + conf->length; p < e;) {
+    switch (*p) {
     case MPPROC:
-      proc = (struct mpproc*)p;
-      if(ncpu < NCPU) {
-        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+      proc = (struct mpproc *)p;
+      if (ncpu < NCPU) {
+        cpus[ncpu].apicid = proc->apicid; // apicid may differ from ncpu
         ncpu++;
       }
       p += sizeof(struct mpproc);
       continue;
     case MPIOAPIC:
-      ioapic = (struct mpioapic*)p;
+      ioapic = (struct mpioapic *)p;
       ioapicid = ioapic->apicno;
       p += sizeof(struct mpioapic);
       continue;
@@ -127,13 +117,13 @@ mpinit(void)
       break;
     }
   }
-  if(!ismp)
+  if (!ismp)
     panic("Didn't find a suitable machine");
 
-  if(mp->imcrp){
+  if (mp->imcrp) {
     // Bochs doesn't support IMCR, so this doesn't run on Bochs.
     // But it would on real hardware.
-    outb(0x22, 0x70);   // Select IMCR
-    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
+    outb(0x22, 0x70);          // Select IMCR
+    outb(0x23, inb(0x23) | 1); // Mask external interrupts.
   }
 }
diff --git a/mp.h b/mp.h
index 4d17283..dc2aeb0 100644
--- a/mp.h
+++ b/mp.h
@@ -1,56 +1,56 @@
 // See MultiProcessor Specification Version 1.[14]
 
-struct mp {             // floating pointer
-  uchar signature[4];           // "_MP_"
-  void *physaddr;               // phys addr of MP config table
-  uchar length;                 // 1
-  uchar specrev;                // [14]
-  uchar checksum;               // all bytes must add up to 0
-  uchar type;                   // MP system config type
+struct mp {           // floating pointer
+  uchar signature[4]; // "_MP_"
+  void *physaddr;     // phys addr of MP config table
+  uchar length;       // 1
+  uchar specrev;      // [14]
+  uchar checksum;     // all bytes must add up to 0
+  uchar type;         // MP system config type
   uchar imcrp;
   uchar reserved[3];
 };
 
-struct mpconf {         // configuration table header
-  uchar signature[4];           // "PCMP"
-  ushort length;                // total table length
-  uchar version;                // [14]
-  uchar checksum;               // all bytes must add up to 0
-  uchar product[20];            // product id
-  uint *oemtable;               // OEM table pointer
-  ushort oemlength;             // OEM table length
-  ushort entry;                 // entry count
-  uint *lapicaddr;              // address of local APIC
-  ushort xlength;               // extended table length
-  uchar xchecksum;              // extended table checksum
+struct mpconf {       // configuration table header
+  uchar signature[4]; // "PCMP"
+  ushort length;      // total table length
+  uchar version;      // [14]
+  uchar checksum;     // all bytes must add up to 0
+  uchar product[20];  // product id
+  uint *oemtable;     // OEM table pointer
+  ushort oemlength;   // OEM table length
+  ushort entry;       // entry count
+  uint *lapicaddr;    // address of local APIC
+  ushort xlength;     // extended table length
+  uchar xchecksum;    // extended table checksum
   uchar reserved;
 };
 
-struct mpproc {         // processor table entry
-  uchar type;                   // entry type (0)
-  uchar apicid;                 // local APIC id
-  uchar version;                // local APIC verison
-  uchar flags;                  // CPU flags
-    #define MPBOOT 0x02           // This proc is the bootstrap processor.
-  uchar signature[4];           // CPU signature
-  uint feature;                 // feature flags from CPUID instruction
+struct mpproc {       // processor table entry
+  uchar type;         // entry type (0)
+  uchar apicid;       // local APIC id
+  uchar version;      // local APIC verison
+  uchar flags;        // CPU flags
+#define MPBOOT 0x02   // This proc is the bootstrap processor.
+  uchar signature[4]; // CPU signature
+  uint feature;       // feature flags from CPUID instruction
   uchar reserved[8];
 };
 
-struct mpioapic {       // I/O APIC table entry
-  uchar type;                   // entry type (2)
-  uchar apicno;                 // I/O APIC id
-  uchar version;                // I/O APIC version
-  uchar flags;                  // I/O APIC flags
-  uint *addr;                  // I/O APIC address
+struct mpioapic { // I/O APIC table entry
+  uchar type;     // entry type (2)
+  uchar apicno;   // I/O APIC id
+  uchar version;  // I/O APIC version
+  uchar flags;    // I/O APIC flags
+  uint *addr;     // I/O APIC address
 };
 
 // Table entry types
-#define MPPROC    0x00  // One per processor
-#define MPBUS     0x01  // One per bus
-#define MPIOAPIC  0x02  // One per I/O APIC
-#define MPIOINTR  0x03  // One per bus interrupt source
-#define MPLINTR   0x04  // One per system interrupt source
+#define MPPROC 0x00   // One per processor
+#define MPBUS 0x01    // One per bus
+#define MPIOAPIC 0x02 // One per I/O APIC
+#define MPIOINTR 0x03 // One per bus interrupt source
+#define MPLINTR 0x04  // One per system interrupt source
 
-//PAGEBREAK!
+// PAGEBREAK!
 // Blank page.
diff --git a/param.h b/param.h
index a7e90ef..5cade8f 100644
--- a/param.h
+++ b/param.h
@@ -1,14 +1,13 @@
-#define NPROC        64  // maximum number of processes
-#define KSTACKSIZE 4096  // size of per-process kernel stack
-#define NCPU          8  // maximum number of CPUs
-#define NOFILE       16  // open files per process
-#define NFILE       100  // open files per system
-#define NINODE       50  // maximum number of active i-nodes
-#define NDEV         10  // maximum major device number
-#define ROOTDEV       1  // device number of file system root disk
-#define MAXARG       32  // max exec arguments
-#define MAXOPBLOCKS  10  // max # of blocks any FS op writes
-#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
-#define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
-#define FSSIZE       1000  // size of file system in blocks
-
+#define NPROC 64                  // maximum number of processes
+#define KSTACKSIZE 4096           // size of per-process kernel stack
+#define NCPU 8                    // maximum number of CPUs
+#define NOFILE 16                 // open files per process
+#define NFILE 100                 // open files per system
+#define NINODE 50                 // maximum number of active i-nodes
+#define NDEV 10                   // maximum major device number
+#define ROOTDEV 1                 // device number of file system root disk
+#define MAXARG 32                 // max exec arguments
+#define MAXOPBLOCKS 10            // max # of blocks any FS op writes
+#define LOGSIZE (MAXOPBLOCKS * 3) // max data blocks in on-disk log
+#define NBUF (MAXOPBLOCKS * 3)    // size of disk block cache
+#define FSSIZE 1000               // size of file system in blocks
diff --git a/picirq.c b/picirq.c
index e26957f..8e780f7 100644
--- a/picirq.c
+++ b/picirq.c
@@ -3,17 +3,15 @@
 #include "traps.h"
 
 // I/O Addresses of the two programmable interrupt controllers
-#define IO_PIC1         0x20    // Master (IRQs 0-7)
-#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
+#define IO_PIC1 0x20 // Master (IRQs 0-7)
+#define IO_PIC2 0xA0 // Slave (IRQs 8-15)
 
 // Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
-void
-picinit(void)
-{
+void picinit(void) {
   // mask all interrupts
-  outb(IO_PIC1+1, 0xFF);
-  outb(IO_PIC2+1, 0xFF);
+  outb(IO_PIC1 + 1, 0xFF);
+  outb(IO_PIC2 + 1, 0xFF);
 }
 
-//PAGEBREAK!
+// PAGEBREAK!
 // Blank page.
diff --git a/pipe.c b/pipe.c
index e9abe7f..fdc819e 100644
--- a/pipe.c
+++ b/pipe.c
@@ -13,22 +13,20 @@
 struct pipe {
   struct spinlock lock;
   char data[PIPESIZE];
-  uint nread;     // number of bytes read
-  uint nwrite;    // number of bytes written
-  int readopen;   // read fd is still open
-  int writeopen;  // write fd is still open
+  uint nread;    // number of bytes read
+  uint nwrite;   // number of bytes written
+  int readopen;  // read fd is still open
+  int writeopen; // write fd is still open
 };
 
-int
-pipealloc(struct file **f0, struct file **f1)
-{
+int pipealloc(struct file **f0, struct file **f1) {
   struct pipe *p;
 
   p = 0;
   *f0 = *f1 = 0;
-  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
+  if ((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
     goto bad;
-  if((p = (struct pipe*)kalloc()) == 0)
+  if ((p = (struct pipe *)kalloc()) == 0)
     goto bad;
   p->readopen = 1;
   p->writeopen = 1;
@@ -45,77 +43,71 @@ pipealloc(struct file **f0, struct file **f1)
   (*f1)->pipe = p;
   return 0;
 
-//PAGEBREAK: 20
- bad:
-  if(p)
-    kfree((char*)p);
-  if(*f0)
+  // PAGEBREAK: 20
+bad:
+  if (p)
+    kfree((char *)p);
+  if (*f0)
     fileclose(*f0);
-  if(*f1)
+  if (*f1)
     fileclose(*f1);
   return -1;
 }
 
-void
-pipeclose(struct pipe *p, int writable)
-{
+void pipeclose(struct pipe *p, int writable) {
   acquire(&p->lock);
-  if(writable){
+  if (writable) {
     p->writeopen = 0;
     wakeup(&p->nread);
   } else {
     p->readopen = 0;
     wakeup(&p->nwrite);
   }
-  if(p->readopen == 0 && p->writeopen == 0){
+  if (p->readopen == 0 && p->writeopen == 0) {
     release(&p->lock);
-    kfree((char*)p);
+    kfree((char *)p);
   } else
     release(&p->lock);
 }
 
-//PAGEBREAK: 40
-int
-pipewrite(struct pipe *p, char *addr, int n)
-{
+// PAGEBREAK: 40
+int pipewrite(struct pipe *p, char *addr, int n) {
   int i;
 
   acquire(&p->lock);
-  for(i = 0; i < n; i++){
-    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
-      if(p->readopen == 0 || myproc()->killed){
+  for (i = 0; i < n; i++) {
+    while (p->nwrite == p->nread + PIPESIZE) { // DOC: pipewrite-full
+      if (p->readopen == 0 || myproc()->killed) {
         release(&p->lock);
         return -1;
       }
       wakeup(&p->nread);
-      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+      sleep(&p->nwrite, &p->lock); // DOC: pipewrite-sleep
     }
     p->data[p->nwrite++ % PIPESIZE] = addr[i];
   }
-  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+  wakeup(&p->nread); // DOC: pipewrite-wakeup1
   release(&p->lock);
   return n;
 }
 
-int
-piperead(struct pipe *p, char *addr, int n)
-{
+int piperead(struct pipe *p, char *addr, int n) {
   int i;
 
   acquire(&p->lock);
-  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
-    if(myproc()->killed){
+  while (p->nread == p->nwrite && p->writeopen) { // DOC: pipe-empty
+    if (myproc()->killed) {
       release(&p->lock);
       return -1;
     }
-    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+    sleep(&p->nread, &p->lock); // DOC: piperead-sleep
   }
-  for(i = 0; i < n; i++){  //DOC: piperead-copy
-    if(p->nread == p->nwrite)
+  for (i = 0; i < n; i++) { // DOC: piperead-copy
+    if (p->nread == p->nwrite)
       break;
     addr[i] = p->data[p->nread++ % PIPESIZE];
   }
-  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+  wakeup(&p->nwrite); // DOC: piperead-wakeup
   release(&p->lock);
   return i;
 }
diff --git a/printf.c b/printf.c
index b3298aa..6dea768 100644
--- a/printf.c
+++ b/printf.c
@@ -2,22 +2,16 @@
 #include "stat.h"
 #include "user.h"
 
-static void
-putc(int fd, char c)
-{
-  write(fd, &c, 1);
-}
+static void putc(int fd, char c) { write(fd, &c, 1); }
 
-static void
-printint(int fd, int xx, int base, int sgn)
-{
+static void printint(int fd, int xx, int base, int sgn) {
   static char digits[] = "0123456789ABCDEF";
   char buf[16];
   int i, neg;
   uint x;
 
   neg = 0;
-  if(sgn && xx < 0){
+  if (sgn && xx < 0) {
     neg = 1;
     x = -xx;
   } else {
@@ -25,54 +19,52 @@ printint(int fd, int xx, int base, int sgn)
   }
 
   i = 0;
-  do{
+  do {
     buf[i++] = digits[x % base];
-  }while((x /= base) != 0);
-  if(neg)
+  } while ((x /= base) != 0);
+  if (neg)
     buf[i++] = '-';
 
-  while(--i >= 0)
+  while (--i >= 0)
     putc(fd, buf[i]);
 }
 
 // Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
+void printf(int fd, const char *fmt, ...) {
   char *s;
   int c, i, state;
   uint *ap;
 
   state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
+  ap = (uint *)(void *)&fmt + 1;
+  for (i = 0; fmt[i]; i++) {
     c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
+    if (state == 0) {
+      if (c == '%') {
         state = '%';
       } else {
         putc(fd, c);
       }
-    } else if(state == '%'){
-      if(c == 'd'){
+    } else if (state == '%') {
+      if (c == 'd') {
         printint(fd, *ap, 10, 1);
         ap++;
-      } else if(c == 'x' || c == 'p'){
+      } else if (c == 'x' || c == 'p') {
         printint(fd, *ap, 16, 0);
         ap++;
-      } else if(c == 's'){
-        s = (char*)*ap;
+      } else if (c == 's') {
+        s = (char *)*ap;
         ap++;
-        if(s == 0)
+        if (s == 0)
           s = "(null)";
-        while(*s != 0){
+        while (*s != 0) {
           putc(fd, *s);
           s++;
         }
-      } else if(c == 'c'){
+      } else if (c == 'c') {
         putc(fd, *ap);
         ap++;
-      } else if(c == '%'){
+      } else if (c == '%') {
         putc(fd, c);
       } else {
         // Unknown % sequence.  Print it to draw attention.
diff --git a/proc.c b/proc.c
index f0eada5..3ac1eb2 100644
--- a/proc.c
+++ b/proc.c
@@ -20,28 +20,19 @@ extern void trapret(void);
 
 static void wakeup1(void *chan);
 
-void
-pinit(void)
-{
-  initlock(&ptable.lock, "ptable");
-}
+void pinit(void) { initlock(&ptable.lock, "ptable"); }
 
 // Must be called with interrupts disabled
-int
-cpuid() {
-  return mycpu()-cpus;
-}
+int cpuid() { return mycpu() - cpus; }
 
 // Must be called with interrupts disabled to avoid the caller being
 // rescheduled between reading lapicid and running through the loop.
-struct cpu*
-mycpu(void)
-{
+struct cpu *mycpu(void) {
   int apicid, i;
-  
-  if(readeflags()&FL_IF)
+
+  if (readeflags() & FL_IF)
     panic("mycpu called with interrupts enabled\n");
-  
+
   apicid = lapicid();
   // APIC IDs are not guaranteed to be contiguous. Maybe we should have
   // a reverse map, or reserve a register to store &cpus[i].
@@ -54,8 +45,7 @@ mycpu(void)
 
 // Disable interrupts so that we are not rescheduled
 // while reading proc from the cpu structure
-struct proc*
-myproc(void) {
+struct proc *myproc(void) {
   struct cpu *c;
   struct proc *p;
   pushcli();
@@ -65,21 +55,19 @@ myproc(void) {
   return p;
 }
 
-//PAGEBREAK: 32
+// PAGEBREAK: 32
 // Look in the process table for an UNUSED proc.
 // If found, change state to EMBRYO and initialize
 // state required to run in the kernel.
 // Otherwise return 0.
-static struct proc*
-allocproc(void)
-{
+static struct proc *allocproc(void) {
   struct proc *p;
   char *sp;
 
   acquire(&ptable.lock);
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == UNUSED)
       goto found;
 
   release(&ptable.lock);
@@ -92,7 +80,7 @@ found:
   release(&ptable.lock);
 
   // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
+  if ((p->kstack = kalloc()) == 0) {
     p->state = UNUSED;
     return 0;
   }
@@ -100,35 +88,36 @@ found:
 
   // Leave room for trap frame.
   sp -= sizeof *p->tf;
-  p->tf = (struct trapframe*)sp;
+  p->tf = (struct trapframe *)sp;
 
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
-  *(uint*)sp = (uint)trapret;
+  *(uint *)sp = (uint)trapret;
 
   sp -= sizeof *p->context;
-  p->context = (struct context*)sp;
+  p->context = (struct context *)sp;
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
   return p;
 }
 
-//PAGEBREAK: 32
+// PAGEBREAK: 32
 // Set up first user process.
-void
-userinit(void)
-{
+void userinit(void) {
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
   p = allocproc();
-  
+
   initproc = p;
-  if((p->pgdir = setupkvm()) == 0)    // setup process's page table pages for context switch, mapping kernel content to address space
+  if ((p->pgdir = setupkvm()) ==
+      0) // setup process's page table pages for context switch, mapping kernel
+         // content to address space
     panic("userinit: out of memory?");
-  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);  // now mapping self's content
+  inituvm(p->pgdir, _binary_initcode_start,
+          (int)_binary_initcode_size); // now mapping self's content
   p->sz = PGSIZE;
   memset(p->tf, 0, sizeof(*p->tf));
   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
@@ -137,7 +126,8 @@ userinit(void)
   p->tf->ss = p->tf->ds;
   p->tf->eflags = FL_IF;
   p->tf->esp = PGSIZE; // User stack
-  p->tf->eip = 0;  // beginning of initcode.S, now virtual address (0 - 4095) mapped to physical address loaded of executable file
+  p->tf->eip = 0; // beginning of initcode.S, now virtual address (0 - 4095)
+                  // mapped to physical address loaded of executable file
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
@@ -177,20 +167,18 @@ userinit(void)
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
-int
-fork(void)
-{
+int fork(void) {
   int i, pid;
   struct proc *np;
   struct proc *curproc = myproc();
 
   // Allocate process.
-  if((np = allocproc()) == 0){
+  if ((np = allocproc()) == 0) {
     return -1;
   }
 
   // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+  if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
     kfree(np->kstack);
     np->kstack = 0;
     np->state = UNUSED;
@@ -203,8 +191,8 @@ fork(void)
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
-  for(i = 0; i < NOFILE; i++)
-    if(curproc->ofile[i])
+  for (i = 0; i < NOFILE; i++)
+    if (curproc->ofile[i])
       np->ofile[i] = filedup(curproc->ofile[i]);
   np->cwd = idup(curproc->cwd);
 
@@ -224,19 +212,17 @@ fork(void)
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
-void
-exit(void)
-{
+void exit(void) {
   struct proc *curproc = myproc();
   struct proc *p;
   int fd;
 
-  if(curproc == initproc)
+  if (curproc == initproc)
     panic("init exiting");
 
   // Close all open files.
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd]){
+  for (fd = 0; fd < NOFILE; fd++) {
+    if (curproc->ofile[fd]) {
       fileclose(curproc->ofile[fd]);
       curproc->ofile[fd] = 0;
     }
@@ -253,10 +239,10 @@ exit(void)
   wakeup1(curproc->parent);
 
   // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == curproc){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+    if (p->parent == curproc) {
       p->parent = initproc;
-      if(p->state == ZOMBIE)
+      if (p->state == ZOMBIE)
         wakeup1(initproc);
     }
   }
@@ -269,22 +255,20 @@ exit(void)
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
-int
-wait(void)
-{
+int wait(void) {
   struct proc *p;
   int havekids, pid;
   struct proc *curproc = myproc();
-  
+
   acquire(&ptable.lock);
-  for(;;){
+  for (;;) {
     // Scan through table looking for exited children.
     havekids = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != curproc)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+      if (p->parent != curproc)
         continue;
       havekids = 1;
-      if(p->state == ZOMBIE){
+      if (p->state == ZOMBIE) {
         // Found one.
         pid = p->pid;
         kfree(p->kstack);
@@ -301,17 +285,17 @@ wait(void)
     }
 
     // No point waiting if we don't have any children.
-    if(!havekids || curproc->killed){
+    if (!havekids || curproc->killed) {
       release(&ptable.lock);
       return -1;
     }
 
     // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+    sleep(curproc, &ptable.lock); // DOC: wait-sleep
   }
 }
 
-//PAGEBREAK: 42
+// PAGEBREAK: 42
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
 // Scheduler never returns.  It loops, doing:
@@ -319,28 +303,27 @@ wait(void)
 //  - swtch to start running that process
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
-void
-scheduler(void)
-{
+void scheduler(void) {
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
-  for(;;){
+
+  for (;;) {
     // Enable interrupts on this processor.
     sti();
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+      if (p->state != RUNNABLE)
         continue;
 
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
       c->proc = p;
-      switchuvm(p); // enter user space by setting %cr3 register to user space pgdir
+      switchuvm(
+          p); // enter user space by setting %cr3 register to user space pgdir
       p->state = RUNNING;
 
       swtch(&(c->scheduler), p->context);
@@ -351,7 +334,6 @@ scheduler(void)
       c->proc = 0;
     }
     release(&ptable.lock);
-
   }
 }
 
@@ -362,19 +344,17 @@ scheduler(void)
 // be proc->intena and proc->ncli, but that would
 // break in the few places where a lock is held but
 // there's no process.
-void
-sched(void)
-{
+void sched(void) {
   int intena;
   struct proc *p = myproc();
 
-  if(!holding(&ptable.lock))
+  if (!holding(&ptable.lock))
     panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
+  if (mycpu()->ncli != 1)
     panic("sched locks");
-  if(p->state == RUNNING)
+  if (p->state == RUNNING)
     panic("sched running");
-  if(readeflags()&FL_IF)
+  if (readeflags() & FL_IF)
     panic("sched interruptible");
   intena = mycpu()->intena;
   swtch(&p->context, mycpu()->scheduler);
@@ -382,10 +362,8 @@ sched(void)
 }
 
 // Give up the CPU for one scheduling round.
-void
-yield(void)
-{
-  acquire(&ptable.lock);  //DOC: yieldlock
+void yield(void) {
+  acquire(&ptable.lock); // DOC: yieldlock
   myproc()->state = RUNNABLE;
   sched();
   release(&ptable.lock);
@@ -393,9 +371,7 @@ yield(void)
 
 // A fork child's very first scheduling by scheduler()
 // will swtch here.  "Return" to user space.
-void
-forkret(void)
-{
+void forkret(void) {
   // after prologue: push %ebp; mov %esp, %ebp... hit return in GDB
   static int first = 1;
   // Still holding ptable.lock from scheduler.
@@ -415,15 +391,13 @@ forkret(void)
 
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
-void
-sleep(void *chan, struct spinlock *lk)
-{
+void sleep(void *chan, struct spinlock *lk) {
   struct proc *p = myproc();
-  
-  if(p == 0)
+
+  if (p == 0)
     panic("sleep");
 
-  if(lk == 0)
+  if (lk == 0)
     panic("sleep without lk");
 
   // Must acquire ptable.lock in order to
@@ -432,8 +406,8 @@ sleep(void *chan, struct spinlock *lk)
   // guaranteed that we won't miss any wakeup
   // (wakeup runs with ptable.lock locked),
   // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
+  if (lk != &ptable.lock) { // DOC: sleeplock0
+    acquire(&ptable.lock);  // DOC: sleeplock1
     release(lk);
   }
   // Go to sleep.
@@ -446,29 +420,25 @@ sleep(void *chan, struct spinlock *lk)
   p->chan = 0;
 
   // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
+  if (lk != &ptable.lock) { // DOC: sleeplock2
     release(&ptable.lock);
     acquire(lk);
   }
 }
 
-//PAGEBREAK!
+// PAGEBREAK!
 // Wake up all processes sleeping on chan.
 // The ptable lock must be held.
-static void
-wakeup1(void *chan)
-{
+static void wakeup1(void *chan) {
   struct proc *p;
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == SLEEPING && p->chan == chan)
       p->state = RUNNABLE;
 }
 
 // Wake up all processes sleeping on chan.
-void
-wakeup(void *chan)
-{
+void wakeup(void *chan) {
   acquire(&ptable.lock);
   wakeup1(chan);
   release(&ptable.lock);
@@ -477,17 +447,15 @@ wakeup(void *chan)
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
-int
-kill(int pid)
-{
+int kill(int pid) {
   struct proc *p;
 
   acquire(&ptable.lock);
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->pid == pid){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+    if (p->pid == pid) {
       p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
+      if (p->state == SLEEPING)
         p->state = RUNNABLE;
       release(&ptable.lock);
       return 0;
@@ -497,37 +465,30 @@ kill(int pid)
   return -1;
 }
 
-//PAGEBREAK: 36
+// PAGEBREAK: 36
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
-void
-procdump(void)
-{
+void procdump(void) {
   static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
+      [UNUSED] "unused",   [EMBRYO] "embryo",  [SLEEPING] "sleep ",
+      [RUNNABLE] "runble", [RUNNING] "run   ", [ZOMBIE] "zombie"};
   int i;
   struct proc *p;
   char *state;
   uint pc[10];
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+    if (p->state == UNUSED)
       continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+    if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
       state = states[p->state];
     else
       state = "???";
     cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
+    if (p->state == SLEEPING) {
+      getcallerpcs((uint *)p->context->ebp + 2, pc);
+      for (i = 0; i < 10 && pc[i] != 0; i++)
         cprintf(" %p", pc[i]);
     }
     cprintf("\n");
diff --git a/proc.h b/proc.h
index 1647114..62a0ed0 100644
--- a/proc.h
+++ b/proc.h
@@ -1,19 +1,19 @@
 // Per-CPU state
 struct cpu {
-  uchar apicid;                // Local APIC ID
-  struct context *scheduler;   // swtch() here to enter scheduler
-  struct taskstate ts;         // Used by x86 to find stack for interrupt
-  struct segdesc gdt[NSEGS];   // x86 global descriptor table
-  volatile uint started;       // Has the CPU started?
-  int ncli;                    // Depth of pushcli nesting.
-  int intena;                  // Were interrupts enabled before pushcli?
-  struct proc *proc;           // The process running on this cpu or null
+  uchar apicid;              // Local APIC ID
+  struct context *scheduler; // swtch() here to enter scheduler
+  struct taskstate ts;       // Used by x86 to find stack for interrupt
+  struct segdesc gdt[NSEGS]; // x86 global descriptor table
+  volatile uint started;     // Has the CPU started?
+  int ncli;                  // Depth of pushcli nesting.
+  int intena;                // Were interrupts enabled before pushcli?
+  struct proc *proc;         // The process running on this cpu or null
 };
 
 extern struct cpu cpus[NCPU];
 extern int ncpu;
 
-//PAGEBREAK: 17
+// PAGEBREAK: 17
 // Saved registers for kernel context switches.
 // Don't need to save all the segment registers (%cs, etc),
 // because they are constant across kernel contexts.
@@ -36,19 +36,19 @@ enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
 // Per-process state
 struct proc {
-  uint sz;                     // Size of process memory (bytes)
-  pde_t* pgdir;                // Page table
-  char *kstack;                // Bottom of kernel stack for this process
-  enum procstate state;        // Process state
-  int pid;                     // Process ID
-  struct proc *parent;         // Parent process
-  struct trapframe *tf;        // Trap frame for current syscall
-  struct context *context;     // swtch() here to run process
-  void *chan;                  // If non-zero, sleeping on chan
-  int killed;                  // If non-zero, have been killed
-  struct file *ofile[NOFILE];  // Open files
-  struct inode *cwd;           // Current directory
-  char name[16];               // Process name (debugging)
+  uint sz;                    // Size of process memory (bytes)
+  pde_t *pgdir;               // Page table
+  char *kstack;               // Bottom of kernel stack for this process
+  enum procstate state;       // Process state
+  int pid;                    // Process ID
+  struct proc *parent;        // Parent process
+  struct trapframe *tf;       // Trap frame for current syscall
+  struct context *context;    // swtch() here to run process
+  void *chan;                 // If non-zero, sleeping on chan
+  int killed;                 // If non-zero, have been killed
+  struct file *ofile[NOFILE]; // Open files
+  struct inode *cwd;          // Current directory
+  char name[16];              // Process name (debugging)
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/rm.c b/rm.c
index 4fd33c8..3f1e607 100644
--- a/rm.c
+++ b/rm.c
@@ -2,18 +2,16 @@
 #include "stat.h"
 #include "user.h"
 
-int
-main(int argc, char *argv[])
-{
+int main(int argc, char *argv[]) {
   int i;
 
-  if(argc < 2){
+  if (argc < 2) {
     printf(2, "Usage: rm files...\n");
     exit();
   }
 
-  for(i = 1; i < argc; i++){
-    if(unlink(argv[i]) < 0){
+  for (i = 1; i < argc; i++) {
+    if (unlink(argv[i]) < 0) {
       printf(2, "rm: %s failed to delete\n", argv[i]);
       break;
     }
diff --git a/sbrktest.c b/sbrktest.c
index bd969ff..ea1dfb8 100644
--- a/sbrktest.c
+++ b/sbrktest.c
@@ -7,10 +7,10 @@
 // (qemu) info cpus
 //  CPU #0: pc=0x0000000080103d20 thread_id=17473
 //* CPU #1: pc=0x0000000000000001 thread_id=17473
-// 
+//
 // 2. if you are not, use 'cpu 1' to set default CPU (thread)
 // 3. 'info pg' and we now can see user space page mappings:
-// 
+//
 // breakpoint set: sys_sbrk(line 58 to avoid race condition)->trapret
 //
 // before sbrk
@@ -28,29 +28,33 @@
 // [00000-00000]  PTE[000]     ----A--UWP 0dee2
 // [00001-00001]  PTE[001]     --------WP 0dee0
 // [00002-00002]  PTE[002]     ---DA--UWP 0dedf
-// [00003-00003]  PTE[003]     -------UWP 0dfbc (newly allocated page after sbrk(1))
+// [00003-00003]  PTE[003]     -------UWP 0dfbc (newly allocated page after
+// sbrk(1))
 
 // a new physical page will be allocted and page table also will be updated
 
-int main(int argc, char *argv[])
-{
-	char *addr = sbrk(1);
-	if (addr == (char *)-1)
-	{
-		printf(2, "sbrk failed\n");
-		exit();
-	}
-	*addr = 'a'; // write above stack (heap) to generate a page fault and self-correction
-	// when use lazy allocation, the mapping changes above would become:
-	// 1. before *addr = 'a', [00002-00002]  PTE[002]     ---DA--UWP 0dee5
-	// 2. after *addr = 'a', [00002-00003]  PTE[002-003] ---DA--UWP 0dee5 0dfbc (new page has been allocated on the fly)
-
-	// write just 1 byte will trigger the page fault, cause one physical page got mapped, so next time, we access
-	// within one page like: (addr + 1), (addr + 2), ... , (addr + 4095), we kind of got a cache-hit
-
-	// *(addr + 4096) = 'b'; //this should cause a kernel panic, because we did not increase process size that much
-
-	printf(1, "sbrk success\n");
-
-	exit();		// must be exit(), if we return, fake PC 0xffffffff will take over, then got killed... 
+int main(int argc, char *argv[]) {
+  char *addr = sbrk(1);
+  if (addr == (char *)-1) {
+    printf(2, "sbrk failed\n");
+    exit();
+  }
+  *addr = 'a'; // write above stack (heap) to generate a page fault and
+               // self-correction
+  // when use lazy allocation, the mapping changes above would become:
+  // 1. before *addr = 'a', [00002-00002]  PTE[002]     ---DA--UWP 0dee5
+  // 2. after *addr = 'a', [00002-00003]  PTE[002-003] ---DA--UWP 0dee5 0dfbc
+  // (new page has been allocated on the fly)
+
+  // write just 1 byte will trigger the page fault, cause one physical page got
+  // mapped, so next time, we access within one page like: (addr + 1), (addr +
+  // 2), ... , (addr + 4095), we kind of got a cache-hit
+
+  // *(addr + 4096) = 'b'; //this should cause a kernel panic, because we did
+  // not increase process size that much
+
+  printf(1, "sbrk success\n");
+
+  exit(); // must be exit(), if we return, fake PC 0xffffffff will take over,
+          // then got killed...
 }
\ No newline at end of file
diff --git a/sh.c b/sh.c
index f56d895..51f4a19 100644
--- a/sh.c
+++ b/sh.c
@@ -5,11 +5,11 @@
 #include "fcntl.h"
 
 // Parsed command representation
-#define EXEC  1
+#define EXEC 1
 #define REDIR 2
-#define PIPE  3
-#define LIST  4
-#define BACK  5
+#define PIPE 3
+#define LIST 4
+#define BACK 5
 
 #define MAXARGS 10
 
@@ -49,14 +49,12 @@ struct backcmd {
   struct cmd *cmd;
 };
 
-int fork1(void);  // Fork but panics on failure.
-void panic(char*);
-struct cmd *parsecmd(char*);
+int fork1(void); // Fork but panics on failure.
+void panic(char *);
+struct cmd *parsecmd(char *);
 
 // Execute cmd.  Never returns.
-void
-runcmd(struct cmd *cmd)
-{
+void runcmd(struct cmd *cmd) {
   int p[2];
   struct backcmd *bcmd;
   struct execcmd *ecmd;
@@ -64,25 +62,25 @@ runcmd(struct cmd *cmd)
   struct pipecmd *pcmd;
   struct redircmd *rcmd;
 
-  if(cmd == 0)
+  if (cmd == 0)
     exit();
 
-  switch(cmd->type){
+  switch (cmd->type) {
   default:
     panic("runcmd");
 
   case EXEC:
-    ecmd = (struct execcmd*)cmd;
-    if(ecmd->argv[0] == 0)
+    ecmd = (struct execcmd *)cmd;
+    if (ecmd->argv[0] == 0)
       exit();
     exec(ecmd->argv[0], ecmd->argv);
     printf(2, "exec %s failed\n", ecmd->argv[0]);
     break;
 
   case REDIR:
-    rcmd = (struct redircmd*)cmd;
+    rcmd = (struct redircmd *)cmd;
     close(rcmd->fd);
-    if(open(rcmd->file, rcmd->mode) < 0){
+    if (open(rcmd->file, rcmd->mode) < 0) {
       printf(2, "open %s failed\n", rcmd->file);
       exit();
     }
@@ -90,25 +88,25 @@ runcmd(struct cmd *cmd)
     break;
 
   case LIST:
-    lcmd = (struct listcmd*)cmd;
-    if(fork1() == 0)
+    lcmd = (struct listcmd *)cmd;
+    if (fork1() == 0)
       runcmd(lcmd->left);
     wait();
     runcmd(lcmd->right);
     break;
 
   case PIPE:
-    pcmd = (struct pipecmd*)cmd;
-    if(pipe(p) < 0)
+    pcmd = (struct pipecmd *)cmd;
+    if (pipe(p) < 0)
       panic("pipe");
-    if(fork1() == 0){
+    if (fork1() == 0) {
       close(1);
       dup2(p[1], 1);
       close(p[0]);
       close(p[1]);
       runcmd(pcmd->left);
     }
-    if(fork1() == 0){
+    if (fork1() == 0) {
       close(0);
       dup2(p[0], 0);
       close(p[0]);
@@ -122,90 +120,79 @@ runcmd(struct cmd *cmd)
     break;
 
   case BACK:
-    bcmd = (struct backcmd*)cmd;
-    if(fork1() == 0)
+    bcmd = (struct backcmd *)cmd;
+    if (fork1() == 0)
       runcmd(bcmd->cmd);
     break;
   }
   exit();
 }
 
-int
-getcmd(char *buf, int nbuf)
-{
+int getcmd(char *buf, int nbuf) {
   printf(2, "$ ");
   memset(buf, 0, nbuf);
   gets(buf, nbuf);
-  if(buf[0] == 0) // EOF
+  if (buf[0] == 0) // EOF
     return -1;
   return 0;
 }
 
-int
-main(void)
-{
+int main(void) {
   static char buf[100];
   int fd;
 
   // Ensure that three file descriptors are open.
-  while((fd = open("console", O_RDWR)) >= 0){
-    if(fd >= 3){
+  while ((fd = open("console", O_RDWR)) >= 0) {
+    if (fd >= 3) {
       close(fd);
       break;
     }
   }
 
   // Read and run input commands.
-  while(getcmd(buf, sizeof(buf)) >= 0){
-    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+  while (getcmd(buf, sizeof(buf)) >= 0) {
+    if (buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' ') {
       // Chdir must be called by the parent, not the child.
-      buf[strlen(buf)-1] = 0;  // chop \n
-      if(chdir(buf+3) < 0)
-        printf(2, "cannot cd %s\n", buf+3);
+      buf[strlen(buf) - 1] = 0; // chop \n
+      if (chdir(buf + 3) < 0)
+        printf(2, "cannot cd %s\n", buf + 3);
       continue;
     }
-    if(fork1() == 0)
+    if (fork1() == 0)
       runcmd(parsecmd(buf));
     wait();
   }
   exit();
 }
 
-void
-panic(char *s)
-{
+void panic(char *s) {
   printf(2, "%s\n", s);
   exit();
 }
 
-int
-fork1(void)
-{
+int fork1(void) {
   int pid;
 
   pid = fork();
-  if(pid == -1)
+  if (pid == -1)
     panic("fork");
   return pid;
 }
 
-//PAGEBREAK!
+// PAGEBREAK!
 // Constructors
 
-struct cmd*
-execcmd(void)
-{
+struct cmd *execcmd(void) {
   struct execcmd *cmd;
 
   cmd = malloc(sizeof(*cmd));
   memset(cmd, 0, sizeof(*cmd));
   cmd->type = EXEC;
-  return (struct cmd*)cmd;
+  return (struct cmd *)cmd;
 }
 
-struct cmd*
-redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
-{
+struct cmd *redircmd(struct cmd *subcmd, char *file, char *efile, int mode,
+                     int fd) {
   struct redircmd *cmd;
 
   cmd = malloc(sizeof(*cmd));
@@ -216,12 +203,10 @@ redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
   cmd->efile = efile;
   cmd->mode = mode;
   cmd->fd = fd;
-  return (struct cmd*)cmd;
+  return (struct cmd *)cmd;
 }
 
-struct cmd*
-pipecmd(struct cmd *left, struct cmd *right)
-{
+struct cmd *pipecmd(struct cmd *left, struct cmd *right) {
   struct pipecmd *cmd;
 
   cmd = malloc(sizeof(*cmd));
@@ -229,12 +214,10 @@ pipecmd(struct cmd *left, struct cmd *right)
   cmd->type = PIPE;
   cmd->left = left;
   cmd->right = right;
-  return (struct cmd*)cmd;
+  return (struct cmd *)cmd;
 }
 
-struct cmd*
-listcmd(struct cmd *left, struct cmd *right)
-{
+struct cmd *listcmd(struct cmd *left, struct cmd *right) {
   struct listcmd *cmd;
 
   cmd = malloc(sizeof(*cmd));
@@ -242,39 +225,35 @@ listcmd(struct cmd *left, struct cmd *right)
   cmd->type = LIST;
   cmd->left = left;
   cmd->right = right;
-  return (struct cmd*)cmd;
+  return (struct cmd *)cmd;
 }
 
-struct cmd*
-backcmd(struct cmd *subcmd)
-{
+struct cmd *backcmd(struct cmd *subcmd) {
   struct backcmd *cmd;
 
   cmd = malloc(sizeof(*cmd));
   memset(cmd, 0, sizeof(*cmd));
   cmd->type = BACK;
   cmd->cmd = subcmd;
-  return (struct cmd*)cmd;
+  return (struct cmd *)cmd;
 }
-//PAGEBREAK!
+// PAGEBREAK!
 // Parsing
 
 char whitespace[] = " \t\r\n\v";
 char symbols[] = "<|>&;()";
 
-int
-gettoken(char **ps, char *es, char **q, char **eq)
-{
+int gettoken(char **ps, char *es, char **q, char **eq) {
   char *s;
   int ret;
 
   s = *ps;
-  while(s < es && strchr(whitespace, *s))
+  while (s < es && strchr(whitespace, *s))
     s++;
-  if(q)
+  if (q)
     *q = s;
   ret = *s;
-  switch(*s){
+  switch (*s) {
   case 0:
     break;
   case '|':
@@ -287,53 +266,49 @@ gettoken(char **ps, char *es, char **q, char **eq)
     break;
   case '>':
     s++;
-    if(*s == '>'){
+    if (*s == '>') {
       ret = '+';
       s++;
     }
     break;
   default:
     ret = 'a';
-    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+    while (s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
       s++;
     break;
   }
-  if(eq)
+  if (eq)
     *eq = s;
 
-  while(s < es && strchr(whitespace, *s))
+  while (s < es && strchr(whitespace, *s))
     s++;
   *ps = s;
   return ret;
 }
 
-int
-peek(char **ps, char *es, char *toks)
-{
+int peek(char **ps, char *es, char *toks) {
   char *s;
 
   s = *ps;
-  while(s < es && strchr(whitespace, *s))
+  while (s < es && strchr(whitespace, *s))
     s++;
   *ps = s;
   return *s && strchr(toks, *s);
 }
 
-struct cmd *parseline(char**, char*);
-struct cmd *parsepipe(char**, char*);
-struct cmd *parseexec(char**, char*);
-struct cmd *nulterminate(struct cmd*);
+struct cmd *parseline(char **, char *);
+struct cmd *parsepipe(char **, char *);
+struct cmd *parseexec(char **, char *);
+struct cmd *nulterminate(struct cmd *);
 
-struct cmd*
-parsecmd(char *s)
-{
+struct cmd *parsecmd(char *s) {
   char *es;
   struct cmd *cmd;
 
   es = s + strlen(s);
   cmd = parseline(&s, es);
   peek(&s, es, "");
-  if(s != es){
+  if (s != es) {
     printf(2, "leftovers: %s\n", s);
     panic("syntax");
   }
@@ -341,102 +316,92 @@ parsecmd(char *s)
   return cmd;
 }
 
-struct cmd*
-parseline(char **ps, char *es)
-{
+struct cmd *parseline(char **ps, char *es) {
   struct cmd *cmd;
 
   cmd = parsepipe(ps, es);
-  while(peek(ps, es, "&")){
+  while (peek(ps, es, "&")) {
     gettoken(ps, es, 0, 0);
     cmd = backcmd(cmd);
   }
-  if(peek(ps, es, ";")){
+  if (peek(ps, es, ";")) {
     gettoken(ps, es, 0, 0);
     cmd = listcmd(cmd, parseline(ps, es));
   }
   return cmd;
 }
 
-struct cmd*
-parsepipe(char **ps, char *es)
-{
+struct cmd *parsepipe(char **ps, char *es) {
   struct cmd *cmd;
 
   cmd = parseexec(ps, es);
-  if(peek(ps, es, "|")){
+  if (peek(ps, es, "|")) {
     gettoken(ps, es, 0, 0);
     cmd = pipecmd(cmd, parsepipe(ps, es));
   }
   return cmd;
 }
 
-struct cmd*
-parseredirs(struct cmd *cmd, char **ps, char *es)
-{
+struct cmd *parseredirs(struct cmd *cmd, char **ps, char *es) {
   int tok;
   char *q, *eq;
 
-  while(peek(ps, es, "<>")){
+  while (peek(ps, es, "<>")) {
     tok = gettoken(ps, es, 0, 0);
-    if(gettoken(ps, es, &q, &eq) != 'a')
+    if (gettoken(ps, es, &q, &eq) != 'a')
       panic("missing file for redirection");
-    switch(tok){
+    switch (tok) {
     case '<':
       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
       break;
     case '>':
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+      cmd = redircmd(cmd, q, eq, O_WRONLY | O_CREATE, 1);
       break;
-    case '+':  // >>
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+    case '+': // >>
+      cmd = redircmd(cmd, q, eq, O_WRONLY | O_CREATE, 1);
       break;
     }
   }
   return cmd;
 }
 
-struct cmd*
-parseblock(char **ps, char *es)
-{
+struct cmd *parseblock(char **ps, char *es) {
   struct cmd *cmd;
 
-  if(!peek(ps, es, "("))
+  if (!peek(ps, es, "("))
     panic("parseblock");
   gettoken(ps, es, 0, 0);
   cmd = parseline(ps, es);
-  if(!peek(ps, es, ")"))
+  if (!peek(ps, es, ")"))
     panic("syntax - missing )");
   gettoken(ps, es, 0, 0);
   cmd = parseredirs(cmd, ps, es);
   return cmd;
 }
 
-struct cmd*
-parseexec(char **ps, char *es)
-{
+struct cmd *parseexec(char **ps, char *es) {
   char *q, *eq;
   int tok, argc;
   struct execcmd *cmd;
   struct cmd *ret;
 
-  if(peek(ps, es, "("))
+  if (peek(ps, es, "("))
     return parseblock(ps, es);
 
   ret = execcmd();
-  cmd = (struct execcmd*)ret;
+  cmd = (struct execcmd *)ret;
 
   argc = 0;
   ret = parseredirs(ret, ps, es);
-  while(!peek(ps, es, "|)&;")){
-    if((tok=gettoken(ps, es, &q, &eq)) == 0)
+  while (!peek(ps, es, "|)&;")) {
+    if ((tok = gettoken(ps, es, &q, &eq)) == 0)
       break;
-    if(tok != 'a')
+    if (tok != 'a')
       panic("syntax");
     cmd->argv[argc] = q;
     cmd->eargv[argc] = eq;
     argc++;
-    if(argc >= MAXARGS)
+    if (argc >= MAXARGS)
       panic("too many args");
     ret = parseredirs(ret, ps, es);
   }
@@ -446,9 +411,7 @@ parseexec(char **ps, char *es)
 }
 
 // NUL-terminate all the counted strings.
-struct cmd*
-nulterminate(struct cmd *cmd)
-{
+struct cmd *nulterminate(struct cmd *cmd) {
   int i;
   struct backcmd *bcmd;
   struct execcmd *ecmd;
@@ -456,36 +419,36 @@ nulterminate(struct cmd *cmd)
   struct pipecmd *pcmd;
   struct redircmd *rcmd;
 
-  if(cmd == 0)
+  if (cmd == 0)
     return 0;
 
-  switch(cmd->type){
+  switch (cmd->type) {
   case EXEC:
-    ecmd = (struct execcmd*)cmd;
-    for(i=0; ecmd->argv[i]; i++)
+    ecmd = (struct execcmd *)cmd;
+    for (i = 0; ecmd->argv[i]; i++)
       *ecmd->eargv[i] = 0;
     break;
 
   case REDIR:
-    rcmd = (struct redircmd*)cmd;
+    rcmd = (struct redircmd *)cmd;
     nulterminate(rcmd->cmd);
     *rcmd->efile = 0;
     break;
 
   case PIPE:
-    pcmd = (struct pipecmd*)cmd;
+    pcmd = (struct pipecmd *)cmd;
     nulterminate(pcmd->left);
     nulterminate(pcmd->right);
     break;
 
   case LIST:
-    lcmd = (struct listcmd*)cmd;
+    lcmd = (struct listcmd *)cmd;
     nulterminate(lcmd->left);
     nulterminate(lcmd->right);
     break;
 
   case BACK:
-    bcmd = (struct backcmd*)cmd;
+    bcmd = (struct backcmd *)cmd;
     nulterminate(bcmd->cmd);
     break;
   }
diff --git a/sleeplock.c b/sleeplock.c
index e0750ea..ae5dcac 100644
--- a/sleeplock.c
+++ b/sleeplock.c
@@ -10,18 +10,14 @@
 #include "spinlock.h"
 #include "sleeplock.h"
 
-void
-initsleeplock(struct sleeplock *lk, char *name)
-{
+void initsleeplock(struct sleeplock *lk, char *name) {
   initlock(&lk->lk, "sleep lock");
   lk->name = name;
   lk->locked = 0;
   lk->pid = 0;
 }
 
-void
-acquiresleep(struct sleeplock *lk)
-{
+void acquiresleep(struct sleeplock *lk) {
   acquire(&lk->lk);
   while (lk->locked) {
     sleep(lk, &lk->lk);
@@ -31,9 +27,7 @@ acquiresleep(struct sleeplock *lk)
   release(&lk->lk);
 }
 
-void
-releasesleep(struct sleeplock *lk)
-{
+void releasesleep(struct sleeplock *lk) {
   acquire(&lk->lk);
   lk->locked = 0;
   lk->pid = 0;
@@ -41,16 +35,11 @@ releasesleep(struct sleeplock *lk)
   release(&lk->lk);
 }
 
-int
-holdingsleep(struct sleeplock *lk)
-{
+int holdingsleep(struct sleeplock *lk) {
   int r;
-  
+
   acquire(&lk->lk);
   r = lk->locked && (lk->pid == myproc()->pid);
   release(&lk->lk);
   return r;
 }
-
-
-
diff --git a/sleeplock.h b/sleeplock.h
index 110e6f3..f06e988 100644
--- a/sleeplock.h
+++ b/sleeplock.h
@@ -1,10 +1,9 @@
 // Long-term locks for processes
 struct sleeplock {
-  uint locked;       // Is the lock held?
+  uint locked;        // Is the lock held?
   struct spinlock lk; // spinlock protecting this sleep lock
-  
+
   // For debugging:
-  char *name;        // Name of lock.
-  int pid;           // Process holding lock
+  char *name; // Name of lock.
+  int pid;    // Process holding lock
 };
-
diff --git a/spinlock.c b/spinlock.c
index 4020186..46e0ee8 100644
--- a/spinlock.c
+++ b/spinlock.c
@@ -9,9 +9,7 @@
 #include "proc.h"
 #include "spinlock.h"
 
-void
-initlock(struct spinlock *lk, char *name)
-{
+void initlock(struct spinlock *lk, char *name) {
   lk->name = name;
   lk->locked = 0;
   lk->cpu = 0;
@@ -21,15 +19,13 @@ initlock(struct spinlock *lk, char *name)
 // Loops (spins) until the lock is acquired.
 // Holding a lock for a long time may cause
 // other CPUs to waste time spinning to acquire it.
-void
-acquire(struct spinlock *lk)
-{
+void acquire(struct spinlock *lk) {
   pushcli(); // disable interrupts to avoid deadlock.
-  if(holding(lk))
+  if (holding(lk))
     panic("acquire");
 
   // The xchg is atomic.
-  while(xchg(&lk->locked, 1) != 0)
+  while (xchg(&lk->locked, 1) != 0)
     ;
 
   // Tell the C compiler and the processor to not move loads or stores
@@ -43,10 +39,8 @@ acquire(struct spinlock *lk)
 }
 
 // Release the lock.
-void
-release(struct spinlock *lk)
-{
-  if(!holding(lk))
+void release(struct spinlock *lk) {
+  if (!holding(lk))
     panic("release");
 
   lk->pcs[0] = 0;
@@ -62,33 +56,29 @@ release(struct spinlock *lk)
   // Release the lock, equivalent to lk->locked = 0.
   // This code can't use a C assignment, since it might
   // not be atomic. A real OS would use C atomics here.
-  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+  asm volatile("movl $0, %0" : "+m"(lk->locked) :);
 
   popcli();
 }
 
 // Record the current call stack in pcs[] by following the %ebp chain.
-void
-getcallerpcs(void *v, uint pcs[])
-{
+void getcallerpcs(void *v, uint pcs[]) {
   uint *ebp;
   int i;
 
-  ebp = (uint*)v - 2;
-  for(i = 0; i < 10; i++){
-    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
+  ebp = (uint *)v - 2;
+  for (i = 0; i < 10; i++) {
+    if (ebp == 0 || ebp < (uint *)KERNBASE || ebp == (uint *)0xffffffff)
       break;
-    pcs[i] = ebp[1];     // saved %eip
-    ebp = (uint*)ebp[0]; // saved %ebp
+    pcs[i] = ebp[1];      // saved %eip
+    ebp = (uint *)ebp[0]; // saved %ebp
   }
-  for(; i < 10; i++)
+  for (; i < 10; i++)
     pcs[i] = 0;
 }
 
 // Check whether this cpu is holding the lock.
-int
-holding(struct spinlock *lock)
-{
+int holding(struct spinlock *lock) {
   int r;
   pushcli();
   r = lock->locked && lock->cpu == mycpu();
@@ -96,31 +86,25 @@ holding(struct spinlock *lock)
   return r;
 }
 
-
 // Pushcli/popcli are like cli/sti except that they are matched:
 // it takes two popcli to undo two pushcli.  Also, if interrupts
 // are off, then pushcli, popcli leaves them off.
 
-void
-pushcli(void)
-{
+void pushcli(void) {
   int eflags;
 
   eflags = readeflags();
   cli();
-  if(mycpu()->ncli == 0)
+  if (mycpu()->ncli == 0)
     mycpu()->intena = eflags & FL_IF;
   mycpu()->ncli += 1;
 }
 
-void
-popcli(void)
-{
-  if(readeflags()&FL_IF)
+void popcli(void) {
+  if (readeflags() & FL_IF)
     panic("popcli - interruptible");
-  if(--mycpu()->ncli < 0)
+  if (--mycpu()->ncli < 0)
     panic("popcli");
-  if(mycpu()->ncli == 0 && mycpu()->intena)
+  if (mycpu()->ncli == 0 && mycpu()->intena)
     sti();
 }
-
diff --git a/spinlock.h b/spinlock.h
index 0a9d8e2..f2452d6 100644
--- a/spinlock.h
+++ b/spinlock.h
@@ -1,11 +1,10 @@
 // Mutual exclusion lock.
 struct spinlock {
-  uint locked;       // Is the lock held?
+  uint locked; // Is the lock held?
 
   // For debugging:
-  char *name;        // Name of lock.
-  struct cpu *cpu;   // The cpu holding the lock.
-  uint pcs[10];      // The call stack (an array of program counters)
-                     // that locked the lock.
+  char *name;      // Name of lock.
+  struct cpu *cpu; // The cpu holding the lock.
+  uint pcs[10];    // The call stack (an array of program counters)
+                   // that locked the lock.
 };
-
diff --git a/stat.h b/stat.h
index 8a80933..d44ddad 100644
--- a/stat.h
+++ b/stat.h
@@ -1,6 +1,6 @@
-#define T_DIR  1   // Directory
-#define T_FILE 2   // File
-#define T_DEV  3   // Device
+#define T_DIR 1  // Directory
+#define T_FILE 2 // File
+#define T_DEV 3  // Device
 
 struct stat {
   short type;  // Type of file
diff --git a/stressfs.c b/stressfs.c
index c0a4743..340750b 100644
--- a/stressfs.c
+++ b/stressfs.c
@@ -13,9 +13,7 @@
 #include "fs.h"
 #include "fcntl.h"
 
-int
-main(int argc, char *argv[])
-{
+int main(int argc, char *argv[]) {
   int fd, i;
   char path[] = "stressfs0";
   char data[512];
@@ -23,16 +21,16 @@ main(int argc, char *argv[])
   printf(1, "stressfs starting\n");
   memset(data, 'a', sizeof(data));
 
-  for(i = 0; i < 4; i++)
-    if(fork() > 0)
+  for (i = 0; i < 4; i++)
+    if (fork() > 0)
       break;
 
   printf(1, "write %d\n", i);
 
   path[8] += i;
   fd = open(path, O_CREATE | O_RDWR);
-  for(i = 0; i < 20; i++)
-//    printf(fd, "%d\n", i);
+  for (i = 0; i < 20; i++)
+    //    printf(fd, "%d\n", i);
     write(fd, data, sizeof(data));
   close(fd);
 
diff --git a/string.c b/string.c
index a7cc61f..4ca605b 100644
--- a/string.c
+++ b/string.c
@@ -1,26 +1,22 @@
 #include "types.h"
 #include "x86.h"
 
-void*
-memset(void *dst, int c, uint n)
-{
-  if ((int)dst%4 == 0 && n%4 == 0){
+void *memset(void *dst, int c, uint n) {
+  if ((int)dst % 4 == 0 && n % 4 == 0) {
     c &= 0xFF;
-    stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
+    stosl(dst, (c << 24) | (c << 16) | (c << 8) | c, n / 4);
   } else
     stosb(dst, c, n);
   return dst;
 }
 
-int
-memcmp(const void *v1, const void *v2, uint n)
-{
+int memcmp(const void *v1, const void *v2, uint n) {
   const uchar *s1, *s2;
 
   s1 = v1;
   s2 = v2;
-  while(n-- > 0){
-    if(*s1 != *s2)
+  while (n-- > 0) {
+    if (*s1 != *s2)
       return *s1 - *s2;
     s1++, s2++;
   }
@@ -28,78 +24,65 @@ memcmp(const void *v1, const void *v2, uint n)
   return 0;
 }
 
-void*
-memmove(void *dst, const void *src, uint n)
-{
+void *memmove(void *dst, const void *src, uint n) {
   const char *s;
   char *d;
 
   s = src;
   d = dst;
-  if(s < d && s + n > d){
+  if (s < d && s + n > d) {
     s += n;
     d += n;
-    while(n-- > 0)
+    while (n-- > 0)
       *--d = *--s;
   } else
-    while(n-- > 0)
+    while (n-- > 0)
       *d++ = *s++;
 
   return dst;
 }
 
 // memcpy exists to placate GCC.  Use memmove.
-void*
-memcpy(void *dst, const void *src, uint n)
-{
+void *memcpy(void *dst, const void *src, uint n) {
   return memmove(dst, src, n);
 }
 
-int
-strncmp(const char *p, const char *q, uint n)
-{
-  while(n > 0 && *p && *p == *q)
+int strncmp(const char *p, const char *q, uint n) {
+  while (n > 0 && *p && *p == *q)
     n--, p++, q++;
-  if(n == 0)
+  if (n == 0)
     return 0;
   return (uchar)*p - (uchar)*q;
 }
 
-char*
-strncpy(char *s, const char *t, int n)
-{
+char *strncpy(char *s, const char *t, int n) {
   char *os;
 
   os = s;
-  while(n-- > 0 && (*s++ = *t++) != 0)
+  while (n-- > 0 && (*s++ = *t++) != 0)
     ;
-  while(n-- > 0)
+  while (n-- > 0)
     *s++ = 0;
   return os;
 }
 
 // Like strncpy but guaranteed to NUL-terminate.
-char*
-safestrcpy(char *s, const char *t, int n)
-{
+char *safestrcpy(char *s, const char *t, int n) {
   char *os;
 
   os = s;
-  if(n <= 0)
+  if (n <= 0)
     return os;
-  while(--n > 0 && (*s++ = *t++) != 0)
+  while (--n > 0 && (*s++ = *t++) != 0)
     ;
   *s = 0;
   return os;
 }
 
-int
-strlen(const char *s)
-{
+int strlen(const char *s) {
   int n;
 
-  for(n = 0; s[n]; n++)
+  for (n = 0; s[n]; n++)
     ;
   return n;
 }
-
diff --git a/syscall.c b/syscall.c
index 85b7765..453f9ae 100644
--- a/syscall.c
+++ b/syscall.c
@@ -14,58 +14,50 @@
 // to a saved program counter, and then the first argument.
 
 // Fetch the int at addr from the current process.
-int
-fetchint(uint addr, int *ip)
-{
+int fetchint(uint addr, int *ip) {
   struct proc *curproc = myproc();
 
-  if(addr >= curproc->sz || addr+4 > curproc->sz)
+  if (addr >= curproc->sz || addr + 4 > curproc->sz)
     return -1;
-  *ip = *(int*)(addr);
+  *ip = *(int *)(addr);
   return 0;
 }
 
 // Fetch the nul-terminated string at addr from the current process.
 // Doesn't actually copy the string - just sets *pp to point at it.
 // Returns length of string, not including nul.
-int
-fetchstr(uint addr, char **pp)
-{
+int fetchstr(uint addr, char **pp) {
   char *s, *ep;
   struct proc *curproc = myproc();
 
-  if(addr >= curproc->sz)
+  if (addr >= curproc->sz)
     return -1;
-  *pp = (char*)addr;
-  ep = (char*)curproc->sz;
-  for(s = *pp; s < ep; s++){
-    if(*s == 0)
+  *pp = (char *)addr;
+  ep = (char *)curproc->sz;
+  for (s = *pp; s < ep; s++) {
+    if (*s == 0)
       return s - *pp;
   }
   return -1;
 }
 
 // Fetch the nth 32-bit system call argument.
-int
-argint(int n, int *ip)
-{
-  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+int argint(int n, int *ip) {
+  return fetchint((myproc()->tf->esp) + 4 + 4 * n, ip);
 }
 
 // Fetch the nth word-sized system call argument as a pointer
 // to a block of memory of size bytes.  Check that the pointer
 // lies within the process address space.
-int
-argptr(int n, char **pp, int size)
-{
+int argptr(int n, char **pp, int size) {
   int i;
   struct proc *curproc = myproc();
- 
-  if(argint(n, &i) < 0)
+
+  if (argint(n, &i) < 0)
     return -1;
-  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+  if (size < 0 || (uint)i >= curproc->sz || (uint)i + size > curproc->sz)
     return -1;
-  *pp = (char*)i;
+  *pp = (char *)i;
   return 0;
 }
 
@@ -73,11 +65,9 @@ argptr(int n, char **pp, int size)
 // Check that the pointer is valid and the string is nul-terminated.
 // (There is no shared writable memory, so the string can't change
 // between this check and being used by the kernel.)
-int
-argstr(int n, char **pp)
-{
+int argstr(int n, char **pp) {
   int addr;
-  if(argint(n, &addr) < 0)
+  if (argint(n, &addr) < 0)
     return -1;
   return fetchstr(addr, pp);
 }
@@ -107,66 +97,34 @@ extern int sys_date(void);
 extern int sys_dup2(void);
 
 static int (*syscalls[])(void) = {
-[SYS_fork]    sys_fork,
-[SYS_exit]    sys_exit,
-[SYS_wait]    sys_wait,
-[SYS_pipe]    sys_pipe,
-[SYS_read]    sys_read,
-[SYS_kill]    sys_kill,
-[SYS_exec]    sys_exec,
-[SYS_fstat]   sys_fstat,
-[SYS_chdir]   sys_chdir,
-[SYS_dup]     sys_dup,
-[SYS_getpid]  sys_getpid,
-[SYS_sbrk]    sys_sbrk,
-[SYS_sleep]   sys_sleep,
-[SYS_uptime]  sys_uptime,
-[SYS_open]    sys_open,
-[SYS_write]   sys_write,
-[SYS_mknod]   sys_mknod,
-[SYS_unlink]  sys_unlink,
-[SYS_link]    sys_link,
-[SYS_mkdir]   sys_mkdir,
-[SYS_close]   sys_close,
-[SYS_date]    sys_date,
-[SYS_dup2]    sys_dup2,
+    [SYS_fork] sys_fork,   [SYS_exit] sys_exit,     [SYS_wait] sys_wait,
+    [SYS_pipe] sys_pipe,   [SYS_read] sys_read,     [SYS_kill] sys_kill,
+    [SYS_exec] sys_exec,   [SYS_fstat] sys_fstat,   [SYS_chdir] sys_chdir,
+    [SYS_dup] sys_dup,     [SYS_getpid] sys_getpid, [SYS_sbrk] sys_sbrk,
+    [SYS_sleep] sys_sleep, [SYS_uptime] sys_uptime, [SYS_open] sys_open,
+    [SYS_write] sys_write, [SYS_mknod] sys_mknod,   [SYS_unlink] sys_unlink,
+    [SYS_link] sys_link,   [SYS_mkdir] sys_mkdir,   [SYS_close] sys_close,
+    [SYS_date] sys_date,   [SYS_dup2] sys_dup2,
 };
 
 // use a string table for the name, any better idea?
 static char *syscallnames[] = {
-[SYS_fork]    "fork",
-[SYS_exit]    "exit",
-[SYS_wait]    "wait",
-[SYS_pipe]    "pipe",
-[SYS_read]    "read",
-[SYS_kill]    "kill",
-[SYS_exec]    "exec",
-[SYS_fstat]   "fstat",
-[SYS_chdir]   "chdir",
-[SYS_dup]     "dup",
-[SYS_getpid]  "getpid",
-[SYS_sbrk]    "sbrk",
-[SYS_sleep]   "sleep",
-[SYS_uptime]  "uptime",
-[SYS_open]    "open",
-[SYS_write]   "write",
-[SYS_mknod]   "mknod",
-[SYS_unlink]  "unlink",
-[SYS_link]    "link",
-[SYS_mkdir]   "mkdir",
-[SYS_close]   "close",
-[SYS_date]    "date",
-[SYS_dup2]    "dup2",
+    [SYS_fork] "fork",   [SYS_exit] "exit",     [SYS_wait] "wait",
+    [SYS_pipe] "pipe",   [SYS_read] "read",     [SYS_kill] "kill",
+    [SYS_exec] "exec",   [SYS_fstat] "fstat",   [SYS_chdir] "chdir",
+    [SYS_dup] "dup",     [SYS_getpid] "getpid", [SYS_sbrk] "sbrk",
+    [SYS_sleep] "sleep", [SYS_uptime] "uptime", [SYS_open] "open",
+    [SYS_write] "write", [SYS_mknod] "mknod",   [SYS_unlink] "unlink",
+    [SYS_link] "link",   [SYS_mkdir] "mkdir",   [SYS_close] "close",
+    [SYS_date] "date",   [SYS_dup2] "dup2",
 };
 
-void
-syscall(void)
-{
+void syscall(void) {
   int num;
   struct proc *curproc = myproc();
 
   num = curproc->tf->eax;
-  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+  if (num > 0 && num < NELEM(syscalls) && syscalls[num]) {
     // should put before the real syscall, e.g. what if exec uses a
     // new image replace the old one, the arguments would be nowhere to track
     //
@@ -183,8 +141,7 @@ syscall(void)
     curproc->tf->eax = syscalls[num]();
     cprintf("%s -> %d\n\n", syscallnames[num], curproc->tf->eax);
   } else {
-    cprintf("%d %s: unknown sys call %d\n",
-            curproc->pid, curproc->name, num);
+    cprintf("%d %s: unknown sys call %d\n", curproc->pid, curproc->name, num);
     curproc->tf->eax = -1;
   }
 }
diff --git a/syscall.h b/syscall.h
index 60d4196..edb15c1 100644
--- a/syscall.h
+++ b/syscall.h
@@ -1,24 +1,24 @@
 // System call numbers
-#define SYS_fork    1
-#define SYS_exit    2
-#define SYS_wait    3
-#define SYS_pipe    4
-#define SYS_read    5
-#define SYS_kill    6
-#define SYS_exec    7
-#define SYS_fstat   8
-#define SYS_chdir   9
-#define SYS_dup    10
+#define SYS_fork 1
+#define SYS_exit 2
+#define SYS_wait 3
+#define SYS_pipe 4
+#define SYS_read 5
+#define SYS_kill 6
+#define SYS_exec 7
+#define SYS_fstat 8
+#define SYS_chdir 9
+#define SYS_dup 10
 #define SYS_getpid 11
-#define SYS_sbrk   12
-#define SYS_sleep  13
+#define SYS_sbrk 12
+#define SYS_sleep 13
 #define SYS_uptime 14
-#define SYS_open   15
-#define SYS_write  16
-#define SYS_mknod  17
+#define SYS_open 15
+#define SYS_write 16
+#define SYS_mknod 17
 #define SYS_unlink 18
-#define SYS_link   19
-#define SYS_mkdir  20
-#define SYS_close  21
-#define SYS_date   22
-#define SYS_dup2   23
+#define SYS_link 19
+#define SYS_mkdir 20
+#define SYS_close 21
+#define SYS_date 22
+#define SYS_dup2 23
diff --git a/sysfile.c b/sysfile.c
index b426dfd..cabeadb 100644
--- a/sysfile.c
+++ b/sysfile.c
@@ -18,34 +18,30 @@
 
 // Fetch the nth word-sized system call argument as a file descriptor
 // and return both the descriptor and the corresponding struct file.
-static int
-argfd(int n, int *pfd, struct file **pf)
-{
+static int argfd(int n, int *pfd, struct file **pf) {
   int fd;
   struct file *f;
 
-  if(argint(n, &fd) < 0)
+  if (argint(n, &fd) < 0)
     return -1;
-  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+  if (fd < 0 || fd >= NOFILE || (f = myproc()->ofile[fd]) == 0)
     return -1;
-  if(pfd)
+  if (pfd)
     *pfd = fd;
-  if(pf)
+  if (pf)
     *pf = f;
   return 0;
 }
 
 // Allocate a file descriptor for the given file.
 // Takes over file reference from caller on success.
-static int
-fdalloc(struct file *f)
-{
+static int fdalloc(struct file *f) {
   int fd;
   struct proc *curproc = myproc();
 
-  for(fd = 0; fd < NOFILE; fd++){
+  for (fd = 0; fd < NOFILE; fd++) {
     // linear find to reach the smallest fd in current process
-    if(curproc->ofile[fd] == 0){
+    if (curproc->ofile[fd] == 0) {
       curproc->ofile[fd] = f;
       return fd;
     }
@@ -53,112 +49,102 @@ fdalloc(struct file *f)
   return -1;
 }
 
-int
-sys_dup(void)
-{
+int sys_dup(void) {
   struct file *f;
   int fd;
 
-  if(argfd(0, 0, &f) < 0)
+  if (argfd(0, 0, &f) < 0)
     return -1;
   cprintf("dup will make a duplication of file object: %p\n", f);
-  if((fd=fdalloc(f)) < 0)
+  if ((fd = fdalloc(f)) < 0)
     return -1;
   filedup(f);
   return fd;
 }
 
-int
-sys_dup2(void)
-{
-    struct file *f;
-    int newfd;
-    if (argfd(0, 0, &f) || argint(1, &newfd) < 0)
-      return -1;
-    cprintf("dup2 will make a duplication of file object %p for given file descriptor %d\n", f, newfd);
-    // check this given newfd is not taken already
-    struct proc *curproc = myproc();
-    if (curproc->ofile[newfd] == 0)
-    {
-        curproc->ofile[newfd] = f;
-        filedup(f);
-        return newfd;
-    }
-
+int sys_dup2(void) {
+  struct file *f;
+  int newfd;
+  if (argfd(0, 0, &f) || argint(1, &newfd) < 0)
     return -1;
+  cprintf("dup2 will make a duplication of file object %p for given file "
+          "descriptor %d\n",
+          f, newfd);
+  // check this given newfd is not taken already
+  struct proc *curproc = myproc();
+  if (curproc->ofile[newfd] == 0) {
+    curproc->ofile[newfd] = f;
+    filedup(f);
+    return newfd;
+  }
+
+  return -1;
 }
 
-int
-sys_read(void)
-{
+int sys_read(void) {
   struct file *f;
   int n;
   char *p;
 
-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+  if (argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
     return -1;
-  cprintf("read on file object %p, file buffer address: %p, size %d\n", f, p, n);
+  cprintf("read on file object %p, file buffer address: %p, size %d\n", f, p,
+          n);
   return fileread(f, p, n);
 }
 
-int
-sys_write(void)
-{
+int sys_write(void) {
   struct file *f;
   int n;
   char *p;
 
-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+  if (argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
     return -1;
-  cprintf("write to file object %p, file buffer address: %p, size %d\n",f, p, n);
+  cprintf("write to file object %p, file buffer address: %p, size %d\n", f, p,
+          n);
   return filewrite(f, p, n);
 }
 
-int
-sys_close(void)
-{
+int sys_close(void) {
   int fd;
   struct file *f;
 
-  if(argfd(0, &fd, &f) < 0)
+  if (argfd(0, &fd, &f) < 0)
     return -1;
-  cprintf("close file descriptor %d previously pointed to file object %p\n", fd, f);
+  cprintf("close file descriptor %d previously pointed to file object %p\n", fd,
+          f);
   myproc()->ofile[fd] = 0;
   fileclose(f);
   return 0;
 }
 
-int
-sys_fstat(void)
-{
+int sys_fstat(void) {
   struct file *f;
   struct stat *st;
 
-  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+  if (argfd(0, 0, &f) < 0 || argptr(1, (void *)&st, sizeof(*st)) < 0)
     return -1;
   cprintf("fstat check file object %p, store file status on %p\n", f, st);
   return filestat(f, st);
 }
 
 // Create the path new as a link to the same inode as old.
-int
-sys_link(void)
-{
+int sys_link(void) {
   char name[DIRSIZ], *new, *old;
   struct inode *dp, *ip;
 
-  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
+  if (argstr(0, &old) < 0 || argstr(1, &new) < 0)
     return -1;
   cprintf("link create new link %s to existing file %s\n", new, old);
 
   begin_op();
-  if((ip = namei(old)) == 0){
+  if ((ip = namei(old)) == 0) {
     end_op();
     return -1;
   }
 
   ilock(ip);
-  if(ip->type == T_DIR){
+  if (ip->type == T_DIR) {
     iunlockput(ip);
     end_op();
     return -1;
@@ -168,10 +154,10 @@ sys_link(void)
   iupdate(ip);
   iunlock(ip);
 
-  if((dp = nameiparent(new, name)) == 0)
+  if ((dp = nameiparent(new, name)) == 0)
     goto bad;
   ilock(dp);
-  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+  if (dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0) {
     iunlockput(dp);
     goto bad;
   }
@@ -192,35 +178,31 @@ bad:
 }
 
 // Is the directory dp empty except for "." and ".." ?
-static int
-isdirempty(struct inode *dp)
-{
+static int isdirempty(struct inode *dp) {
   int off;
   struct dirent de;
 
-  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+  for (off = 2 * sizeof(de); off < dp->size; off += sizeof(de)) {
+    if (readi(dp, (char *)&de, off, sizeof(de)) != sizeof(de))
       panic("isdirempty: readi");
-    if(de.inum != 0)
+    if (de.inum != 0)
       return 0;
   }
   return 1;
 }
 
-//PAGEBREAK!
-int
-sys_unlink(void)
-{
+// PAGEBREAK!
+int sys_unlink(void) {
   struct inode *ip, *dp;
   struct dirent de;
   char name[DIRSIZ], *path;
   uint off;
 
-  if(argstr(0, &path) < 0)
+  if (argstr(0, &path) < 0)
     return -1;
   cprintf("unlink delete %s from file system\n", path);
   begin_op();
-  if((dp = nameiparent(path, name)) == 0){
+  if ((dp = nameiparent(path, name)) == 0) {
     end_op();
     return -1;
   }
@@ -228,24 +210,24 @@ sys_unlink(void)
   ilock(dp);
 
   // Cannot unlink "." or "..".
-  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+  if (namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
     goto bad;
 
-  if((ip = dirlookup(dp, name, &off)) == 0)
+  if ((ip = dirlookup(dp, name, &off)) == 0)
     goto bad;
   ilock(ip);
 
-  if(ip->nlink < 1)
+  if (ip->nlink < 1)
     panic("unlink: nlink < 1");
-  if(ip->type == T_DIR && !isdirempty(ip)){
+  if (ip->type == T_DIR && !isdirempty(ip)) {
     iunlockput(ip);
     goto bad;
   }
 
   memset(&de, 0, sizeof(de));
-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+  if (writei(dp, (char *)&de, off, sizeof(de)) != sizeof(de))
     panic("unlink: writei");
-  if(ip->type == T_DIR){
+  if (ip->type == T_DIR) {
     dp->nlink--;
     iupdate(dp);
   }
@@ -265,26 +247,24 @@ bad:
   return -1;
 }
 
-static struct inode*
-create(char *path, short type, short major, short minor)
-{
+static struct inode *create(char *path, short type, short major, short minor) {
   struct inode *ip, *dp;
   char name[DIRSIZ];
 
-  if((dp = nameiparent(path, name)) == 0)
+  if ((dp = nameiparent(path, name)) == 0)
     return 0;
   ilock(dp);
 
-  if((ip = dirlookup(dp, name, 0)) != 0){
+  if ((ip = dirlookup(dp, name, 0)) != 0) {
     iunlockput(dp);
     ilock(ip);
-    if(type == T_FILE && ip->type == T_FILE)
+    if (type == T_FILE && ip->type == T_FILE)
       return ip;
     iunlockput(ip);
     return 0;
   }
 
-  if((ip = ialloc(dp->dev, type)) == 0)
+  if ((ip = ialloc(dp->dev, type)) == 0)
     panic("create: ialloc");
 
   ilock(ip);
@@ -293,15 +273,15 @@ create(char *path, short type, short major, short minor)
   ip->nlink = 1;
   iupdate(ip);
 
-  if(type == T_DIR){  // Create . and .. entries.
-    dp->nlink++;  // for ".."
+  if (type == T_DIR) { // Create . and .. entries.
+    dp->nlink++;       // for ".."
     iupdate(dp);
     // No ip->nlink++ for ".": avoid cyclic ref count.
-    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+    if (dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
       panic("create dots");
   }
 
-  if(dirlink(dp, name, ip->inum) < 0)
+  if (dirlink(dp, name, ip->inum) < 0)
     panic("create: dirlink");
 
   iunlockput(dp);
@@ -309,15 +289,13 @@ create(char *path, short type, short major, short minor)
   return ip;
 }
 
-int
-sys_open(void)
-{
+int sys_open(void) {
   char *path;
   int fd, omode;
   struct file *f;
   struct inode *ip;
 
-  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
+  if (argstr(0, &path) < 0 || argint(1, &omode) < 0)
     return -1;
   cprintf("open file %s with mode ", path);
   if (omode & O_CREATE)
@@ -332,27 +310,27 @@ sys_open(void)
 
   begin_op();
 
-  if(omode & O_CREATE){
+  if (omode & O_CREATE) {
     ip = create(path, T_FILE, 0, 0);
-    if(ip == 0){
+    if (ip == 0) {
       end_op();
       return -1;
     }
   } else {
-    if((ip = namei(path)) == 0){
+    if ((ip = namei(path)) == 0) {
       end_op();
       return -1;
     }
     ilock(ip);
-    if(ip->type == T_DIR && omode != O_RDONLY){
+    if (ip->type == T_DIR && omode != O_RDONLY) {
       iunlockput(ip);
       end_op();
       return -1;
     }
   }
 
-  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
-    if(f)
+  if ((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0) {
+    if (f)
       fileclose(f);
     iunlockput(ip);
     end_op();
@@ -369,14 +347,12 @@ sys_open(void)
   return fd;
 }
 
-int
-sys_mkdir(void)
-{
+int sys_mkdir(void) {
   char *path;
   struct inode *ip;
 
   begin_op();
-  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
+  if (argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0) {
     end_op();
     return -1;
   }
@@ -386,42 +362,37 @@ sys_mkdir(void)
   return 0;
 }
 
-int
-sys_mknod(void)
-{
+int sys_mknod(void) {
   struct inode *ip;
   char *path;
   int major, minor;
 
   begin_op();
-  if((argstr(0, &path)) < 0 ||
-     argint(1, &major) < 0 ||
-     argint(2, &minor) < 0 ||
-     (ip = create(path, T_DEV, major, minor)) == 0){
+  if ((argstr(0, &path)) < 0 || argint(1, &major) < 0 ||
+      argint(2, &minor) < 0 || (ip = create(path, T_DEV, major, minor)) == 0) {
     end_op();
     return -1;
   }
-  cprintf("mknod creates file node %p on file path %s, major %d, minor %d\n", ip, path, major, minor);
+  cprintf("mknod creates file node %p on file path %s, major %d, minor %d\n",
+          ip, path, major, minor);
   iunlockput(ip);
   end_op();
   return 0;
 }
 
-int
-sys_chdir(void)
-{
+int sys_chdir(void) {
   char *path;
   struct inode *ip;
   struct proc *curproc = myproc();
-  
+
   begin_op();
-  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
+  if (argstr(0, &path) < 0 || (ip = namei(path)) == 0) {
     end_op();
     return -1;
   }
   cprintf("chdir change to %s\n", path);
   ilock(ip);
-  if(ip->type != T_DIR){
+  if (ip->type != T_DIR) {
     iunlockput(ip);
     end_op();
     return -1;
@@ -433,28 +404,26 @@ sys_chdir(void)
   return 0;
 }
 
-int
-sys_exec(void)
-{
+int sys_exec(void) {
   char *path, *argv[MAXARG];
   int i;
   uint uargv, uarg;
 
-  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
+  if (argstr(0, &path) < 0 || argint(1, (int *)&uargv) < 0) {
     return -1;
   }
   cprintf("exec will load %s with arguments:", path);
   memset(argv, 0, sizeof(argv));
-  for(i=0;; i++){
-    if(i >= NELEM(argv))
+  for (i = 0;; i++) {
+    if (i >= NELEM(argv))
       return -1;
-    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
+    if (fetchint(uargv + 4 * i, (int *)&uarg) < 0)
       return -1;
-    if(uarg == 0){
+    if (uarg == 0) {
       argv[i] = 0;
       break;
     }
-    if(fetchstr(uarg, &argv[i]) < 0)
+    if (fetchstr(uarg, &argv[i]) < 0)
       return -1;
     cprintf(" %s\n", argv[i]);
   }
@@ -462,21 +431,19 @@ sys_exec(void)
   return exec(path, argv);
 }
 
-int
-sys_pipe(void)
-{
+int sys_pipe(void) {
   int *fd;
   struct file *rf, *wf;
   int fd0, fd1;
 
-  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
+  if (argptr(0, (void *)&fd, 2 * sizeof(fd[0])) < 0)
     return -1;
   cprintf("pipe read end here: %p, write end here: %p\n", fd, fd + 1);
-  if(pipealloc(&rf, &wf) < 0)
+  if (pipealloc(&rf, &wf) < 0)
     return -1;
   fd0 = -1;
-  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
-    if(fd0 >= 0)
+  if ((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0) {
+    if (fd0 >= 0)
       myproc()->ofile[fd0] = 0;
     fileclose(rf);
     fileclose(wf);
diff --git a/sysproc.c b/sysproc.c
index e192bb6..1820a7a 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -7,77 +7,56 @@
 #include "mmu.h"
 #include "proc.h"
 
-int
-sys_fork(void)
-{
-  return fork();
-}
+int sys_fork(void) { return fork(); }
 
-int
-sys_exit(void)
-{
+int sys_exit(void) {
   exit();
-  return 0;  // not reached
+  return 0; // not reached
 }
 
-int
-sys_wait(void)
-{
-  return wait();
-}
+int sys_wait(void) { return wait(); }
 
-int
-sys_kill(void)
-{
+int sys_kill(void) {
   int pid;
 
-  if(argint(0, &pid) < 0)
+  if (argint(0, &pid) < 0)
     return -1;
   cprintf("kill pid: %d\n", pid);
   return kill(pid);
 }
 
-int
-sys_getpid(void)
-{
-  return myproc()->pid;
-}
+int sys_getpid(void) { return myproc()->pid; }
 
-int
-sys_sbrk(void)
-{
+int sys_sbrk(void) {
   int addr;
   int n;
 
-  if(argint(0, &n) < 0)
+  if (argint(0, &n) < 0)
     return -1;
   struct proc *curproc = myproc();
   addr = curproc->sz;
   cprintf("sbrk increments data size from 0x%x to 0x%x\n", addr, addr + n);
 
-  if (n < 0)
-  {
+  if (n < 0) {
     // shrink process address space
     deallocuvm(curproc->pgdir, addr, addr + n);
   }
   curproc->sz = addr + n;
-  
+
   return addr;
 }
 
-int
-sys_sleep(void)
-{
+int sys_sleep(void) {
   int n;
   uint ticks0;
 
-  if(argint(0, &n) < 0)
+  if (argint(0, &n) < 0)
     return -1;
   cprintf("sleep %d secs\n", n);
   acquire(&tickslock);
   ticks0 = ticks;
-  while(ticks - ticks0 < n){
-    if(myproc()->killed){
+  while (ticks - ticks0 < n) {
+    if (myproc()->killed) {
       release(&tickslock);
       return -1;
     }
@@ -89,9 +68,7 @@ sys_sleep(void)
 
 // return how many clock tick interrupts have occurred
 // since start.
-int
-sys_uptime(void)
-{
+int sys_uptime(void) {
   uint xticks;
 
   acquire(&tickslock);
@@ -100,20 +77,17 @@ sys_uptime(void)
   return xticks;
 }
 
-int
-sys_date(void)
-{
-    char *date;
-    if (argptr(0, &date, sizeof(struct rtcdate)) < 0)
-    {
-        return -1;
-    }
-    cprintf("syscall date got called with rtc struct on address %p\n", date);
-    struct rtcdate *rtc = (struct rtcdate *)date;
-    // fill in rtcdate
-    cmostime(rtc);
-    cprintf("UTC time:\n");
-    cprintf("%d-%d-%d %dh:%dm:%ds\n", rtc->year, rtc->month, rtc->day,
-      rtc->hour, rtc->minute, rtc->second);
-    return 0;
+int sys_date(void) {
+  char *date;
+  if (argptr(0, &date, sizeof(struct rtcdate)) < 0) {
+    return -1;
+  }
+  cprintf("syscall date got called with rtc struct on address %p\n", date);
+  struct rtcdate *rtc = (struct rtcdate *)date;
+  // fill in rtcdate
+  cmostime(rtc);
+  cprintf("UTC time:\n");
+  cprintf("%d-%d-%d %dh:%dm:%ds\n", rtc->year, rtc->month, rtc->day, rtc->hour,
+          rtc->minute, rtc->second);
+  return 0;
 }
diff --git a/trap.c b/trap.c
index 352f0b0..26af406 100644
--- a/trap.c
+++ b/trap.c
@@ -10,47 +10,39 @@
 
 // Interrupt descriptor table (shared by all CPUs).
 struct gatedesc idt[256];
-extern uint vectors[];  // in vectors.S: array of 256 entry pointers
+extern uint vectors[]; // in vectors.S: array of 256 entry pointers
 struct spinlock tickslock;
 uint ticks;
 extern int mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm);
 extern int hitguardpage(pte_t *pgdir, char *uva);
 
-void
-tvinit(void)
-{
+void tvinit(void) {
   int i;
 
-  for(i = 0; i < 256; i++)
-    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
-  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+  for (i = 0; i < 256; i++)
+    SETGATE(idt[i], 0, SEG_KCODE << 3, vectors[i], 0);
+  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE << 3, vectors[T_SYSCALL], DPL_USER);
 
   initlock(&tickslock, "time");
 }
 
-void
-idtinit(void)
-{
-  lidt(idt, sizeof(idt));
-}
+void idtinit(void) { lidt(idt, sizeof(idt)); }
 
-//PAGEBREAK: 41
-void
-trap(struct trapframe *tf)
-{
-  if(tf->trapno == T_SYSCALL){
-    if(myproc()->killed)
+// PAGEBREAK: 41
+void trap(struct trapframe *tf) {
+  if (tf->trapno == T_SYSCALL) {
+    if (myproc()->killed)
       exit();
-    myproc()->tf = tf;  // store user process current state
+    myproc()->tf = tf; // store user process current state
     syscall();
-    if(myproc()->killed)
+    if (myproc()->killed)
       exit();
     return;
   }
 
-  switch(tf->trapno){
+  switch (tf->trapno) {
   case T_IRQ0 + IRQ_TIMER:
-    if(cpuid() == 0){
+    if (cpuid() == 0) {
       acquire(&tickslock);
       ticks++;
       wakeup(&ticks);
@@ -62,7 +54,7 @@ trap(struct trapframe *tf)
     ideintr();
     lapiceoi();
     break;
-  case T_IRQ0 + IRQ_IDE+1:
+  case T_IRQ0 + IRQ_IDE + 1:
     // Bochs generates spurious IDE1 interrupts.
     break;
   case T_IRQ0 + IRQ_KBD:
@@ -75,69 +67,66 @@ trap(struct trapframe *tf)
     break;
   case T_IRQ0 + 7:
   case T_IRQ0 + IRQ_SPURIOUS:
-    cprintf("cpu%d: spurious interrupt at %x:%x\n",
-            cpuid(), tf->cs, tf->eip);
+    cprintf("cpu%d: spurious interrupt at %x:%x\n", cpuid(), tf->cs, tf->eip);
     lapiceoi();
     break;
-  case T_PGFLT:
-  {
-    if (rcr2() >= myproc()->sz)
-    {
-        // we don't allocate new memory for exceeding process size
-        // if we implement malloc then I guess we do not need this condition anymore?
-        cprintf("Invalid address 0x%x, will be panicked.\n", rcr2());
-        panic("Invalid address!\n");
+  case T_PGFLT: {
+    if (rcr2() >= myproc()->sz) {
+      // we don't allocate new memory for exceeding process size
+      // if we implement malloc then I guess we do not need this condition
+      // anymore?
+      cprintf("Invalid address 0x%x, will be panicked.\n", rcr2());
+      panic("Invalid address!\n");
     }
     // what if we use system call write to the guard page,
     // which we should not write to? we can check if PTE_U is enabled
     // we do not allocate memory for this area
-    if (hitguardpage(myproc()->pgdir, (char *)rcr2()))
-    {
+    if (hitguardpage(myproc()->pgdir, (char *)rcr2())) {
       panic("hitguardpage\n");
     }
 
     // find which page contains page fault virtual address with PGROUNDDOWN
     char *new_mem = kalloc();
-    if (new_mem == 0)
-    {
-        panic("Out of memory\n");
+    if (new_mem == 0) {
+      panic("Out of memory\n");
     }
     memset(new_mem, 0, PGSIZE);
     cprintf("page fault at address 0x%x, will be corrected.\n", rcr2());
     // lazy map to the allocated physical memory page with user R/W
-    mappages(myproc()->pgdir, (void *)PGROUNDDOWN(rcr2()), PGSIZE, V2P(new_mem), PTE_W | PTE_U);
+    mappages(myproc()->pgdir, (void *)PGROUNDDOWN(rcr2()), PGSIZE, V2P(new_mem),
+             PTE_W | PTE_U);
     break;
   }
 
-  //PAGEBREAK: 13
+  // PAGEBREAK: 13
   default:
-    if(myproc() == 0 || (tf->cs&3) == 0){
+    if (myproc() == 0 || (tf->cs & 3) == 0) {
       // In kernel, it must be our mistake.
-      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
-              tf->trapno, cpuid(), tf->eip, rcr2());
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n", tf->trapno,
+              cpuid(), tf->eip, rcr2());
       panic("trap");
     }
     // In user space, assume process misbehaved.
     cprintf("pid %d %s: trap %d err %d on cpu %d "
             "eip 0x%x addr 0x%x--kill proc\n",
-            myproc()->pid, myproc()->name, tf->trapno,
-            tf->err, cpuid(), tf->eip, rcr2());
+            myproc()->pid, myproc()->name, tf->trapno, tf->err, cpuid(),
+            tf->eip, rcr2());
     myproc()->killed = 1;
   }
 
   // Force process exit if it has been killed and is in user space.
   // (If it is still executing in the kernel, let it keep running
   // until it gets to the regular system call return.)
-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+  if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
     exit();
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(myproc() && myproc()->state == RUNNING &&
-     tf->trapno == T_IRQ0+IRQ_TIMER)
+  if (myproc() && myproc()->state == RUNNING &&
+      tf->trapno == T_IRQ0 + IRQ_TIMER)
     yield();
 
   // Check if the process has been killed since we yielded
-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+  if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
     exit();
 }
diff --git a/traps.h b/traps.h
index 0bd1fd8..887c2f4 100644
--- a/traps.h
+++ b/traps.h
@@ -1,38 +1,37 @@
 // x86 trap and interrupt constants.
 
 // Processor-defined:
-#define T_DIVIDE         0      // divide error
-#define T_DEBUG          1      // debug exception
-#define T_NMI            2      // non-maskable interrupt
-#define T_BRKPT          3      // breakpoint
-#define T_OFLOW          4      // overflow
-#define T_BOUND          5      // bounds check
-#define T_ILLOP          6      // illegal opcode
-#define T_DEVICE         7      // device not available
-#define T_DBLFLT         8      // double fault
+#define T_DIVIDE 0 // divide error
+#define T_DEBUG 1  // debug exception
+#define T_NMI 2    // non-maskable interrupt
+#define T_BRKPT 3  // breakpoint
+#define T_OFLOW 4  // overflow
+#define T_BOUND 5  // bounds check
+#define T_ILLOP 6  // illegal opcode
+#define T_DEVICE 7 // device not available
+#define T_DBLFLT 8 // double fault
 // #define T_COPROC      9      // reserved (not used since 486)
-#define T_TSS           10      // invalid task switch segment
-#define T_SEGNP         11      // segment not present
-#define T_STACK         12      // stack exception
-#define T_GPFLT         13      // general protection fault
-#define T_PGFLT         14      // page fault
+#define T_TSS 10   // invalid task switch segment
+#define T_SEGNP 11 // segment not present
+#define T_STACK 12 // stack exception
+#define T_GPFLT 13 // general protection fault
+#define T_PGFLT 14 // page fault
 // #define T_RES        15      // reserved
-#define T_FPERR         16      // floating point error
-#define T_ALIGN         17      // aligment check
-#define T_MCHK          18      // machine check
-#define T_SIMDERR       19      // SIMD floating point error
+#define T_FPERR 16   // floating point error
+#define T_ALIGN 17   // aligment check
+#define T_MCHK 18    // machine check
+#define T_SIMDERR 19 // SIMD floating point error
 
 // These are arbitrarily chosen, but with care not to overlap
 // processor defined exceptions or interrupt vectors.
-#define T_SYSCALL       64      // system call
-#define T_DEFAULT      500      // catchall
+#define T_SYSCALL 64  // system call
+#define T_DEFAULT 500 // catchall
 
-#define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ
-
-#define IRQ_TIMER        0
-#define IRQ_KBD          1
-#define IRQ_COM1         4
-#define IRQ_IDE         14
-#define IRQ_ERROR       19
-#define IRQ_SPURIOUS    31
+#define T_IRQ0 32 // IRQ 0 corresponds to int T_IRQ
 
+#define IRQ_TIMER 0
+#define IRQ_KBD 1
+#define IRQ_COM1 4
+#define IRQ_IDE 14
+#define IRQ_ERROR 19
+#define IRQ_SPURIOUS 31
diff --git a/types.h b/types.h
index e4adf64..3752a39 100644
--- a/types.h
+++ b/types.h
@@ -1,4 +1,4 @@
-typedef unsigned int   uint;
+typedef unsigned int uint;
 typedef unsigned short ushort;
-typedef unsigned char  uchar;
+typedef unsigned char uchar;
 typedef uint pde_t;
diff --git a/uart.c b/uart.c
index b8946da..ce2fb93 100644
--- a/uart.c
+++ b/uart.c
@@ -12,66 +12,56 @@
 #include "proc.h"
 #include "x86.h"
 
-#define COM1    0x3f8
+#define COM1 0x3f8
 
-static int uart;    // is there a uart?
+static int uart; // is there a uart?
 
-void
-uartinit(void)
-{
+void uartinit(void) {
   char *p;
 
   // Turn off the FIFO
-  outb(COM1+2, 0);
+  outb(COM1 + 2, 0);
 
   // 9600 baud, 8 data bits, 1 stop bit, parity off.
-  outb(COM1+3, 0x80);    // Unlock divisor
-  outb(COM1+0, 115200/9600);
-  outb(COM1+1, 0);
-  outb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
-  outb(COM1+4, 0);
-  outb(COM1+1, 0x01);    // Enable receive interrupts.
+  outb(COM1 + 3, 0x80); // Unlock divisor
+  outb(COM1 + 0, 115200 / 9600);
+  outb(COM1 + 1, 0);
+  outb(COM1 + 3, 0x03); // Lock divisor, 8 data bits.
+  outb(COM1 + 4, 0);
+  outb(COM1 + 1, 0x01); // Enable receive interrupts.
 
   // If status is 0xFF, no serial port.
-  if(inb(COM1+5) == 0xFF)
+  if (inb(COM1 + 5) == 0xFF)
     return;
   uart = 1;
 
   // Acknowledge pre-existing interrupt conditions;
   // enable interrupts.
-  inb(COM1+2);
-  inb(COM1+0);
+  inb(COM1 + 2);
+  inb(COM1 + 0);
   ioapicenable(IRQ_COM1, 0);
 
   // Announce that we're here.
-  for(p="xv6...\n"; *p; p++)
+  for (p = "xv6...\n"; *p; p++)
     uartputc(*p);
 }
 
-void
-uartputc(int c)
-{
+void uartputc(int c) {
   int i;
 
-  if(!uart)
+  if (!uart)
     return;
-  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
+  for (i = 0; i < 128 && !(inb(COM1 + 5) & 0x20); i++)
     microdelay(10);
-  outb(COM1+0, c);
+  outb(COM1 + 0, c);
 }
 
-static int
-uartgetc(void)
-{
-  if(!uart)
+static int uartgetc(void) {
+  if (!uart)
     return -1;
-  if(!(inb(COM1+5) & 0x01))
+  if (!(inb(COM1 + 5) & 0x01))
     return -1;
-  return inb(COM1+0);
+  return inb(COM1 + 0);
 }
 
-void
-uartintr(void)
-{
-  consoleintr(uartgetc);
-}
+void uartintr(void) { consoleintr(uartgetc); }
diff --git a/ulib.c b/ulib.c
index 8e1e1a2..90ed0f8 100644
--- a/ulib.c
+++ b/ulib.c
@@ -4,103 +4,85 @@
 #include "user.h"
 #include "x86.h"
 
-char*
-strcpy(char *s, const char *t)
-{
+char *strcpy(char *s, const char *t) {
   char *os;
 
   os = s;
-  while((*s++ = *t++) != 0)
+  while ((*s++ = *t++) != 0)
     ;
   return os;
 }
 
-int
-strcmp(const char *p, const char *q)
-{
-  while(*p && *p == *q)
+int strcmp(const char *p, const char *q) {
+  while (*p && *p == *q)
     p++, q++;
   return (uchar)*p - (uchar)*q;
 }
 
-uint
-strlen(const char *s)
-{
+uint strlen(const char *s) {
   int n;
 
-  for(n = 0; s[n]; n++)
+  for (n = 0; s[n]; n++)
     ;
   return n;
 }
 
-void*
-memset(void *dst, int c, uint n)
-{
+void *memset(void *dst, int c, uint n) {
   stosb(dst, c, n);
   return dst;
 }
 
-char*
-strchr(const char *s, char c)
-{
-  for(; *s; s++)
-    if(*s == c)
-      return (char*)s;
+char *strchr(const char *s, char c) {
+  for (; *s; s++)
+    if (*s == c)
+      return (char *)s;
   return 0;
 }
 
-char*
-gets(char *buf, int max)
-{
+char *gets(char *buf, int max) {
   int i, cc;
   char c;
 
-  for(i=0; i+1 < max; ){
+  for (i = 0; i + 1 < max;) {
     cc = read(0, &c, 1);
-    if(cc < 1)
+    if (cc < 1)
       break;
     buf[i++] = c;
-    if(c == '\n' || c == '\r')
+    if (c == '\n' || c == '\r')
       break;
   }
   buf[i] = '\0';
   return buf;
 }
 
-int
-stat(const char *n, struct stat *st)
-{
+int stat(const char *n, struct stat *st) {
   int fd;
   int r;
 
   fd = open(n, O_RDONLY);
-  if(fd < 0)
+  if (fd < 0)
     return -1;
   r = fstat(fd, st);
   close(fd);
   return r;
 }
 
-int
-atoi(const char *s)
-{
+int atoi(const char *s) {
   int n;
 
   n = 0;
-  while('0' <= *s && *s <= '9')
-    n = n*10 + *s++ - '0';
+  while ('0' <= *s && *s <= '9')
+    n = n * 10 + *s++ - '0';
   return n;
 }
 
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
+void *memmove(void *vdst, const void *vsrc, int n) {
   char *dst;
   const char *src;
 
   dst = vdst;
   src = vsrc;
-  while(n-- > 0)
+  while (n-- > 0)
     *dst++ = *src++;
   return vdst;
 }
diff --git a/umalloc.c b/umalloc.c
index a7e7d2c..489d8d8 100644
--- a/umalloc.c
+++ b/umalloc.c
@@ -21,21 +21,19 @@ typedef union header Header;
 static Header base;
 static Header *freep;
 
-void
-free(void *ap)
-{
+void free(void *ap) {
   Header *bp, *p;
 
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+  bp = (Header *)ap - 1;
+  for (p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    if (p >= p->s.ptr && (bp > p || bp < p->s.ptr))
       break;
-  if(bp + bp->s.size == p->s.ptr){
+  if (bp + bp->s.size == p->s.ptr) {
     bp->s.size += p->s.ptr->s.size;
     bp->s.ptr = p->s.ptr->s.ptr;
   } else
     bp->s.ptr = p->s.ptr;
-  if(p + p->s.size == bp){
+  if (p + p->s.size == bp) {
     p->s.size += bp->s.size;
     p->s.ptr = bp->s.ptr;
   } else
@@ -43,37 +41,33 @@ free(void *ap)
   freep = p;
 }
 
-static Header*
-morecore(uint nu)
-{
+static Header *morecore(uint nu) {
   char *p;
   Header *hp;
 
-  if(nu < 4096)
+  if (nu < 4096)
     nu = 4096;
   p = sbrk(nu * sizeof(Header));
-  if(p == (char*)-1)
+  if (p == (char *)-1)
     return 0;
-  hp = (Header*)p;
+  hp = (Header *)p;
   hp->s.size = nu;
-  free((void*)(hp + 1));
+  free((void *)(hp + 1));
   return freep;
 }
 
-void*
-malloc(uint nbytes)
-{
+void *malloc(uint nbytes) {
   Header *p, *prevp;
   uint nunits;
 
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
-  if((prevp = freep) == 0){
+  nunits = (nbytes + sizeof(Header) - 1) / sizeof(Header) + 1;
+  if ((prevp = freep) == 0) {
     base.s.ptr = freep = prevp = &base;
     base.s.size = 0;
   }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
-    if(p->s.size >= nunits){
-      if(p->s.size == nunits)
+  for (p = prevp->s.ptr;; prevp = p, p = p->s.ptr) {
+    if (p->s.size >= nunits) {
+      if (p->s.size == nunits)
         prevp->s.ptr = p->s.ptr;
       else {
         p->s.size -= nunits;
@@ -81,10 +75,10 @@ malloc(uint nbytes)
         p->s.size = nunits;
       }
       freep = prevp;
-      return (void*)(p + 1);
+      return (void *)(p + 1);
     }
-    if(p == freep)
-      if((p = morecore(nunits)) == 0)
+    if (p == freep)
+      if ((p = morecore(nunits)) == 0)
         return 0;
   }
 }
diff --git a/user.h b/user.h
index eb2a141..aa406ed 100644
--- a/user.h
+++ b/user.h
@@ -5,37 +5,37 @@ struct rtcdate;
 int fork(void);
 int exit(void) __attribute__((noreturn));
 int wait(void);
-int pipe(int*);
-int write(int, const void*, int);
-int read(int, void*, int);
+int pipe(int *);
+int write(int, const void *, int);
+int read(int, void *, int);
 int close(int);
 int kill(int);
-int exec(char*, char**);
-int open(const char*, int);
-int mknod(const char*, short, short);
-int unlink(const char*);
-int fstat(int fd, struct stat*);
-int link(const char*, const char*);
-int mkdir(const char*);
-int chdir(const char*);
+int exec(char *, char **);
+int open(const char *, int);
+int mknod(const char *, short, short);
+int unlink(const char *);
+int fstat(int fd, struct stat *);
+int link(const char *, const char *);
+int mkdir(const char *);
+int chdir(const char *);
 int dup(int);
 int dup2(int, int);
 int getpid(void);
-char* sbrk(int);
+char *sbrk(int);
 int sleep(int);
 int uptime(void);
-int date(struct rtcdate*);
+int date(struct rtcdate *);
 
 // ulib.c
-int stat(const char*, struct stat*);
-char* strcpy(char*, const char*);
-void *memmove(void*, const void*, int);
-char* strchr(const char*, char c);
-int strcmp(const char*, const char*);
-void printf(int, const char*, ...);
-char* gets(char*, int max);
-uint strlen(const char*);
-void* memset(void*, int, uint);
-void* malloc(uint);
-void free(void*);
-int atoi(const char*);
+int stat(const char *, struct stat *);
+char *strcpy(char *, const char *);
+void *memmove(void *, const void *, int);
+char *strchr(const char *, char c);
+int strcmp(const char *, const char *);
+void printf(int, const char *, ...);
+char *gets(char *, int max);
+uint strlen(const char *);
+void *memset(void *, int, uint);
+void *malloc(uint);
+void free(void *);
+int atoi(const char *);
diff --git a/usertests.c b/usertests.c
index a1e97e7..70f9504 100644
--- a/usertests.c
+++ b/usertests.c
@@ -10,28 +10,26 @@
 
 char buf[8192];
 char name[3];
-char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };
+char *echoargv[] = {"echo", "ALL", "TESTS", "PASSED", 0};
 int stdout = 1;
 
 // does chdir() call iput(p->cwd) in a transaction?
-void
-iputtest(void)
-{
+void iputtest(void) {
   printf(stdout, "iput test\n");
 
-  if(mkdir("iputdir") < 0){
+  if (mkdir("iputdir") < 0) {
     printf(stdout, "mkdir failed\n");
     exit();
   }
-  if(chdir("iputdir") < 0){
+  if (chdir("iputdir") < 0) {
     printf(stdout, "chdir iputdir failed\n");
     exit();
   }
-  if(unlink("../iputdir") < 0){
+  if (unlink("../iputdir") < 0) {
     printf(stdout, "unlink ../iputdir failed\n");
     exit();
   }
-  if(chdir("/") < 0){
+  if (chdir("/") < 0) {
     printf(stdout, "chdir / failed\n");
     exit();
   }
@@ -39,28 +37,26 @@ iputtest(void)
 }
 
 // does exit() call iput(p->cwd) in a transaction?
-void
-exitiputtest(void)
-{
+void exitiputtest(void) {
   int pid;
 
   printf(stdout, "exitiput test\n");
 
   pid = fork();
-  if(pid < 0){
+  if (pid < 0) {
     printf(stdout, "fork failed\n");
     exit();
   }
-  if(pid == 0){
-    if(mkdir("iputdir") < 0){
+  if (pid == 0) {
+    if (mkdir("iputdir") < 0) {
       printf(stdout, "mkdir failed\n");
       exit();
     }
-    if(chdir("iputdir") < 0){
+    if (chdir("iputdir") < 0) {
       printf(stdout, "child chdir failed\n");
       exit();
     }
-    if(unlink("../iputdir") < 0){
+    if (unlink("../iputdir") < 0) {
       printf(stdout, "unlink ../iputdir failed\n");
       exit();
     }
@@ -81,31 +77,29 @@ exitiputtest(void)
 //      for(i = 0; i < 10000; i++)
 //        yield();
 //    }
-void
-openiputtest(void)
-{
+void openiputtest(void) {
   int pid;
 
   printf(stdout, "openiput test\n");
-  if(mkdir("oidir") < 0){
+  if (mkdir("oidir") < 0) {
     printf(stdout, "mkdir oidir failed\n");
     exit();
   }
   pid = fork();
-  if(pid < 0){
+  if (pid < 0) {
     printf(stdout, "fork failed\n");
     exit();
   }
-  if(pid == 0){
+  if (pid == 0) {
     int fd = open("oidir", O_RDWR);
-    if(fd >= 0){
+    if (fd >= 0) {
       printf(stdout, "open directory for write succeeded\n");
       exit();
     }
     exit();
   }
   sleep(1);
-  if(unlink("oidir") != 0){
+  if (unlink("oidir") != 0) {
     printf(stdout, "unlink failed\n");
     exit();
   }
@@ -115,46 +109,42 @@ openiputtest(void)
 
 // simple file system tests
 
-void
-opentest(void)
-{
+void opentest(void) {
   int fd;
 
   printf(stdout, "open test\n");
   fd = open("echo", 0);
-  if(fd < 0){
+  if (fd < 0) {
     printf(stdout, "open echo failed!\n");
     exit();
   }
   close(fd);
   fd = open("doesnotexist", 0);
-  if(fd >= 0){
+  if (fd >= 0) {
     printf(stdout, "open doesnotexist succeeded!\n");
     exit();
   }
   printf(stdout, "open test ok\n");
 }
 
-void
-writetest(void)
-{
+void writetest(void) {
   int fd;
   int i;
 
   printf(stdout, "small file test\n");
-  fd = open("small", O_CREATE|O_RDWR);
-  if(fd >= 0){
+  fd = open("small", O_CREATE | O_RDWR);
+  if (fd >= 0) {
     printf(stdout, "creat small succeeded; ok\n");
   } else {
     printf(stdout, "error: creat small failed!\n");
     exit();
   }
-  for(i = 0; i < 100; i++){
-    if(write(fd, "aaaaaaaaaa", 10) != 10){
+  for (i = 0; i < 100; i++) {
+    if (write(fd, "aaaaaaaaaa", 10) != 10) {
       printf(stdout, "error: write aa %d new file failed\n", i);
       exit();
     }
-    if(write(fd, "bbbbbbbbbb", 10) != 10){
+    if (write(fd, "bbbbbbbbbb", 10) != 10) {
       printf(stdout, "error: write bb %d new file failed\n", i);
       exit();
     }
@@ -162,14 +152,14 @@ writetest(void)
   printf(stdout, "writes ok\n");
   close(fd);
   fd = open("small", O_RDONLY);
-  if(fd >= 0){
+  if (fd >= 0) {
     printf(stdout, "open small succeeded ok\n");
   } else {
     printf(stdout, "error: open small failed!\n");
     exit();
   }
   i = read(fd, buf, 2000);
-  if(i == 2000){
+  if (i == 2000) {
     printf(stdout, "read succeeded ok\n");
   } else {
     printf(stdout, "read failed\n");
@@ -177,29 +167,27 @@ writetest(void)
   }
   close(fd);
 
-  if(unlink("small") < 0){
+  if (unlink("small") < 0) {
     printf(stdout, "unlink small failed\n");
     exit();
   }
   printf(stdout, "small file test ok\n");
 }
 
-void
-writetest1(void)
-{
+void writetest1(void) {
   int i, fd, n;
 
   printf(stdout, "big files test\n");
 
-  fd = open("big", O_CREATE|O_RDWR);
-  if(fd < 0){
+  fd = open("big", O_CREATE | O_RDWR);
+  if (fd < 0) {
     printf(stdout, "error: creat big failed!\n");
     exit();
   }
 
-  for(i = 0; i < MAXFILE; i++){
-    ((int*)buf)[0] = i;
-    if(write(fd, buf, 512) != 512){
+  for (i = 0; i < MAXFILE; i++) {
+    ((int *)buf)[0] = i;
+    if (write(fd, buf, 512) != 512) {
       printf(stdout, "error: write big file failed\n", i);
       exit();
     }
@@ -208,93 +196,87 @@ writetest1(void)
   close(fd);
 
   fd = open("big", O_RDONLY);
-  if(fd < 0){
+  if (fd < 0) {
     printf(stdout, "error: open big failed!\n");
     exit();
   }
 
   n = 0;
-  for(;;){
+  for (;;) {
     i = read(fd, buf, 512);
-    if(i == 0){
-      if(n == MAXFILE - 1){
+    if (i == 0) {
+      if (n == MAXFILE - 1) {
         printf(stdout, "read only %d blocks from big", n);
         exit();
       }
       break;
-    } else if(i != 512){
+    } else if (i != 512) {
       printf(stdout, "read failed %d\n", i);
       exit();
     }
-    if(((int*)buf)[0] != n){
-      printf(stdout, "read content of block %d is %d\n",
-             n, ((int*)buf)[0]);
+    if (((int *)buf)[0] != n) {
+      printf(stdout, "read content of block %d is %d\n", n, ((int *)buf)[0]);
       exit();
     }
     n++;
   }
   close(fd);
-  if(unlink("big") < 0){
+  if (unlink("big") < 0) {
     printf(stdout, "unlink big failed\n");
     exit();
   }
   printf(stdout, "big files ok\n");
 }
 
-void
-createtest(void)
-{
+void createtest(void) {
   int i, fd;
 
   printf(stdout, "many creates, followed by unlink test\n");
 
   name[0] = 'a';
   name[2] = '\0';
-  for(i = 0; i < 52; i++){
+  for (i = 0; i < 52; i++) {
     name[1] = '0' + i;
-    fd = open(name, O_CREATE|O_RDWR);
+    fd = open(name, O_CREATE | O_RDWR);
     close(fd);
   }
   name[0] = 'a';
   name[2] = '\0';
-  for(i = 0; i < 52; i++){
+  for (i = 0; i < 52; i++) {
     name[1] = '0' + i;
     unlink(name);
   }
   printf(stdout, "many creates, followed by unlink; ok\n");
 }
 
-void dirtest(void)
-{
+void dirtest(void) {
   printf(stdout, "mkdir test\n");
 
-  if(mkdir("dir0") < 0){
+  if (mkdir("dir0") < 0) {
     printf(stdout, "mkdir failed\n");
     exit();
   }
 
-  if(chdir("dir0") < 0){
+  if (chdir("dir0") < 0) {
     printf(stdout, "chdir dir0 failed\n");
     exit();
   }
 
-  if(chdir("..") < 0){
+  if (chdir("..") < 0) {
     printf(stdout, "chdir .. failed\n");
     exit();
   }
 
-  if(unlink("dir0") < 0){
+  if (unlink("dir0") < 0) {
     printf(stdout, "unlink dir0 failed\n");
     exit();
   }
   printf(stdout, "mkdir test ok\n");
 }
 
-void
-exectest(void)
-{
+void exectest(void) {
   printf(stdout, "exec test\n");
-  if(exec("echo", echoargv) < 0){
+  if (exec("echo", echoargv) < 0) {
     printf(stdout, "exec echo failed\n");
     exit();
   }
@@ -302,46 +284,44 @@ exectest(void)
 
 // simple fork and pipe read/write
 
-void
-pipe1(void)
-{
+void pipe1(void) {
   int fds[2], pid;
   int seq, i, n, cc, total;
 
-  if(pipe(fds) != 0){
+  if (pipe(fds) != 0) {
     printf(1, "pipe() failed\n");
     exit();
   }
   pid = fork();
   seq = 0;
-  if(pid == 0){
+  if (pid == 0) {
     close(fds[0]);
-    for(n = 0; n < 5; n++){
-      for(i = 0; i < 1033; i++)
+    for (n = 0; n < 5; n++) {
+      for (i = 0; i < 1033; i++)
         buf[i] = seq++;
-      if(write(fds[1], buf, 1033) != 1033){
+      if (write(fds[1], buf, 1033) != 1033) {
         printf(1, "pipe1 oops 1\n");
         exit();
       }
     }
     exit();
-  } else if(pid > 0){
+  } else if (pid > 0) {
     close(fds[1]);
     total = 0;
     cc = 1;
-    while((n = read(fds[0], buf, cc)) > 0){
-      for(i = 0; i < n; i++){
-        if((buf[i] & 0xff) != (seq++ & 0xff)){
+    while ((n = read(fds[0], buf, cc)) > 0) {
+      for (i = 0; i < n; i++) {
+        if ((buf[i] & 0xff) != (seq++ & 0xff)) {
           printf(1, "pipe1 oops 2\n");
           return;
         }
       }
       total += n;
       cc = cc * 2;
-      if(cc > sizeof(buf))
+      if (cc > sizeof(buf))
         cc = sizeof(buf);
     }
-    if(total != 5 * 1033){
+    if (total != 5 * 1033) {
       printf(1, "pipe1 oops 3 total %d\n", total);
       exit();
     }
@@ -355,36 +335,34 @@ pipe1(void)
 }
 
 // meant to be run w/ at most two CPUs
-void
-preempt(void)
-{
+void preempt(void) {
   int pid1, pid2, pid3;
   int pfds[2];
 
   printf(1, "preempt: ");
   pid1 = fork();
-  if(pid1 == 0)
-    for(;;)
+  if (pid1 == 0)
+    for (;;)
       ;
 
   pid2 = fork();
-  if(pid2 == 0)
-    for(;;)
+  if (pid2 == 0)
+    for (;;)
       ;
 
   pipe(pfds);
   pid3 = fork();
-  if(pid3 == 0){
+  if (pid3 == 0) {
     close(pfds[0]);
-    if(write(pfds[1], "x", 1) != 1)
+    if (write(pfds[1], "x", 1) != 1)
       printf(1, "preempt write error");
     close(pfds[1]);
-    for(;;)
+    for (;;)
       ;
   }
 
   close(pfds[1]);
-  if(read(pfds[0], buf, sizeof(buf)) != 1){
+  if (read(pfds[0], buf, sizeof(buf)) != 1) {
     printf(1, "preempt read error");
     return;
   }
@@ -401,19 +379,17 @@ preempt(void)
 }
 
 // try to find any races between exit and wait
-void
-exitwait(void)
-{
+void exitwait(void) {
   int i, pid;
 
-  for(i = 0; i < 100; i++){
+  for (i = 0; i < 100; i++) {
     pid = fork();
-    if(pid < 0){
+    if (pid < 0) {
       printf(1, "fork failed\n");
       return;
     }
-    if(pid){
-      if(wait() != pid){
+    if (pid) {
+      if (wait() != pid) {
         printf(1, "wait wrong pid\n");
         return;
       }
@@ -424,27 +400,25 @@ exitwait(void)
   printf(1, "exitwait ok\n");
 }
 
-void
-mem(void)
-{
+void mem(void) {
   void *m1, *m2;
   int pid, ppid;
 
   printf(1, "mem test\n");
   ppid = getpid();
-  if((pid = fork()) == 0){
+  if ((pid = fork()) == 0) {
     m1 = 0;
-    while((m2 = malloc(10001)) != 0){
-      *(char**)m2 = m1;
+    while ((m2 = malloc(10001)) != 0) {
+      *(char **)m2 = m1;
       m1 = m2;
     }
-    while(m1){
-      m2 = *(char**)m1;
+    while (m1) {
+      m2 = *(char **)m1;
       free(m1);
       m1 = m2;
     }
-    m1 = malloc(1024*20);
-    if(m1 == 0){
+    m1 = malloc(1024 * 20);
+    if (m1 == 0) {
       printf(1, "couldn't allocate mem?!!\n");
       kill(ppid);
       exit();
@@ -461,50 +435,48 @@ mem(void)
 
 // two processes write to the same file descriptor
 // is the offset shared? does inode locking work?
-void
-sharedfd(void)
-{
+void sharedfd(void) {
   int fd, pid, i, n, nc, np;
   char buf[10];
 
   printf(1, "sharedfd test\n");
 
   unlink("sharedfd");
-  fd = open("sharedfd", O_CREATE|O_RDWR);
-  if(fd < 0){
+  fd = open("sharedfd", O_CREATE | O_RDWR);
+  if (fd < 0) {
     printf(1, "fstests: cannot open sharedfd for writing");
     return;
   }
   pid = fork();
-  memset(buf, pid==0?'c':'p', sizeof(buf));
-  for(i = 0; i < 1000; i++){
-    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+  memset(buf, pid == 0 ? 'c' : 'p', sizeof(buf));
+  for (i = 0; i < 1000; i++) {
+    if (write(fd, buf, sizeof(buf)) != sizeof(buf)) {
       printf(1, "fstests: write sharedfd failed\n");
       break;
     }
   }
-  if(pid == 0)
+  if (pid == 0)
     exit();
   else
     wait();
   close(fd);
   fd = open("sharedfd", 0);
-  if(fd < 0){
+  if (fd < 0) {
     printf(1, "fstests: cannot open sharedfd for reading\n");
     return;
   }
   nc = np = 0;
-  while((n = read(fd, buf, sizeof(buf))) > 0){
-    for(i = 0; i < sizeof(buf); i++){
-      if(buf[i] == 'c')
+  while ((n = read(fd, buf, sizeof(buf))) > 0) {
+    for (i = 0; i < sizeof(buf); i++) {
+      if (buf[i] == 'c')
         nc++;
-      if(buf[i] == 'p')
+      if (buf[i] == 'p')
         np++;
     }
   }
   close(fd);
   unlink("sharedfd");
-  if(nc == 10000 && np == 10000){
+  if (nc == 10000 && np == 10000) {
     printf(1, "sharedfd ok\n");
   } else {
     printf(1, "sharedfd oops %d %d\n", nc, np);
@@ -514,35 +486,33 @@ sharedfd(void)
 
 // four processes write different files at the same
 // time, to test block allocation.
-void
-fourfiles(void)
-{
+void fourfiles(void) {
   int fd, pid, i, j, n, total, pi;
-  char *names[] = { "f0", "f1", "f2", "f3" };
+  char *names[] = {"f0", "f1", "f2", "f3"};
   char *fname;
 
   printf(1, "fourfiles test\n");
 
-  for(pi = 0; pi < 4; pi++){
+  for (pi = 0; pi < 4; pi++) {
     fname = names[pi];
     unlink(fname);
 
     pid = fork();
-    if(pid < 0){
+    if (pid < 0) {
       printf(1, "fork failed\n");
       exit();
     }
 
-    if(pid == 0){
+    if (pid == 0) {
       fd = open(fname, O_CREATE | O_RDWR);
-      if(fd < 0){
+      if (fd < 0) {
         printf(1, "create failed\n");
         exit();
       }
 
-      memset(buf, '0'+pi, 512);
-      for(i = 0; i < 12; i++){
-        if((n = write(fd, buf, 500)) != 500){
+      memset(buf, '0' + pi, 512);
+      for (i = 0; i < 12; i++) {
+        if ((n = write(fd, buf, 500)) != 500) {
           printf(1, "write failed %d\n", n);
           exit();
         }
@@ -551,17 +521,17 @@ fourfiles(void)
     }
   }
 
-  for(pi = 0; pi < 4; pi++){
+  for (pi = 0; pi < 4; pi++) {
     wait();
   }
 
-  for(i = 0; i < 2; i++){
+  for (i = 0; i < 2; i++) {
     fname = names[i];
     fd = open(fname, 0);
     total = 0;
-    while((n = read(fd, buf, sizeof(buf))) > 0){
-      for(j = 0; j < n; j++){
-        if(buf[j] != '0'+i){
+    while ((n = read(fd, buf, sizeof(buf))) > 0) {
+      for (j = 0; j < n; j++) {
+        if (buf[j] != '0' + i) {
           printf(1, "wrong char\n");
           exit();
         }
@@ -569,7 +539,7 @@ fourfiles(void)
       total += n;
     }
     close(fd);
-    if(total != 12*500){
+    if (total != 12 * 500) {
       printf(1, "wrong length %d\n", total);
       exit();
     }
@@ -580,36 +550,34 @@ fourfiles(void)
 }
 
 // four processes create and delete different files in same directory
-void
-createdelete(void)
-{
+void createdelete(void) {
   enum { N = 20 };
   int pid, i, fd, pi;
   char name[32];
 
   printf(1, "createdelete test\n");
 
-  for(pi = 0; pi < 4; pi++){
+  for (pi = 0; pi < 4; pi++) {
     pid = fork();
-    if(pid < 0){
+    if (pid < 0) {
       printf(1, "fork failed\n");
       exit();
     }
 
-    if(pid == 0){
+    if (pid == 0) {
       name[0] = 'p' + pi;
       name[2] = '\0';
-      for(i = 0; i < N; i++){
+      for (i = 0; i < N; i++) {
         name[1] = '0' + i;
         fd = open(name, O_CREATE | O_RDWR);
-        if(fd < 0){
+        if (fd < 0) {
           printf(1, "create failed\n");
           exit();
         }
         close(fd);
-        if(i > 0 && (i % 2 ) == 0){
+        if (i > 0 && (i % 2) == 0) {
           name[1] = '0' + (i / 2);
-          if(unlink(name) < 0){
+          if (unlink(name) < 0) {
             printf(1, "unlink failed\n");
             exit();
           }
@@ -619,30 +587,30 @@ createdelete(void)
     }
   }
 
-  for(pi = 0; pi < 4; pi++){
+  for (pi = 0; pi < 4; pi++) {
     wait();
   }
 
   name[0] = name[1] = name[2] = 0;
-  for(i = 0; i < N; i++){
-    for(pi = 0; pi < 4; pi++){
+  for (i = 0; i < N; i++) {
+    for (pi = 0; pi < 4; pi++) {
       name[0] = 'p' + pi;
       name[1] = '0' + i;
       fd = open(name, 0);
-      if((i == 0 || i >= N/2) && fd < 0){
+      if ((i == 0 || i >= N / 2) && fd < 0) {
         printf(1, "oops createdelete %s didn't exist\n", name);
         exit();
-      } else if((i >= 1 && i < N/2) && fd >= 0){
+      } else if ((i >= 1 && i < N / 2) && fd >= 0) {
         printf(1, "oops createdelete %s did exist\n", name);
         exit();
       }
-      if(fd >= 0)
+      if (fd >= 0)
         close(fd);
     }
   }
 
-  for(i = 0; i < N; i++){
-    for(pi = 0; pi < 4; pi++){
+  for (i = 0; i < N; i++) {
+    for (pi = 0; pi < 4; pi++) {
       name[0] = 'p' + i;
       name[1] = '0' + i;
       unlink(name);
@@ -653,14 +621,12 @@ createdelete(void)
 }
 
 // can I unlink a file and still read it?
-void
-unlinkread(void)
-{
+void unlinkread(void) {
   int fd, fd1;
 
   printf(1, "unlinkread test\n");
   fd = open("unlinkread", O_CREATE | O_RDWR);
-  if(fd < 0){
+  if (fd < 0) {
     printf(1, "create unlinkread failed\n");
     exit();
   }
@@ -668,11 +634,11 @@ unlinkread(void)
   close(fd);
 
   fd = open("unlinkread", O_RDWR);
-  if(fd < 0){
+  if (fd < 0) {
     printf(1, "open unlinkread failed\n");
     exit();
   }
-  if(unlink("unlinkread") != 0){
+  if (unlink("unlinkread") != 0) {
     printf(1, "unlink unlinkread failed\n");
     exit();
   }
@@ -681,15 +647,15 @@ unlinkread(void)
   write(fd1, "yyy", 3);
   close(fd1);
 
-  if(read(fd, buf, sizeof(buf)) != 5){
+  if (read(fd, buf, sizeof(buf)) != 5) {
     printf(1, "unlinkread read failed");
     exit();
   }
-  if(buf[0] != 'h'){
+  if (buf[0] != 'h') {
     printf(1, "unlinkread wrong data\n");
     exit();
   }
-  if(write(fd, buf, 10) != 10){
+  if (write(fd, buf, 10) != 10) {
     printf(1, "unlinkread write failed\n");
     exit();
   }
@@ -698,9 +664,7 @@ unlinkread(void)
   printf(1, "unlinkread ok\n");
 }
 
-void
-linktest(void)
-{
+void linktest(void) {
   int fd;
 
   printf(1, "linktest\n");
@@ -708,51 +672,51 @@ linktest(void)
   unlink("lf1");
   unlink("lf2");
 
-  fd = open("lf1", O_CREATE|O_RDWR);
-  if(fd < 0){
+  fd = open("lf1", O_CREATE | O_RDWR);
+  if (fd < 0) {
     printf(1, "create lf1 failed\n");
     exit();
   }
-  if(write(fd, "hello", 5) != 5){
+  if (write(fd, "hello", 5) != 5) {
     printf(1, "write lf1 failed\n");
     exit();
   }
   close(fd);
 
-  if(link("lf1", "lf2") < 0){
+  if (link("lf1", "lf2") < 0) {
     printf(1, "link lf1 lf2 failed\n");
     exit();
   }
   unlink("lf1");
 
-  if(open("lf1", 0) >= 0){
+  if (open("lf1", 0) >= 0) {
     printf(1, "unlinked lf1 but it is still there!\n");
     exit();
   }
 
   fd = open("lf2", 0);
-  if(fd < 0){
+  if (fd < 0) {
     printf(1, "open lf2 failed\n");
     exit();
   }
-  if(read(fd, buf, sizeof(buf)) != 5){
+  if (read(fd, buf, sizeof(buf)) != 5) {
     printf(1, "read lf2 failed\n");
     exit();
   }
   close(fd);
 
-  if(link("lf2", "lf2") >= 0){
+  if (link("lf2", "lf2") >= 0) {
     printf(1, "link lf2 lf2 succeeded! oops\n");
     exit();
   }
 
   unlink("lf2");
-  if(link("lf2", "lf1") >= 0){
+  if (link("lf2", "lf1") >= 0) {
     printf(1, "link non-existant succeeded! oops\n");
     exit();
   }
 
-  if(link(".", "lf1") >= 0){
+  if (link(".", "lf1") >= 0) {
     printf(1, "link . lf1 succeeded! oops\n");
     exit();
   }
@@ -761,9 +725,7 @@ linktest(void)
 }
 
 // test concurrent create/link/unlink of the same file
-void
-concreate(void)
-{
+void concreate(void) {
   char file[3];
   int i, pid, n, fd;
   char fa[40];
@@ -775,23 +737,23 @@ concreate(void)
   printf(1, "concreate test\n");
   file[0] = 'C';
   file[2] = '\0';
-  for(i = 0; i < 40; i++){
+  for (i = 0; i < 40; i++) {
     file[1] = '0' + i;
     unlink(file);
     pid = fork();
-    if(pid && (i % 3) == 1){
+    if (pid && (i % 3) == 1) {
       link("C0", file);
-    } else if(pid == 0 && (i % 5) == 1){
+    } else if (pid == 0 && (i % 5) == 1) {
       link("C0", file);
     } else {
       fd = open(file, O_CREATE | O_RDWR);
-      if(fd < 0){
+      if (fd < 0) {
         printf(1, "concreate create %s failed\n", file);
         exit();
       }
       close(fd);
     }
-    if(pid == 0)
+    if (pid == 0)
       exit();
     else
       wait();
@@ -800,16 +762,16 @@ concreate(void)
   memset(fa, 0, sizeof(fa));
   fd = open(".", 0);
   n = 0;
-  while(read(fd, &de, sizeof(de)) > 0){
-    if(de.inum == 0)
+  while (read(fd, &de, sizeof(de)) > 0) {
+    if (de.inum == 0)
       continue;
-    if(de.name[0] == 'C' && de.name[2] == '\0'){
+    if (de.name[0] == 'C' && de.name[2] == '\0') {
       i = de.name[1] - '0';
-      if(i < 0 || i >= sizeof(fa)){
+      if (i < 0 || i >= sizeof(fa)) {
         printf(1, "concreate weird file %s\n", de.name);
         exit();
       }
-      if(fa[i]){
+      if (fa[i]) {
         printf(1, "concreate duplicate file %s\n", de.name);
         exit();
       }
@@ -819,20 +781,19 @@ concreate(void)
   }
   close(fd);
 
-  if(n != 40){
+  if (n != 40) {
     printf(1, "concreate not enough files in directory listing\n");
     exit();
   }
 
-  for(i = 0; i < 40; i++){
+  for (i = 0; i < 40; i++) {
     file[1] = '0' + i;
     pid = fork();
-    if(pid < 0){
+    if (pid < 0) {
       printf(1, "fork failed\n");
       exit();
     }
-    if(((i % 3) == 0 && pid == 0) ||
-       ((i % 3) == 1 && pid != 0)){
+    if (((i % 3) == 0 && pid == 0) || ((i % 3) == 1 && pid != 0)) {
       close(open(file, 0));
       close(open(file, 0));
       close(open(file, 0));
@@ -843,7 +804,7 @@ concreate(void)
       unlink(file);
       unlink(file);
     }
-    if(pid == 0)
+    if (pid == 0)
       exit();
     else
       wait();
@@ -854,33 +815,31 @@ concreate(void)
 
 // another concurrent link/unlink/create test,
 // to look for deadlocks.
-void
-linkunlink()
-{
+void linkunlink() {
   int pid, i;
 
   printf(1, "linkunlink test\n");
 
   unlink("x");
   pid = fork();
-  if(pid < 0){
+  if (pid < 0) {
     printf(1, "fork failed\n");
     exit();
   }
 
   unsigned int x = (pid ? 1 : 97);
-  for(i = 0; i < 100; i++){
+  for (i = 0; i < 100; i++) {
     x = x * 1103515245 + 12345;
-    if((x % 3) == 0){
+    if ((x % 3) == 0) {
       close(open("x", O_RDWR | O_CREATE));
-    } else if((x % 3) == 1){
+    } else if ((x % 3) == 1) {
       link("cat", "x");
     } else {
       unlink("x");
     }
   }
 
-  if(pid)
+  if (pid)
     wait();
   else
     exit();
@@ -889,9 +848,7 @@ linkunlink()
 }
 
 // directory that uses indirect blocks
-void
-bigdir(void)
-{
+void bigdir(void) {
   int i, fd;
   char name[10];
 
@@ -899,30 +856,30 @@ bigdir(void)
   unlink("bd");
 
   fd = open("bd", O_CREATE);
-  if(fd < 0){
+  if (fd < 0) {
     printf(1, "bigdir create failed\n");
     exit();
   }
   close(fd);
 
-  for(i = 0; i < 500; i++){
+  for (i = 0; i < 500; i++) {
     name[0] = 'x';
     name[1] = '0' + (i / 64);
     name[2] = '0' + (i % 64);
     name[3] = '\0';
-    if(link("bd", name) != 0){
+    if (link("bd", name) != 0) {
       printf(1, "bigdir link failed\n");
       exit();
     }
   }
 
   unlink("bd");
-  for(i = 0; i < 500; i++){
+  for (i = 0; i < 500; i++) {
     name[0] = 'x';
     name[1] = '0' + (i / 64);
     name[2] = '0' + (i % 64);
     name[3] = '\0';
-    if(unlink(name) != 0){
+    if (unlink(name) != 0) {
       printf(1, "bigdir unlink failed");
       exit();
     }
@@ -931,39 +888,37 @@ bigdir(void)
   printf(1, "bigdir ok\n");
 }
 
-void
-subdir(void)
-{
+void subdir(void) {
   int fd, cc;
 
   printf(1, "subdir test\n");
 
   unlink("ff");
-  if(mkdir("dd") != 0){
+  if (mkdir("dd") != 0) {
     printf(1, "subdir mkdir dd failed\n");
     exit();
   }
 
   fd = open("dd/ff", O_CREATE | O_RDWR);
-  if(fd < 0){
+  if (fd < 0) {
     printf(1, "create dd/ff failed\n");
     exit();
   }
   write(fd, "ff", 2);
   close(fd);
 
-  if(unlink("dd") >= 0){
+  if (unlink("dd") >= 0) {
     printf(1, "unlink dd (non-empty dir) succeeded!\n");
     exit();
   }
 
-  if(mkdir("/dd/dd") != 0){
+  if (mkdir("/dd/dd") != 0) {
     printf(1, "subdir mkdir dd/dd failed\n");
     exit();
   }
 
   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
-  if(fd < 0){
+  if (fd < 0) {
     printf(1, "create dd/dd/ff failed\n");
     exit();
   }
@@ -971,142 +926,142 @@ subdir(void)
   close(fd);
 
   fd = open("dd/dd/../ff", 0);
-  if(fd < 0){
+  if (fd < 0) {
     printf(1, "open dd/dd/../ff failed\n");
     exit();
   }
   cc = read(fd, buf, sizeof(buf));
-  if(cc != 2 || buf[0] != 'f'){
+  if (cc != 2 || buf[0] != 'f') {
     printf(1, "dd/dd/../ff wrong content\n");
     exit();
   }
   close(fd);
 
-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+  if (link("dd/dd/ff", "dd/dd/ffff") != 0) {
     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
     exit();
   }
 
-  if(unlink("dd/dd/ff") != 0){
+  if (unlink("dd/dd/ff") != 0) {
     printf(1, "unlink dd/dd/ff failed\n");
     exit();
   }
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
+  if (open("dd/dd/ff", O_RDONLY) >= 0) {
     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
     exit();
   }
 
-  if(chdir("dd") != 0){
+  if (chdir("dd") != 0) {
     printf(1, "chdir dd failed\n");
     exit();
   }
-  if(chdir("dd/../../dd") != 0){
+  if (chdir("dd/../../dd") != 0) {
     printf(1, "chdir dd/../../dd failed\n");
     exit();
   }
-  if(chdir("dd/../../../dd") != 0){
+  if (chdir("dd/../../../dd") != 0) {
     printf(1, "chdir dd/../../dd failed\n");
     exit();
   }
-  if(chdir("./..") != 0){
+  if (chdir("./..") != 0) {
     printf(1, "chdir ./.. failed\n");
     exit();
   }
 
   fd = open("dd/dd/ffff", 0);
-  if(fd < 0){
+  if (fd < 0) {
     printf(1, "open dd/dd/ffff failed\n");
     exit();
   }
-  if(read(fd, buf, sizeof(buf)) != 2){
+  if (read(fd, buf, sizeof(buf)) != 2) {
     printf(1, "read dd/dd/ffff wrong len\n");
     exit();
   }
   close(fd);
 
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
+  if (open("dd/dd/ff", O_RDONLY) >= 0) {
     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
     exit();
   }
 
-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+  if (open("dd/ff/ff", O_CREATE | O_RDWR) >= 0) {
     printf(1, "create dd/ff/ff succeeded!\n");
     exit();
   }
-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+  if (open("dd/xx/ff", O_CREATE | O_RDWR) >= 0) {
     printf(1, "create dd/xx/ff succeeded!\n");
     exit();
   }
-  if(open("dd", O_CREATE) >= 0){
+  if (open("dd", O_CREATE) >= 0) {
     printf(1, "create dd succeeded!\n");
     exit();
   }
-  if(open("dd", O_RDWR) >= 0){
+  if (open("dd", O_RDWR) >= 0) {
     printf(1, "open dd rdwr succeeded!\n");
     exit();
   }
-  if(open("dd", O_WRONLY) >= 0){
+  if (open("dd", O_WRONLY) >= 0) {
     printf(1, "open dd wronly succeeded!\n");
     exit();
   }
-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
+  if (link("dd/ff/ff", "dd/dd/xx") == 0) {
     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
     exit();
   }
-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
+  if (link("dd/xx/ff", "dd/dd/xx") == 0) {
     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
     exit();
   }
-  if(link("dd/ff", "dd/dd/ffff") == 0){
+  if (link("dd/ff", "dd/dd/ffff") == 0) {
     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
     exit();
   }
-  if(mkdir("dd/ff/ff") == 0){
+  if (mkdir("dd/ff/ff") == 0) {
     printf(1, "mkdir dd/ff/ff succeeded!\n");
     exit();
   }
-  if(mkdir("dd/xx/ff") == 0){
+  if (mkdir("dd/xx/ff") == 0) {
     printf(1, "mkdir dd/xx/ff succeeded!\n");
     exit();
   }
-  if(mkdir("dd/dd/ffff") == 0){
+  if (mkdir("dd/dd/ffff") == 0) {
     printf(1, "mkdir dd/dd/ffff succeeded!\n");
     exit();
   }
-  if(unlink("dd/xx/ff") == 0){
+  if (unlink("dd/xx/ff") == 0) {
     printf(1, "unlink dd/xx/ff succeeded!\n");
     exit();
   }
-  if(unlink("dd/ff/ff") == 0){
+  if (unlink("dd/ff/ff") == 0) {
     printf(1, "unlink dd/ff/ff succeeded!\n");
     exit();
   }
-  if(chdir("dd/ff") == 0){
+  if (chdir("dd/ff") == 0) {
     printf(1, "chdir dd/ff succeeded!\n");
     exit();
   }
-  if(chdir("dd/xx") == 0){
+  if (chdir("dd/xx") == 0) {
     printf(1, "chdir dd/xx succeeded!\n");
     exit();
   }
 
-  if(unlink("dd/dd/ffff") != 0){
+  if (unlink("dd/dd/ffff") != 0) {
     printf(1, "unlink dd/dd/ff failed\n");
     exit();
   }
-  if(unlink("dd/ff") != 0){
+  if (unlink("dd/ff") != 0) {
     printf(1, "unlink dd/ff failed\n");
     exit();
   }
-  if(unlink("dd") == 0){
+  if (unlink("dd") == 0) {
     printf(1, "unlink non-empty dd succeeded!\n");
     exit();
   }
-  if(unlink("dd/dd") < 0){
+  if (unlink("dd/dd") < 0) {
     printf(1, "unlink dd/dd failed\n");
     exit();
   }
-  if(unlink("dd") < 0){
+  if (unlink("dd") < 0) {
     printf(1, "unlink dd failed\n");
     exit();
   }
@@ -1115,24 +1070,22 @@ subdir(void)
 }
 
 // test writes that are larger than the log.
-void
-bigwrite(void)
-{
+void bigwrite(void) {
   int fd, sz;
 
   printf(1, "bigwrite test\n");
 
   unlink("bigwrite");
-  for(sz = 499; sz < 12*512; sz += 471){
+  for (sz = 499; sz < 12 * 512; sz += 471) {
     fd = open("bigwrite", O_CREATE | O_RDWR);
-    if(fd < 0){
+    if (fd < 0) {
       printf(1, "cannot create bigwrite\n");
       exit();
     }
     int i;
-    for(i = 0; i < 2; i++){
+    for (i = 0; i < 2; i++) {
       int cc = write(fd, buf, sz);
-      if(cc != sz){
+      if (cc != sz) {
         printf(1, "write(%d) ret %d\n", sz, cc);
         exit();
       }
@@ -1144,22 +1097,20 @@ bigwrite(void)
   printf(1, "bigwrite ok\n");
 }
 
-void
-bigfile(void)
-{
+void bigfile(void) {
   int fd, i, total, cc;
 
   printf(1, "bigfile test\n");
 
   unlink("bigfile");
   fd = open("bigfile", O_CREATE | O_RDWR);
-  if(fd < 0){
+  if (fd < 0) {
     printf(1, "cannot create bigfile");
     exit();
   }
-  for(i = 0; i < 20; i++){
+  for (i = 0; i < 20; i++) {
     memset(buf, i, 600);
-    if(write(fd, buf, 600) != 600){
+    if (write(fd, buf, 600) != 600) {
       printf(1, "write bigfile failed\n");
       exit();
     }
@@ -1167,31 +1118,31 @@ bigfile(void)
   close(fd);
 
   fd = open("bigfile", 0);
-  if(fd < 0){
+  if (fd < 0) {
     printf(1, "cannot open bigfile\n");
     exit();
   }
   total = 0;
-  for(i = 0; ; i++){
+  for (i = 0;; i++) {
     cc = read(fd, buf, 300);
-    if(cc < 0){
+    if (cc < 0) {
       printf(1, "read bigfile failed\n");
       exit();
     }
-    if(cc == 0)
+    if (cc == 0)
       break;
-    if(cc != 300){
+    if (cc != 300) {
       printf(1, "short read bigfile\n");
       exit();
     }
-    if(buf[0] != i/2 || buf[299] != i/2){
+    if (buf[0] != i / 2 || buf[299] != i / 2) {
       printf(1, "read bigfile wrong data\n");
       exit();
     }
     total += cc;
   }
   close(fd);
-  if(total != 20*600){
+  if (total != 20 * 600) {
     printf(1, "read bigfile wrong total\n");
     exit();
   }
@@ -1200,40 +1151,39 @@ bigfile(void)
   printf(1, "bigfile test ok\n");
 }
 
-void
-fourteen(void)
-{
+void fourteen(void) {
   int fd;
 
   // DIRSIZ is 14.
   printf(1, "fourteen test\n");
 
-  if(mkdir("12345678901234") != 0){
+  if (mkdir("12345678901234") != 0) {
     printf(1, "mkdir 12345678901234 failed\n");
     exit();
   }
-  if(mkdir("12345678901234/123456789012345") != 0){
+  if (mkdir("12345678901234/123456789012345") != 0) {
     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
     exit();
   }
   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
-  if(fd < 0){
-    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+  if (fd < 0) {
+    printf(1,
+           "create 123456789012345/123456789012345/123456789012345 failed\n");
     exit();
   }
   close(fd);
   fd = open("12345678901234/12345678901234/12345678901234", 0);
-  if(fd < 0){
+  if (fd < 0) {
     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
     exit();
   }
   close(fd);
 
-  if(mkdir("12345678901234/12345678901234") == 0){
+  if (mkdir("12345678901234/12345678901234") == 0) {
     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
     exit();
   }
-  if(mkdir("123456789012345/12345678901234") == 0){
+  if (mkdir("123456789012345/12345678901234") == 0) {
     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
     exit();
   }
@@ -1241,96 +1191,92 @@ fourteen(void)
   printf(1, "fourteen ok\n");
 }
 
-void
-rmdot(void)
-{
+void rmdot(void) {
   printf(1, "rmdot test\n");
-  if(mkdir("dots") != 0){
+  if (mkdir("dots") != 0) {
     printf(1, "mkdir dots failed\n");
     exit();
   }
-  if(chdir("dots") != 0){
+  if (chdir("dots") != 0) {
     printf(1, "chdir dots failed\n");
     exit();
   }
-  if(unlink(".") == 0){
+  if (unlink(".") == 0) {
     printf(1, "rm . worked!\n");
     exit();
   }
-  if(unlink("..") == 0){
+  if (unlink("..") == 0) {
     printf(1, "rm .. worked!\n");
     exit();
   }
-  if(chdir("/") != 0){
+  if (chdir("/") != 0) {
     printf(1, "chdir / failed\n");
     exit();
   }
-  if(unlink("dots/.") == 0){
+  if (unlink("dots/.") == 0) {
     printf(1, "unlink dots/. worked!\n");
     exit();
   }
-  if(unlink("dots/..") == 0){
+  if (unlink("dots/..") == 0) {
     printf(1, "unlink dots/.. worked!\n");
     exit();
   }
-  if(unlink("dots") != 0){
+  if (unlink("dots") != 0) {
     printf(1, "unlink dots failed!\n");
     exit();
   }
   printf(1, "rmdot ok\n");
 }
 
-void
-dirfile(void)
-{
+void dirfile(void) {
   int fd;
 
   printf(1, "dir vs file\n");
 
   fd = open("dirfile", O_CREATE);
-  if(fd < 0){
+  if (fd < 0) {
     printf(1, "create dirfile failed\n");
     exit();
   }
   close(fd);
-  if(chdir("dirfile") == 0){
+  if (chdir("dirfile") == 0) {
     printf(1, "chdir dirfile succeeded!\n");
     exit();
   }
   fd = open("dirfile/xx", 0);
-  if(fd >= 0){
+  if (fd >= 0) {
     printf(1, "create dirfile/xx succeeded!\n");
     exit();
   }
   fd = open("dirfile/xx", O_CREATE);
-  if(fd >= 0){
+  if (fd >= 0) {
     printf(1, "create dirfile/xx succeeded!\n");
     exit();
   }
-  if(mkdir("dirfile/xx") == 0){
+  if (mkdir("dirfile/xx") == 0) {
     printf(1, "mkdir dirfile/xx succeeded!\n");
     exit();
   }
-  if(unlink("dirfile/xx") == 0){
+  if (unlink("dirfile/xx") == 0) {
     printf(1, "unlink dirfile/xx succeeded!\n");
     exit();
   }
-  if(link("README", "dirfile/xx") == 0){
+  if (link("README", "dirfile/xx") == 0) {
     printf(1, "link to dirfile/xx succeeded!\n");
     exit();
   }
-  if(unlink("dirfile") != 0){
+  if (unlink("dirfile") != 0) {
     printf(1, "unlink dirfile failed!\n");
     exit();
   }
 
   fd = open(".", O_RDWR);
-  if(fd >= 0){
+  if (fd >= 0) {
     printf(1, "open . for writing succeeded!\n");
     exit();
   }
   fd = open(".", 0);
-  if(write(fd, "x", 1) > 0){
+  if (write(fd, "x", 1) > 0) {
     printf(1, "write . succeeded!\n");
     exit();
   }
@@ -1340,20 +1286,18 @@ dirfile(void)
 }
 
 // test that iput() is called at the end of _namei()
-void
-iref(void)
-{
+void iref(void) {
   int i, fd;
 
   printf(1, "empty file name\n");
 
   // the 50 is NINODE
-  for(i = 0; i < 50 + 1; i++){
-    if(mkdir("irefd") != 0){
+  for (i = 0; i < 50 + 1; i++) {
+    if (mkdir("irefd") != 0) {
       printf(1, "mkdir irefd failed\n");
       exit();
     }
-    if(chdir("irefd") != 0){
+    if (chdir("irefd") != 0) {
       printf(1, "chdir irefd failed\n");
       exit();
     }
@@ -1361,10 +1305,10 @@ iref(void)
     mkdir("");
     link("README", "");
     fd = open("", O_CREATE);
-    if(fd >= 0)
+    if (fd >= 0)
       close(fd);
     fd = open("xx", O_CREATE);
-    if(fd >= 0)
+    if (fd >= 0)
       close(fd);
     unlink("xx");
   }
@@ -1376,34 +1320,32 @@ iref(void)
 // test that fork fails gracefully
 // the forktest binary also does this, but it runs out of proc entries first.
 // inside the bigger usertests binary, we run out of memory first.
-void
-forktest(void)
-{
+void forktest(void) {
   int n, pid;
 
   printf(1, "fork test\n");
 
-  for(n=0; n<1000; n++){
+  for (n = 0; n < 1000; n++) {
     pid = fork();
-    if(pid < 0)
+    if (pid < 0)
       break;
-    if(pid == 0)
+    if (pid == 0)
       exit();
   }
 
-  if(n == 1000){
+  if (n == 1000) {
     printf(1, "fork claimed to work 1000 times!\n");
     exit();
   }
 
-  for(; n > 0; n--){
-    if(wait() < 0){
+  for (; n > 0; n--) {
+    if (wait() < 0) {
       printf(1, "wait stopped early\n");
       exit();
     }
   }
 
-  if(wait() != -1){
+  if (wait() != -1) {
     printf(1, "wait got too many\n");
     exit();
   }
@@ -1411,9 +1353,7 @@ forktest(void)
   printf(1, "fork test OK\n");
 }
 
-void
-sbrktest(void)
-{
+void sbrktest(void) {
   int fds[2], pid, pids[10], ppid;
   char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
   uint amt;
@@ -1424,9 +1364,9 @@ sbrktest(void)
   // can one sbrk() less than a page?
   a = sbrk(0);
   int i;
-  for(i = 0; i < 5000; i++){
+  for (i = 0; i < 5000; i++) {
     b = sbrk(1);
-    if(b != a){
+    if (b != a) {
       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
       exit();
     }
@@ -1434,53 +1374,55 @@ sbrktest(void)
     a = b + 1;
   }
   pid = fork();
-  if(pid < 0){
+  if (pid < 0) {
     printf(stdout, "sbrk test fork failed\n");
     exit();
   }
   c = sbrk(1);
   c = sbrk(1);
-  if(c != a + 1){
+  if (c != a + 1) {
     printf(stdout, "sbrk test failed post-fork\n");
     exit();
   }
-  if(pid == 0)
+  if (pid == 0)
     exit();
   wait();
 
   // can one grow address space to something big?
-#define BIG (100*1024*1024)
+#define BIG (100 * 1024 * 1024)
   a = sbrk(0);
   amt = (BIG) - (uint)a;
   p = sbrk(amt);
   if (p != a) {
-    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+    printf(stdout,
+           "sbrk test failed to grow big address space; enough phys mem?\n");
     exit();
   }
-  lastaddr = (char*) (BIG-1);
+  lastaddr = (char *)(BIG - 1);
   *lastaddr = 99;
 
   // can one de-allocate?
   a = sbrk(0);
   c = sbrk(-4096);
-  if(c == (char*)0xffffffff){
+  if (c == (char *)0xffffffff) {
     printf(stdout, "sbrk could not deallocate\n");
     exit();
   }
   c = sbrk(0);
-  if(c != a - 4096){
-    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+  if (c != a - 4096) {
+    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a,
+           c);
     exit();
   }
 
   // can one re-allocate that page?
   a = sbrk(0);
   c = sbrk(4096);
-  if(c != a || sbrk(0) != a + 4096){
+  if (c != a || sbrk(0) != a + 4096) {
     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
     exit();
   }
-  if(*lastaddr == 99){
+  if (*lastaddr == 99) {
     // should be zero
     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
     exit();
@@ -1488,20 +1430,20 @@ sbrktest(void)
 
   a = sbrk(0);
   c = sbrk(-(sbrk(0) - oldbrk));
-  if(c != a){
+  if (c != a) {
     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
     exit();
   }
 
   // can we read the kernel's memory?
-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+  for (a = (char *)(KERNBASE); a < (char *)(KERNBASE + 2000000); a += 50000) {
     ppid = getpid();
     pid = fork();
-    if(pid < 0){
+    if (pid < 0) {
       printf(stdout, "fork failed\n");
       exit();
     }
-    if(pid == 0){
+    if (pid == 0) {
       printf(stdout, "oops could read %x = %x\n", a, *a);
       kill(ppid);
       exit();
@@ -1511,67 +1453,64 @@ sbrktest(void)
 
   // if we run the system out of memory, does it clean up the last
   // failed allocation?
-  if(pipe(fds) != 0){
+  if (pipe(fds) != 0) {
     printf(1, "pipe() failed\n");
     exit();
   }
-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-    if((pids[i] = fork()) == 0){
+  for (i = 0; i < sizeof(pids) / sizeof(pids[0]); i++) {
+    if ((pids[i] = fork()) == 0) {
       // allocate a lot of memory
       sbrk(BIG - (uint)sbrk(0));
       write(fds[1], "x", 1);
       // sit around until killed
-      for(;;) sleep(1000);
+      for (;;)
+        sleep(1000);
     }
-    if(pids[i] != -1)
+    if (pids[i] != -1)
       read(fds[0], &scratch, 1);
   }
   // if those failed allocations freed up the pages they did allocate,
   // we'll be able to allocate here
   c = sbrk(4096);
-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-    if(pids[i] == -1)
+  for (i = 0; i < sizeof(pids) / sizeof(pids[0]); i++) {
+    if (pids[i] == -1)
       continue;
     kill(pids[i]);
     wait();
   }
-  if(c == (char*)0xffffffff){
+  if (c == (char *)0xffffffff) {
     printf(stdout, "failed sbrk leaked memory\n");
     exit();
   }
 
-  if(sbrk(0) > oldbrk)
+  if (sbrk(0) > oldbrk)
     sbrk(-(sbrk(0) - oldbrk));
 
   printf(stdout, "sbrk test OK\n");
 }
 
-void
-validateint(int *p)
-{
+void validateint(int *p) {
   int res;
   asm("mov %%esp, %%ebx\n\t"
       "mov %3, %%esp\n\t"
       "int %2\n\t"
-      "mov %%ebx, %%esp" :
-      "=a" (res) :
-      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
-      "ebx");
+      "mov %%ebx, %%esp"
+      : "=a"(res)
+      : "a"(SYS_sleep), "n"(T_SYSCALL), "c"(p)
+      : "ebx");
 }
 
-void
-validatetest(void)
-{
+void validatetest(void) {
   int hi, pid;
   uint p;
 
   printf(stdout, "validate test\n");
-  hi = 1100*1024;
+  hi = 1100 * 1024;
 
-  for(p = 0; p <= (uint)hi; p += 4096){
-    if((pid = fork()) == 0){
+  for (p = 0; p <= (uint)hi; p += 4096) {
+    if ((pid = fork()) == 0) {
       // try to crash the kernel by passing in a badly placed integer
-      validateint((int*)p);
+      validateint((int *)p);
       exit();
     }
     sleep(0);
@@ -1580,7 +1519,7 @@ validatetest(void)
     wait();
 
     // try to crash the kernel by passing in a bad string pointer
-    if(link("nosuchfile", (char*)p) != -1){
+    if (link("nosuchfile", (char *)p) != -1) {
       printf(stdout, "link should not succeed\n");
       exit();
     }
@@ -1591,14 +1530,12 @@ validatetest(void)
 
 // does unintialized data start out zero?
 char uninit[10000];
-void
-bsstest(void)
-{
+void bsstest(void) {
   int i;
 
   printf(stdout, "bss test\n");
-  for(i = 0; i < sizeof(uninit); i++){
-    if(uninit[i] != '\0'){
+  for (i = 0; i < sizeof(uninit); i++) {
+    if (uninit[i] != '\0') {
       printf(stdout, "bss test failed\n");
       exit();
     }
@@ -1609,32 +1546,33 @@ bsstest(void)
 // does exec return an error if the arguments
 // are larger than a page? or does it write
 // below the stack and wreck the instructions/data?
-void
-bigargtest(void)
-{
+void bigargtest(void) {
   int pid, fd;
 
   unlink("bigarg-ok");
   pid = fork();
-  if(pid == 0){
+  if (pid == 0) {
     static char *args[MAXARG];
     int i;
-    for(i = 0; i < MAXARG-1; i++)
-      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
-    args[MAXARG-1] = 0;
+    for (i = 0; i < MAXARG - 1; i++)
+      args[i] = "bigargs test: failed\n                                        "
+                "                                                              "
+                "                                                              "
+                "                                   ";
+    args[MAXARG - 1] = 0;
     printf(stdout, "bigarg test\n");
     exec("echo", args);
     printf(stdout, "bigarg test ok\n");
     fd = open("bigarg-ok", O_CREATE);
     close(fd);
     exit();
-  } else if(pid < 0){
+  } else if (pid < 0) {
     printf(stdout, "bigargtest: fork failed\n");
     exit();
   }
   wait();
   fd = open("bigarg-ok", 0);
-  if(fd < 0){
+  if (fd < 0) {
     printf(stdout, "bigarg test failed!\n");
     exit();
   }
@@ -1644,15 +1582,13 @@ bigargtest(void)
 
 // what happens when the file system runs out of blocks?
 // answer: balloc panics, so this test is not useful.
-void
-fsfull()
-{
+void fsfull() {
   int nfiles;
   int fsblocks = 0;
 
   printf(1, "fsfull test\n");
 
-  for(nfiles = 0; ; nfiles++){
+  for (nfiles = 0;; nfiles++) {
     char name[64];
     name[0] = 'f';
     name[1] = '0' + nfiles / 1000;
@@ -1661,26 +1597,26 @@ fsfull()
     name[4] = '0' + (nfiles % 10);
     name[5] = '\0';
     printf(1, "writing %s\n", name);
-    int fd = open(name, O_CREATE|O_RDWR);
-    if(fd < 0){
+    int fd = open(name, O_CREATE | O_RDWR);
+    if (fd < 0) {
       printf(1, "open %s failed\n", name);
       break;
     }
     int total = 0;
-    while(1){
+    while (1) {
       int cc = write(fd, buf, 512);
-      if(cc < 512)
+      if (cc < 512)
         break;
       total += cc;
       fsblocks++;
     }
     printf(1, "wrote %d bytes\n", total);
     close(fd);
-    if(total == 0)
+    if (total == 0)
       break;
   }
 
-  while(nfiles >= 0){
+  while (nfiles >= 0) {
     char name[64];
     name[0] = 'f';
     name[1] = '0' + nfiles / 1000;
@@ -1695,11 +1631,9 @@ fsfull()
   printf(1, "fsfull test finished\n");
 }
 
-void
-uio()
-{
-  #define RTC_ADDR 0x70
-  #define RTC_DATA 0x71
+void uio() {
+#define RTC_ADDR 0x70
+#define RTC_DATA 0x71
 
   ushort port = 0;
   uchar val = 0;
@@ -1707,25 +1641,24 @@ uio()
 
   printf(1, "uio test\n");
   pid = fork();
-  if(pid == 0){
+  if (pid == 0) {
     port = RTC_ADDR;
-    val = 0x09;  /* year */
+    val = 0x09; /* year */
     /* http://wiki.osdev.org/Inline_Assembly/Examples */
-    asm volatile("outb %0,%1"::"a"(val), "d" (port));
+    asm volatile("outb %0,%1" ::"a"(val), "d"(port));
     port = RTC_DATA;
-    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+    asm volatile("inb %1,%0" : "=a"(val) : "d"(port));
     printf(1, "uio: uio succeeded; test FAILED\n");
     exit();
-  } else if(pid < 0){
-    printf (1, "fork failed\n");
+  } else if (pid < 0) {
+    printf(1, "fork failed\n");
     exit();
   }
   wait();
   printf(1, "uio test done\n");
 }
 
-void argptest()
-{
+void argptest() {
   int fd;
   fd = open("init", O_RDONLY);
   if (fd < 0) {
@@ -1738,19 +1671,15 @@ void argptest()
 }
 
 unsigned long randstate = 1;
-unsigned int
-rand()
-{
+unsigned int rand() {
   randstate = randstate * 1664525 + 1013904223;
   return randstate;
 }
 
-int
-main(int argc, char *argv[])
-{
+int main(int argc, char *argv[]) {
   printf(1, "usertests starting\n");
 
-  if(open("usertests.ran", 0) >= 0){
+  if (open("usertests.ran", 0) >= 0) {
     printf(1, "already ran user tests -- rebuild fs.img\n");
     exit();
   }
diff --git a/vm.c b/vm.c
index ed5497b..f2c46d7 100644
--- a/vm.c
+++ b/vm.c
@@ -7,14 +7,12 @@
 #include "proc.h"
 #include "elf.h"
 
-extern char data[];  // defined by kernel.ld
-pde_t *kpgdir;  // for use in scheduler()
+extern char data[]; // defined by kernel.ld
+pde_t *kpgdir;      // for use in scheduler()
 
 // Set up CPU's kernel segment descriptors.
 // Run once on entry on each CPU.
-void
-seginit(void)
-{
+void seginit(void) {
   struct cpu *c;
 
   // Map "logical" addresses to virtual addresses using identity map.
@@ -22,9 +20,9 @@ seginit(void)
   // because it would have to have DPL_USR, but the CPU forbids
   // an interrupt from CPL=0 to DPL=3.
   c = &cpus[cpuid()];
-  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+  c->gdt[SEG_KCODE] = SEG(STA_X | STA_R, 0, 0xffffffff, 0);
   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
-  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+  c->gdt[SEG_UCODE] = SEG(STA_X | STA_R, 0, 0xffffffff, DPL_USER);
   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
   lgdt(c->gdt, sizeof(c->gdt));
 }
@@ -32,17 +30,15 @@ seginit(void)
 // Return the address of the PTE in page table pgdir
 // that corresponds to virtual address va.  If alloc!=0,
 // create any required page table pages.
-static pte_t *
-walkpgdir(pde_t *pgdir, const void *va, int alloc)
-{
+static pte_t *walkpgdir(pde_t *pgdir, const void *va, int alloc) {
   pde_t *pde;
   pte_t *pgtab;
 
   pde = &pgdir[PDX(va)];
-  if(*pde & PTE_P){
-    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+  if (*pde & PTE_P) {
+    pgtab = (pte_t *)P2V(PTE_ADDR(*pde));
   } else {
-    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+    if (!alloc || (pgtab = (pte_t *)kalloc()) == 0)
       return 0;
     // Make sure all those PTE_P bits are zero.
     memset(pgtab, 0, PGSIZE);
@@ -57,21 +53,19 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
 // Create PTEs for virtual addresses starting at va that refer to
 // physical addresses starting at pa. va and size might not
 // be page-aligned.
-int
-mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
-{
+int mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm) {
   char *a, *last;
   pte_t *pte;
 
-  a = (char*)PGROUNDDOWN((uint)va);
-  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
-  for(;;){
-    if((pte = walkpgdir(pgdir, a, 1)) == 0)
+  a = (char *)PGROUNDDOWN((uint)va);
+  last = (char *)PGROUNDDOWN(((uint)va) + size - 1);
+  for (;;) {
+    if ((pte = walkpgdir(pgdir, a, 1)) == 0)
       return -1;
-    if(*pte & PTE_P)
+    if (*pte & PTE_P)
       panic("remap");
     *pte = pa | perm | PTE_P;
-    if(a == last)
+    if (a == last)
       break;
     a += PGSIZE;
     pa += PGSIZE;
@@ -108,16 +102,14 @@ static struct kmap {
   uint phys_end;
   int perm;
 } kmap[] = {
- { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
- { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
- { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
- { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
+    {(void *)KERNBASE, 0, EXTMEM, PTE_W},            // I/O space
+    {(void *)KERNLINK, V2P(KERNLINK), V2P(data), 0}, // kern text+rodata
+    {(void *)data, V2P(data), PHYSTOP, PTE_W},       // kern data+memory
+    {(void *)DEVSPACE, DEVSPACE, 0, PTE_W},          // more devices
 };
 
 // Set up kernel part of a page table.
-pde_t*
-setupkvm(void)
-{
+pde_t *setupkvm(void) {
   if (!kpgdir)
     panic("where is kernel pgdir?\n");
   pde_t *pgdir;
@@ -127,12 +119,10 @@ setupkvm(void)
   // copy pdes from kernel page directory
   // only copy needed ones, we don't do memmove
   struct kmap *k;
-  for (k = kmap; k < &kmap[NELEM(kmap)]; k++)
-  {
+  for (k = kmap; k < &kmap[NELEM(kmap)]; k++) {
     uint sz = k->phys_end - k->phys_start, i;
     uint end = sz >> PDXSHIFT;
-    for (i = 0; i <= end; i++)
-    {
+    for (i = 0; i <= end; i++) {
       int idx = PDX(k->virt) + i;
       if (idx < NPDENTRIES)
         pgdir[idx] = kpgdir[idx];
@@ -145,18 +135,16 @@ setupkvm(void)
 
 // Allocate one page table for the machine for the kernel address
 // space for scheduler processes.
-void
-kvmalloc(void)
-{
+void kvmalloc(void) {
   struct kmap *k;
-  if((kpgdir = (pde_t*)kalloc()) == 0)
+  if ((kpgdir = (pde_t *)kalloc()) == 0)
     panic("kvmalloc");
   memset(kpgdir, 0, PGSIZE);
-  if (P2V(PHYSTOP) > (void*)DEVSPACE)
+  if (P2V(PHYSTOP) > (void *)DEVSPACE)
     panic("PHYSTOP too high");
-  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
-    if(mappages(kpgdir, k->virt, k->phys_end - k->phys_start,
-                (uint)k->phys_start, k->perm) < 0) {
+  for (k = kmap; k < &kmap[NELEM(kmap)]; k++)
+    if (mappages(kpgdir, k->virt, k->phys_end - k->phys_start,
+                 (uint)k->phys_start, k->perm) < 0) {
       freevm(kpgdir);
     }
   switchkvm();
@@ -164,71 +152,63 @@ kvmalloc(void)
 
 // Switch h/w page table register to the kernel-only page table,
 // for when no process is running.
-void
-switchkvm(void)
-{
-  lcr3(V2P(kpgdir));   // switch to the kernel page table
+void switchkvm(void) {
+  lcr3(V2P(kpgdir)); // switch to the kernel page table
 }
 
 // Switch TSS and h/w page table to correspond to process p.
-void
-switchuvm(struct proc *p)
-{
-  if(p == 0)
+void switchuvm(struct proc *p) {
+  if (p == 0)
     panic("switchuvm: no process");
-  if(p->kstack == 0)
+  if (p->kstack == 0)
     panic("switchuvm: no kstack");
-  if(p->pgdir == 0)
+  if (p->pgdir == 0)
     panic("switchuvm: no pgdir");
 
   pushcli();
-  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
-                                sizeof(mycpu()->ts)-1, 0);
+  mycpu()->gdt[SEG_TSS] =
+      SEG16(STS_T32A, &mycpu()->ts, sizeof(mycpu()->ts) - 1, 0);
   mycpu()->gdt[SEG_TSS].s = 0;
   mycpu()->ts.ss0 = SEG_KDATA << 3;
   mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
   // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
   // forbids I/O instructions (e.g., inb and outb) from user space
-  mycpu()->ts.iomb = (ushort) 0xFFFF;
+  mycpu()->ts.iomb = (ushort)0xFFFF;
   ltr(SEG_TSS << 3);
-  lcr3(V2P(p->pgdir));  // switch to process's address space
+  lcr3(V2P(p->pgdir)); // switch to process's address space
   popcli();
 }
 
 // Load the initcode into address 0 of pgdir.
 // sz must be less than a page.
-void
-inituvm(pde_t *pgdir, char *init, uint sz)
-{
+void inituvm(pde_t *pgdir, char *init, uint sz) {
   char *mem;
 
-  if(sz >= PGSIZE)
+  if (sz >= PGSIZE)
     panic("inituvm: more than a page");
   mem = kalloc();
   memset(mem, 0, PGSIZE);
-  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
+  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W | PTE_U);
   memmove(mem, init, sz);
 }
 
 // Load a program segment into pgdir.  addr must be page-aligned
 // and the pages from addr to addr+sz must already be mapped.
-int
-loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
-{
+int loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz) {
   uint i, pa, n;
   pte_t *pte;
 
-  if((uint) addr % PGSIZE != 0)
+  if ((uint)addr % PGSIZE != 0)
     panic("loaduvm: addr must be page aligned");
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
+  for (i = 0; i < sz; i += PGSIZE) {
+    if ((pte = walkpgdir(pgdir, addr + i, 0)) == 0)
       panic("loaduvm: address should exist");
     pa = PTE_ADDR(*pte);
-    if(sz - i < PGSIZE)
+    if (sz - i < PGSIZE)
       n = sz - i;
     else
       n = PGSIZE;
-    if(readi(ip, P2V(pa), offset+i, n) != n)
+    if (readi(ip, P2V(pa), offset + i, n) != n)
       return -1;
   }
   return 0;
@@ -236,27 +216,26 @@ loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
 
 // Allocate page tables and physical memory to grow process from oldsz to
 // newsz, which need not be page aligned.  Returns new size or 0 on error.
-int
-allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
-{
+int allocuvm(pde_t *pgdir, uint oldsz, uint newsz) {
   char *mem;
   uint a;
 
-  if(newsz >= KERNBASE)
+  if (newsz >= KERNBASE)
     return 0;
-  if(newsz < oldsz)
+  if (newsz < oldsz)
     return oldsz;
 
   a = PGROUNDUP(oldsz);
-  for(; a < newsz; a += PGSIZE){
+  for (; a < newsz; a += PGSIZE) {
     mem = kalloc();
-    if(mem == 0){
+    if (mem == 0) {
       cprintf("allocuvm out of memory\n");
       deallocuvm(pgdir, newsz, oldsz);
       return 0;
     }
-    memset(mem, 0, PGSIZE); // when load new binary, if there is any gap (memsz - filesz), fill with 0
-    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
+    memset(mem, 0, PGSIZE); // when load new binary, if there is any gap (memsz
+                            // - filesz), fill with 0
+    if (mappages(pgdir, (char *)a, PGSIZE, V2P(mem), PTE_W | PTE_U) < 0) {
       cprintf("allocuvm out of memory (2)\n");
       deallocuvm(pgdir, newsz, oldsz);
       kfree(mem);
@@ -270,23 +249,21 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 // newsz.  oldsz and newsz need not be page-aligned, nor does newsz
 // need to be less than oldsz.  oldsz can be larger than the actual
 // process size.  Returns the new process size.
-int
-deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
-{
+int deallocuvm(pde_t *pgdir, uint oldsz, uint newsz) {
   pte_t *pte;
   uint a, pa;
 
-  if(newsz >= oldsz)
+  if (newsz >= oldsz)
     return oldsz;
 
   a = PGROUNDUP(newsz);
-  for(; a  < oldsz; a += PGSIZE){
-    pte = walkpgdir(pgdir, (char*)a, 0);
-    if(!pte)
+  for (; a < oldsz; a += PGSIZE) {
+    pte = walkpgdir(pgdir, (char *)a, 0);
+    if (!pte)
       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
-    else if((*pte & PTE_P) != 0){
+    else if ((*pte & PTE_P) != 0) {
       pa = PTE_ADDR(*pte);
-      if(pa == 0)
+      if (pa == 0)
         panic("kfree");
       char *v = P2V(pa);
       kfree(v);
@@ -298,77 +275,69 @@ deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 
 // Free a page table and all the physical memory pages
 // in the user part.
-void
-freevm(pde_t *pgdir)
-{
+void freevm(pde_t *pgdir) {
   uint i;
 
-  if(pgdir == 0)
+  if (pgdir == 0)
     panic("freevm: no pgdir");
   deallocuvm(pgdir, KERNBASE, 0);
   // 0 - NPDENTRYIES/2 will map user space
   // we only free user
-  for(i = 0; i < NPDENTRIES/2; i++){
-    if(pgdir[i] & PTE_P){
-      char * v = P2V(PTE_ADDR(pgdir[i]));
+  for (i = 0; i < NPDENTRIES / 2; i++) {
+    if (pgdir[i] & PTE_P) {
+      char *v = P2V(PTE_ADDR(pgdir[i]));
       kfree(v);
     }
   }
-  kfree((char*)pgdir);
+  kfree((char *)pgdir);
 }
 
 // Clear PTE_U on a page. Used to create an inaccessible
 // page beneath the user stack.
-void
-clearpteu(pde_t *pgdir, char *uva)
-{
+void clearpteu(pde_t *pgdir, char *uva) {
   pte_t *pte;
 
   pte = walkpgdir(pgdir, uva, 0);
-  if(pte == 0)
+  if (pte == 0)
     panic("clearpteu");
   *pte &= ~PTE_U;
 }
 
-int hitguardpage(pte_t *pgdir, char *uva)
-{
+int hitguardpage(pte_t *pgdir, char *uva) {
   pte_t *pte;
 
   pte = walkpgdir(pgdir, uva, 0);
   if (pte == 0)
     panic("hitguardpage");
-  if (*pte && !(*pte & PTE_U))
-  {
+  if (*pte && !(*pte & PTE_U)) {
     cprintf("hitguardpage on phy address: 0x%x\n", PTE_ADDR(*pte));
     return 1;
   }
-    
+
   return 0;
 }
 
 // Given a parent process's page table, create a copy
 // of it for a child.
-pde_t*
-copyuvm(pde_t *pgdir, uint sz)
-{
+pde_t *copyuvm(pde_t *pgdir, uint sz) {
   pde_t *d;
   pte_t *pte;
   uint pa, i, flags;
   char *mem;
 
-  if((d = setupkvm()) == 0)
+  if ((d = setupkvm()) == 0)
     return 0;
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+  for (i = 0; i < sz; i += PGSIZE) {
+    if ((pte = walkpgdir(pgdir, (void *)i, 0)) == 0)
       panic("copyuvm: pte should exist");
-    if(!(*pte & PTE_P))
+    if (!(*pte & PTE_P))
       panic("copyuvm: page not present");
     pa = PTE_ADDR(*pte);
     flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
+    if ((mem = kalloc()) == 0)
       goto bad;
-    memmove(mem, (char*)P2V(pa), PGSIZE);
-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
+    memmove(mem, (char *)P2V(pa), PGSIZE);
+    if (mappages(d, (void *)i, PGSIZE, V2P(mem), flags) < 0) {
       kfree(mem);
       goto bad;
     }
@@ -380,38 +349,34 @@ bad:
   return 0;
 }
 
-//PAGEBREAK!
+// PAGEBREAK!
 // Map user virtual address to kernel address.
-char*
-uva2ka(pde_t *pgdir, char *uva)
-{
+char *uva2ka(pde_t *pgdir, char *uva) {
   pte_t *pte;
 
   pte = walkpgdir(pgdir, uva, 0);
-  if((*pte & PTE_P) == 0)
+  if ((*pte & PTE_P) == 0)
     return 0;
-  if((*pte & PTE_U) == 0)
+  if ((*pte & PTE_U) == 0)
     return 0;
-  return (char*)P2V(PTE_ADDR(*pte));
+  return (char *)P2V(PTE_ADDR(*pte));
 }
 
 // Copy len bytes from p to user address va in page table pgdir.
 // Most useful when pgdir is not the current page table.
 // uva2ka ensures this only works for PTE_U pages.
-int
-copyout(pde_t *pgdir, uint va, void *p, uint len)
-{
+int copyout(pde_t *pgdir, uint va, void *p, uint len) {
   char *buf, *pa0;
   uint n, va0;
 
-  buf = (char*)p;
-  while(len > 0){
+  buf = (char *)p;
+  while (len > 0) {
     va0 = (uint)PGROUNDDOWN(va);
-    pa0 = uva2ka(pgdir, (char*)va0);
-    if(pa0 == 0)
+    pa0 = uva2ka(pgdir, (char *)va0);
+    if (pa0 == 0)
       return -1;
     n = PGSIZE - (va - va0);
-    if(n > len)
+    if (n > len)
       n = len;
     memmove(pa0 + (va - va0), buf, n);
     len -= n;
@@ -421,10 +386,9 @@ copyout(pde_t *pgdir, uint va, void *p, uint len)
   return 0;
 }
 
-//PAGEBREAK!
+// PAGEBREAK!
 // Blank page.
-//PAGEBREAK!
+// PAGEBREAK!
 // Blank page.
-//PAGEBREAK!
+// PAGEBREAK!
 // Blank page.
-
diff --git a/wc.c b/wc.c
index d6a54df..1474bb3 100644
--- a/wc.c
+++ b/wc.c
@@ -4,46 +4,42 @@
 
 char buf[512];
 
-void
-wc(int fd, char *name)
-{
+void wc(int fd, char *name) {
   int i, n;
   int l, w, c, inword;
 
   l = w = c = 0;
   inword = 0;
-  while((n = read(fd, buf, sizeof(buf))) > 0){
-    for(i=0; i<n; i++){
+  while ((n = read(fd, buf, sizeof(buf))) > 0) {
+    for (i = 0; i < n; i++) {
       c++;
-      if(buf[i] == '\n')
+      if (buf[i] == '\n')
         l++;
-      if(strchr(" \r\t\n\v", buf[i]))
+      if (strchr(" \r\t\n\v", buf[i]))
         inword = 0;
-      else if(!inword){
+      else if (!inword) {
         w++;
         inword = 1;
       }
     }
   }
-  if(n < 0){
+  if (n < 0) {
     printf(1, "wc: read error\n");
     exit();
   }
   printf(1, "%d %d %d %s\n", l, w, c, name);
 }
 
-int
-main(int argc, char *argv[])
-{
+int main(int argc, char *argv[]) {
   int fd, i;
 
-  if(argc <= 1){
+  if (argc <= 1) {
     wc(0, "");
     exit();
   }
 
-  for(i = 1; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
+  for (i = 1; i < argc; i++) {
+    if ((fd = open(argv[i], 0)) < 0) {
       printf(1, "wc: cannot open %s\n", argv[i]);
       exit();
     }
diff --git a/x86.h b/x86.h
index 07312a5..ec13515 100644
--- a/x86.h
+++ b/x86.h
@@ -1,150 +1,110 @@
 // Routines to let C code use special x86 instructions.
 
-static inline uchar
-inb(ushort port)
-{
+static inline uchar inb(ushort port) {
   uchar data;
 
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+  asm volatile("in %1,%0" : "=a"(data) : "d"(port));
   return data;
 }
 
-static inline void
-insl(int port, void *addr, int cnt)
-{
-  asm volatile("cld; rep insl" :
-               "=D" (addr), "=c" (cnt) :
-               "d" (port), "0" (addr), "1" (cnt) :
-               "memory", "cc");
+static inline void insl(int port, void *addr, int cnt) {
+  asm volatile("cld; rep insl"
+               : "=D"(addr), "=c"(cnt)
+               : "d"(port), "0"(addr), "1"(cnt)
+               : "memory", "cc");
 }
 
-static inline void
-outb(ushort port, uchar data)
-{
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+static inline void outb(ushort port, uchar data) {
+  asm volatile("out %0,%1" : : "a"(data), "d"(port));
 }
 
-static inline void
-outw(ushort port, ushort data)
-{
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+static inline void outw(ushort port, ushort data) {
+  asm volatile("out %0,%1" : : "a"(data), "d"(port));
 }
 
-static inline void
-outsl(int port, const void *addr, int cnt)
-{
-  asm volatile("cld; rep outsl" :
-               "=S" (addr), "=c" (cnt) :
-               "d" (port), "0" (addr), "1" (cnt) :
-               "cc");
+static inline void outsl(int port, const void *addr, int cnt) {
+  asm volatile("cld; rep outsl"
+               : "=S"(addr), "=c"(cnt)
+               : "d"(port), "0"(addr), "1"(cnt)
+               : "cc");
 }
 
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
-               "=D" (addr), "=c" (cnt) :
-               "0" (addr), "1" (cnt), "a" (data) :
-               "memory", "cc");
+static inline void stosb(void *addr, int data, int cnt) {
+  asm volatile("cld; rep stosb"
+               : "=D"(addr), "=c"(cnt)
+               : "0"(addr), "1"(cnt), "a"(data)
+               : "memory", "cc");
 }
 
-static inline void
-stosl(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosl" :
-               "=D" (addr), "=c" (cnt) :
-               "0" (addr), "1" (cnt), "a" (data) :
-               "memory", "cc");
+static inline void stosl(void *addr, int data, int cnt) {
+  asm volatile("cld; rep stosl"
+               : "=D"(addr), "=c"(cnt)
+               : "0"(addr), "1"(cnt), "a"(data)
+               : "memory", "cc");
 }
 
 struct segdesc;
 
-static inline void
-lgdt(struct segdesc *p, int size)
-{
+static inline void lgdt(struct segdesc *p, int size) {
   volatile ushort pd[3];
 
-  pd[0] = size-1;
+  pd[0] = size - 1;
   pd[1] = (uint)p;
   pd[2] = (uint)p >> 16;
 
-  asm volatile("lgdt (%0)" : : "r" (pd));
+  asm volatile("lgdt (%0)" : : "r"(pd));
 }
 
 struct gatedesc;
 
-static inline void
-lidt(struct gatedesc *p, int size)
-{
+static inline void lidt(struct gatedesc *p, int size) {
   volatile ushort pd[3];
 
-  pd[0] = size-1;
+  pd[0] = size - 1;
   pd[1] = (uint)p;
   pd[2] = (uint)p >> 16;
 
-  asm volatile("lidt (%0)" : : "r" (pd));
+  asm volatile("lidt (%0)" : : "r"(pd));
 }
 
-static inline void
-ltr(ushort sel)
-{
-  asm volatile("ltr %0" : : "r" (sel));
-}
+static inline void ltr(ushort sel) { asm volatile("ltr %0" : : "r"(sel)); }
 
-static inline uint
-readeflags(void)
-{
+static inline uint readeflags(void) {
   uint eflags;
-  asm volatile("pushfl; popl %0" : "=r" (eflags));
+  asm volatile("pushfl; popl %0" : "=r"(eflags));
   return eflags;
 }
 
-static inline void
-loadgs(ushort v)
-{
-  asm volatile("movw %0, %%gs" : : "r" (v));
+static inline void loadgs(ushort v) {
+  asm volatile("movw %0, %%gs" : : "r"(v));
 }
 
-static inline void
-cli(void)
-{
-  asm volatile("cli");
-}
+static inline void cli(void) { asm volatile("cli"); }
 
-static inline void
-sti(void)
-{
-  asm volatile("sti");
-}
+static inline void sti(void) { asm volatile("sti"); }
 
-static inline uint
-xchg(volatile uint *addr, uint newval)
-{
+static inline uint xchg(volatile uint *addr, uint newval) {
   uint result;
 
   // The + in "+m" denotes a read-modify-write operand.
-  asm volatile("lock; xchgl %0, %1" :
-               "+m" (*addr), "=a" (result) :
-               "1" (newval) :
-               "cc");
+  asm volatile("lock; xchgl %0, %1"
+               : "+m"(*addr), "=a"(result)
+               : "1"(newval)
+               : "cc");
   return result;
 }
 
-static inline uint
-rcr2(void)
-{
+static inline uint rcr2(void) {
   uint val;
-  asm volatile("movl %%cr2,%0" : "=r" (val));
+  asm volatile("movl %%cr2,%0" : "=r"(val));
   return val;
 }
 
-static inline void
-lcr3(uint val)
-{
-  asm volatile("movl %0,%%cr3" : : "r" (val));
+static inline void lcr3(uint val) {
+  asm volatile("movl %0,%%cr3" : : "r"(val));
 }
 
-//PAGEBREAK: 36
+// PAGEBREAK: 36
 // Layout of the trap frame built on the stack by the
 // hardware and by trapasm.S, and passed to trap().
 struct trapframe {
@@ -152,7 +112,7 @@ struct trapframe {
   uint edi;
   uint esi;
   uint ebp;
-  uint oesp;      // useless & ignored
+  uint oesp; // useless & ignored
   uint ebx;
   uint edx;
   uint ecx;
diff --git a/zombie.c b/zombie.c
index ee817da..b8fd15b 100644
--- a/zombie.c
+++ b/zombie.c
@@ -5,10 +5,8 @@
 #include "stat.h"
 #include "user.h"
 
-int
-main(void)
-{
-  if(fork() > 0)
-    sleep(5);  // Let child exit before parent.
+int main(void) {
+  if (fork() > 0)
+    sleep(5); // Let child exit before parent.
   exit();
 }
-- 
2.24.3 (Apple Git-128)

