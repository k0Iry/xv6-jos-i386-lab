From 765f3781a9247a5b70008da0c38e9ee51fb5e27d Mon Sep 17 00:00:00 2001
From: Aaron <kljsandjb@me.com>
Date: Sun, 14 Jun 2020 23:27:42 +0200
Subject: [PATCH] xv6 pages for the kernel are shared among processes

---
 defs.h |  1 +
 exec.c |  2 +-
 proc.c |  2 +-
 vm.c   | 30 ++++++++++++++++++++++++++++--
 4 files changed, 31 insertions(+), 4 deletions(-)

diff --git a/defs.h b/defs.h
index 8237829..d807866 100644
--- a/defs.h
+++ b/defs.h
@@ -174,6 +174,7 @@ void            uartputc(int);
 void            seginit(void);
 void            kvmalloc(void);
 pde_t*          setupkvm(void);
+pde_t*          setupuvm(void);
 char*           uva2ka(pde_t*, char*);
 int             allocuvm(pde_t*, uint, uint);
 int             deallocuvm(pde_t*, uint, uint);
diff --git a/exec.c b/exec.c
index d8d6738..704ddbd 100644
--- a/exec.c
+++ b/exec.c
@@ -35,7 +35,7 @@ exec(char *path, char **argv)
   if(elf.magic != ELF_MAGIC)
     goto bad;
 
-  if((pgdir = setupkvm()) == 0)
+  if((pgdir = setupuvm()) == 0)
     goto bad;
 
   // Load program into memory.
diff --git a/proc.c b/proc.c
index f0eada5..539eefa 100644
--- a/proc.c
+++ b/proc.c
@@ -126,7 +126,7 @@ userinit(void)
   p = allocproc();
   
   initproc = p;
-  if((p->pgdir = setupkvm()) == 0)    // setup process's page table pages for context switch, mapping kernel content to address space
+  if((p->pgdir = setupuvm()) == 0)    // setup process's page table pages for context switch, mapping kernel content to address space
     panic("userinit: out of memory?");
   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);  // now mapping self's content
   p->sz = PGSIZE;
diff --git a/vm.c b/vm.c
index 1e821ed..e90e4d4 100644
--- a/vm.c
+++ b/vm.c
@@ -135,6 +135,30 @@ setupkvm(void)
   return pgdir;
 }
 
+pde_t *setupuvm(void)
+{
+  pde_t *pgdir;
+  if ((pgdir = (pde_t *)kalloc()) == 0)
+    return 0;
+  memset(pgdir, 0, PGSIZE);
+  // copy pdes from kernel page directory
+  // only copy needed ones, we don't do memmove
+  struct kmap *k;
+  for (k = kmap; k < &kmap[NELEM(kmap)]; k++)
+  {
+    uint sz = k->phys_end - k->phys_start, i;
+    for (i = 0; i <= (sz >> PDXSHIFT); i++)
+    {
+      int idx = PDX(k->virt) + i;
+      if (idx < NPDENTRIES)
+        pgdir[idx] = kpgdir[idx];
+      // cprintf("index is %d\n", PDX(k->virt) + i);
+    }
+  }
+
+  return pgdir;
+}
+
 // Allocate one page table for the machine for the kernel address
 // space for scheduler processes.
 void
@@ -288,7 +312,9 @@ freevm(pde_t *pgdir)
   if(pgdir == 0)
     panic("freevm: no pgdir");
   deallocuvm(pgdir, KERNBASE, 0);
-  for(i = 0; i < NPDENTRIES; i++){
+  // 0 - NPDENTRYIES/2 will map user space
+  // we only free user
+  for(i = 0; i < NPDENTRIES/2; i++){
     if(pgdir[i] & PTE_P){
       char * v = P2V(PTE_ADDR(pgdir[i]));
       kfree(v);
@@ -336,7 +362,7 @@ copyuvm(pde_t *pgdir, uint sz)
   uint pa, i, flags;
   char *mem;
 
-  if((d = setupkvm()) == 0)
+  if((d = setupuvm()) == 0)
     return 0;
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
-- 
2.24.3 (Apple Git-128)

