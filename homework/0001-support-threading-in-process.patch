From da862688b3ab0ae36feb8cc02b1b421be8c3e91e Mon Sep 17 00:00:00 2001
From: Aaron <kljsandjb@me.com>
Date: Mon, 3 Aug 2020 14:43:13 +0000
Subject: [PATCH] support threading in process

to the kernel, it only cares about task unit, in linux it is process

user space threads within a process share code segment,
static memory and heap (dynamic memory),
but have separate processor registers sets and stacks.
---
 defs.h    |  1 +
 proc.c    | 60 ++++++++++++++++++++++++++++++++++++-------------------
 syscall.c |  5 ++++-
 syscall.h |  3 ++-
 sysproc.c | 18 +++++++++++++++++
 user.h    |  1 +
 usys.S    |  1 +
 uthread.c | 21 ++++++++++++++++++-
 vm.c      | 14 ++++++++++++-
 9 files changed, 99 insertions(+), 25 deletions(-)

diff --git a/defs.h b/defs.h
index 8627d58..477b63d 100644
--- a/defs.h
+++ b/defs.h
@@ -123,6 +123,7 @@ void yield(void);
 
 // swtch.S
 void swtch(struct context **, struct context *);
+struct proc *allocthread(uint, uint);
 
 // spinlock.c
 void acquire(struct spinlock *);
diff --git a/proc.c b/proc.c
index bf1fec1..e776696 100644
--- a/proc.c
+++ b/proc.c
@@ -106,6 +106,41 @@ found:
   return p;
 }
 
+// create a new execute thread for a process
+// we clone parent process and tweak the kernel
+// stack for the child, assign the same pid
+struct proc *allocthread(uint eip, uint esp) {
+   extern pde_t *cloneuvm(pde_t *pgdir, uint sz);
+   struct proc *curproc = myproc();
+   struct proc *child = allocproc();
+   if (!child)
+     return child;
+
+   // clone the child
+   child->pgdir = cloneuvm(curproc->pgdir, curproc->sz);
+   child->sz = curproc->sz;
+   
+   // copy necessary segment registers and eflags
+   child->tf->cs = curproc->tf->cs;
+   child->tf->ds = curproc->tf->ds;
+   child->tf->es = curproc->tf->es;
+   child->tf->ss = curproc->tf->ss;
+   child->tf->fs = curproc->tf->fs;
+   child->tf->gs = curproc->tf->gs;
+   child->tf->eflags = curproc->tf->eflags;
+
+   child->tf->eip = eip;
+   child->tf->esp = esp;
+
+   acquire(&ptable.lock);
+
+   child->state = RUNNABLE;
+
+   release(&ptable.lock);
+
+   return child;
+}
+
 // PAGEBREAK: 32
 // Set up first user process.
 void userinit(void) {
@@ -123,6 +158,10 @@ void userinit(void) {
           (int)_binary_initcode_size); // now mapping self's content
   p->sz = PGSIZE;
   memset(p->tf, 0, sizeof(*p->tf));
+  // we need to set low 2 bits in CS, otherwise
+  // user program would instead use kernel stack
+  // when trapped into kernel, we will fail to
+  // fetch the syscall arguments (%esp & %cs keep same)
   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
   p->tf->es = p->tf->ds;
@@ -146,27 +185,6 @@ void userinit(void) {
   release(&ptable.lock);
 }
 
-// Grow current process's memory by n bytes.
-// Return 0 on success, -1 on failure.
-// int
-// growproc(int n)
-// {
-//   uint sz;
-//   struct proc *curproc = myproc();
-
-//   sz = curproc->sz;
-//   if(n > 0){
-//     if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
-//       return -1;
-//   } else if(n < 0){
-//     if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
-//       return -1;
-//   }
-//   curproc->sz = sz;
-//   switchuvm(curproc);
-//   return 0;
-// }
-
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
diff --git a/syscall.c b/syscall.c
index 032695d..8ed28f4 100644
--- a/syscall.c
+++ b/syscall.c
@@ -96,6 +96,7 @@ extern int sys_uptime(void);
 extern int sys_date(void);
 extern int sys_dup2(void);
 extern int sys_alarm(void);
+extern int sys_create_thread(void);
 
 // we register syscall interfaces here
 static int (*syscalls[])(void) = {
@@ -107,6 +108,7 @@ static int (*syscalls[])(void) = {
     [SYS_write] sys_write, [SYS_mknod] sys_mknod,   [SYS_unlink] sys_unlink,
     [SYS_link] sys_link,   [SYS_mkdir] sys_mkdir,   [SYS_close] sys_close,
     [SYS_date] sys_date,   [SYS_dup2] sys_dup2,     [SYS_alarm] sys_alarm,
+    [SYS_uthread_create] sys_create_thread,
 };
 
 // use a string table for the name, any better idea?
@@ -120,6 +122,7 @@ static char *syscallnames[] = {
     [SYS_write] "write", [SYS_mknod] "mknod",   [SYS_unlink] "unlink",
     [SYS_link] "link",   [SYS_mkdir] "mkdir",   [SYS_close] "close",
     [SYS_date] "date",   [SYS_dup2] "dup2",     [SYS_alarm] "alarm",
+    [SYS_uthread_create] "create_thread",
 };
 
 // breakpoint here, x/37x
@@ -164,7 +167,7 @@ void syscall(void) {
     //   cprintf("first argument: %s\n", argument);
 
     curproc->tf->eax = syscalls[num]();
-    if (num != 16)
+    if (num != SYS_write)
       cprintf("%s -> %d\n\n", syscallnames[num], curproc->tf->eax);
   } else {
     cprintf("%d %s: unknown sys call %d\n", curproc->pid, curproc->name, num);
diff --git a/syscall.h b/syscall.h
index f1bcf02..d9f0fc7 100644
--- a/syscall.h
+++ b/syscall.h
@@ -22,4 +22,5 @@
 #define SYS_close 21
 #define SYS_date 22
 #define SYS_dup2 23
-#define SYS_alarm 24
\ No newline at end of file
+#define SYS_alarm 24
+#define SYS_uthread_create 25
\ No newline at end of file
diff --git a/sysproc.c b/sysproc.c
index 3d35ace..be80a75 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -103,3 +103,21 @@ int sys_alarm(void) {
   myproc()->ticksleft = ticks;
   return 0;
 }
+
+int sys_create_thread(void) {
+   int thread_id;
+   void (*entry)();
+   int esp;
+   if (argint(0, &thread_id) < 0)
+     return -1;
+   if (argptr(1, (char **)&entry, 4) < 0)
+     return -1;
+   if (argint(2, &esp) < 0)
+     return -1;
+   
+   struct proc *t;
+   if ((t= allocthread((uint)entry, esp)) == 0)
+     return -1;
+
+   return 0;
+}
\ No newline at end of file
diff --git a/user.h b/user.h
index 859f982..04bda7b 100644
--- a/user.h
+++ b/user.h
@@ -26,6 +26,7 @@ int sleep(int);
 int uptime(void);
 int date(struct rtcdate *);
 int alarm(uint, void (*)());
+int uthread_create(uint, uint, uint);
 
 // ulib.c
 int stat(const char *, struct stat *);
diff --git a/usys.S b/usys.S
index 14f284b..5730172 100644
--- a/usys.S
+++ b/usys.S
@@ -33,3 +33,4 @@ SYSCALL(uptime)
 SYSCALL(date)
 SYSCALL(dup2)
 SYSCALL(alarm)
+SYSCALL(uthread_create)
\ No newline at end of file
diff --git a/uthread.c b/uthread.c
index 66fc1f8..225c713 100644
--- a/uthread.c
+++ b/uthread.c
@@ -35,6 +35,7 @@ thread_init(void)
   current_thread->state = RUNNING;
 }
 
+// make multiple CPUs enter the thread scheduler, pick the thread and run respectively
 static void 
 thread_schedule(void)
 {
@@ -66,6 +67,16 @@ thread_schedule(void)
     next_thread = 0;
 }
 
+/*
+ once we create a thread, maybe we need to add it
+ to the group in the kernel, so the kernel could
+ assign idle CPUs to it (via system call)
+
+ but this group should be per process owned, maybe
+ we can add this in struct proc (kernel code),
+ could be a linked-list so that we can dynamically
+ update it
+*/
 void 
 thread_create(void (*func)())
 {
@@ -79,6 +90,14 @@ thread_create(void (*func)())
   * (int *) (t->sp) = (int)func;           // push return address on stack
   t->sp -= 32;                             // space for registers that thread_switch expects
   t->state = RUNNABLE;
+
+  // make a system call, pass the thread_schedule() to the kernel,
+  // let idle CPUs enter the scheduler
+  if (uthread_create((uint)t, (uint)func, (uint)t->sp) != 0)
+  {
+     printf(2, "uthread_create syscall failed!\n");
+     exit();
+  }
 }
 
 void 
@@ -108,7 +127,7 @@ main(int argc, char *argv[])
 {
   thread_init();
   thread_create(mythread);
-  thread_create(mythread);
+  // thread_create(mythread);
   thread_schedule();
   return 0;
 }
diff --git a/vm.c b/vm.c
index f2c46d7..cf542c4 100644
--- a/vm.c
+++ b/vm.c
@@ -126,13 +126,25 @@ pde_t *setupkvm(void) {
       int idx = PDX(k->virt) + i;
       if (idx < NPDENTRIES)
         pgdir[idx] = kpgdir[idx];
-      // cprintf("index is %d\n", PDX(k->virt) + i);
     }
   }
 
   return pgdir;
 }
 
+// clone a child process by only copying page tables
+pde_t *cloneuvm(pde_t *pgdir, uint sz) {
+  pde_t *p;
+  if ((p = setupkvm()) == 0)
+    return 0;
+  sz = sz >> PDXSHIFT;
+  int i = 0;
+  for (; i <= sz; i++)
+    p[i] = pgdir[i];
+
+  return p;
+}
+
 // Allocate one page table for the machine for the kernel address
 // space for scheduler processes.
 void kvmalloc(void) {
-- 
2.20.1

